\hypertarget{catch_8hpp_source}{}\doxysection{catch.\+hpp}
\label{catch_8hpp_source}\index{cmake-\/build-\/debug/\_deps/sfml-\/src/extlibs/headers/catch.hpp@{cmake-\/build-\/debug/\_deps/sfml-\/src/extlibs/headers/catch.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ *  Catch v1.12.2}}
\DoxyCodeLine{3 \textcolor{comment}{ *  Generated: 2018-\/05-\/14 15:10:01.112442}}
\DoxyCodeLine{4 \textcolor{comment}{ *  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5 \textcolor{comment}{ *  This file has been merged from multiple headers. Please don't edit it directly}}
\DoxyCodeLine{6 \textcolor{comment}{ *  Copyright (c) 2012 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{7 \textcolor{comment}{ *}}
\DoxyCodeLine{8 \textcolor{comment}{ *  Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{9 \textcolor{comment}{ *  file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{10 \textcolor{comment}{ */}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#    pragma clang system\_header}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#    pragma GCC system\_header}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{comment}{// \#included from: internal/catch\_suppress\_warnings.h}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#   ifdef \_\_ICC }\textcolor{comment}{// icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#       pragma warning(push)}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#       pragma warning(disable: 161 1682)}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#   else }\textcolor{comment}{// \_\_ICC}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wglobal-\/constructors"{}}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wvariadic-\/macros"{}}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wc99-\/extensions"{}}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wunused-\/variable"{}}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#       pragma clang diagnostic push}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wc++98-\/compat"{}}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wc++98-\/compat-\/pedantic"{}}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wswitch-\/enum"{}}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wcovered-\/switch-\/default"{}}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wvariadic-\/macros"{}}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wunused-\/variable"{}}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wparentheses"{}}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_MAIN) || defined(CATCH\_CONFIG\_RUNNER)}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#  define CATCH\_IMPL}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#  ifndef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{58 }
\DoxyCodeLine{59 \textcolor{comment}{// \#included from: internal/catch\_notimplemented\_exception.h}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_NOTIMPLEMENTED\_EXCEPTION\_H\_INCLUDED}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62 \textcolor{comment}{// \#included from: catch\_common.h}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_COMMON\_H\_INCLUDED}}
\DoxyCodeLine{64 }
\DoxyCodeLine{65 \textcolor{comment}{// \#included from: catch\_compiler\_capabilities.h}}
\DoxyCodeLine{66 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_COMPILER\_CAPABILITIES\_HPP\_INCLUDED}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 \textcolor{comment}{// Detect a number of compiler features -\/ mostly C++11/14 conformance -\/ by compiler}}
\DoxyCodeLine{69 \textcolor{comment}{// The following features are defined:}}
\DoxyCodeLine{70 \textcolor{comment}{//}}
\DoxyCodeLine{71 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_NULLPTR : is nullptr supported?}}
\DoxyCodeLine{72 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_NOEXCEPT : is noexcept supported?}}
\DoxyCodeLine{73 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS : The delete and default keywords for compiler generated methods}}
\DoxyCodeLine{74 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_IS\_ENUM : std::is\_enum is supported?}}
\DoxyCodeLine{75 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_TUPLE : std::tuple is supported}}
\DoxyCodeLine{76 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_LONG\_LONG : is long long supported?}}
\DoxyCodeLine{77 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_OVERRIDE : is override supported?}}
\DoxyCodeLine{78 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_UNIQUE\_PTR : is unique\_ptr supported (otherwise use auto\_ptr)}}
\DoxyCodeLine{79 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_SHUFFLE : is std::shuffle supported?}}
\DoxyCodeLine{80 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_TYPE\_TRAITS : are type\_traits and enable\_if supported?}}
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \textcolor{comment}{// CATCH\_CONFIG\_CPP11\_OR\_GREATER : Is C++11 supported?}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{comment}{// CATCH\_CONFIG\_VARIADIC\_MACROS : are variadic macros supported?}}
\DoxyCodeLine{85 \textcolor{comment}{// CATCH\_CONFIG\_COUNTER : is the \_\_COUNTER\_\_ macro supported?}}
\DoxyCodeLine{86 \textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH : is Windows SEH supported?}}
\DoxyCodeLine{87 \textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS : are POSIX signals supported?}}
\DoxyCodeLine{88 \textcolor{comment}{// ****************}}
\DoxyCodeLine{89 \textcolor{comment}{// Note to maintainers: if new toggles are added please document them}}
\DoxyCodeLine{90 \textcolor{comment}{// in configuration.md, too}}
\DoxyCodeLine{91 \textcolor{comment}{// ****************}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93 \textcolor{comment}{// In general each macro has a \_NO\_<feature name> form}}
\DoxyCodeLine{94 \textcolor{comment}{// (e.g. CATCH\_CONFIG\_CPP11\_NO\_NULLPTR) which disables the feature.}}
\DoxyCodeLine{95 \textcolor{comment}{// Many features, at point of detection, define an \_INTERNAL\_ macro, so they}}
\DoxyCodeLine{96 \textcolor{comment}{// can be combined, en-\/mass, with the \_NO\_ forms later.}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{comment}{// All the C++11 features can be disabled with CATCH\_CONFIG\_NO\_CPP11}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{preprocessor}{\#  if \_\_cplusplus >= 201103L}}
\DoxyCodeLine{103 \textcolor{preprocessor}{\#    define CATCH\_CPP11\_OR\_GREATER}}
\DoxyCodeLine{104 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{preprocessor}{\#  if \_\_cplusplus >= 201402L}}
\DoxyCodeLine{107 \textcolor{preprocessor}{\#    define CATCH\_CPP14\_OR\_GREATER}}
\DoxyCodeLine{108 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{109 }
\DoxyCodeLine{110 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 \textcolor{preprocessor}{\#  if \_\_has\_feature(cxx\_nullptr)}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{116 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{preprocessor}{\#  if \_\_has\_feature(cxx\_noexcept)}}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{120 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 \textcolor{preprocessor}{\#   if defined(CATCH\_CPP11\_OR\_GREATER)}}
\DoxyCodeLine{123 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{124 \textcolor{preprocessor}{            \_Pragma( "{}clang diagnostic push"{}} ) \(\backslash\)}
\DoxyCodeLine{125             \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wexit-\/time-\/destructors\(\backslash\)"{}"{} )}
\DoxyCodeLine{126 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{127 \textcolor{preprocessor}{            \_Pragma( "{}clang diagnostic pop"{}} )}
\DoxyCodeLine{128 }
\DoxyCodeLine{129 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{130 \textcolor{preprocessor}{            \_Pragma( "{}clang diagnostic push"{}} ) \(\backslash\)}
\DoxyCodeLine{131             \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wparentheses\(\backslash\)"{}"{} )}
\DoxyCodeLine{132 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_UNSUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{133 \textcolor{preprocessor}{            \_Pragma( "{}clang diagnostic pop"{}} )}
\DoxyCodeLine{134 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_clang\_\_}}
\DoxyCodeLine{137 }
\DoxyCodeLine{139 \textcolor{comment}{// We know some environments not to support full POSIX signals}}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#if defined(\_\_CYGWIN\_\_) || defined(\_\_QNX\_\_)}}
\DoxyCodeLine{141 }
\DoxyCodeLine{142 \textcolor{preprocessor}{\#   if !defined(CATCH\_CONFIG\_POSIX\_SIGNALS)}}
\DoxyCodeLine{143 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{144 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{145 }
\DoxyCodeLine{146 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 \textcolor{preprocessor}{\#ifdef \_\_OS400\_\_}}
\DoxyCodeLine{149 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{150 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{151 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{152 }
\DoxyCodeLine{154 \textcolor{comment}{// Cygwin}}
\DoxyCodeLine{155 \textcolor{preprocessor}{\#ifdef \_\_CYGWIN\_\_}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{comment}{// Required for some versions of Cygwin to declare gettimeofday}}
\DoxyCodeLine{158 \textcolor{comment}{// see: http://stackoverflow.com/questions/36901803/gettimeofday-\/not-\/declared-\/in-\/this-\/scope-\/cygwin}}
\DoxyCodeLine{159 \textcolor{preprocessor}{\#   define \_BSD\_SOURCE}}
\DoxyCodeLine{160 }
\DoxyCodeLine{161 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_CYGWIN\_\_}}
\DoxyCodeLine{162 }
\DoxyCodeLine{164 \textcolor{comment}{// Borland}}
\DoxyCodeLine{165 \textcolor{preprocessor}{\#ifdef \_\_BORLANDC\_\_}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_BORLANDC\_\_}}
\DoxyCodeLine{168 }
\DoxyCodeLine{170 \textcolor{comment}{// EDG}}
\DoxyCodeLine{171 \textcolor{preprocessor}{\#ifdef \_\_EDG\_VERSION\_\_}}
\DoxyCodeLine{172 }
\DoxyCodeLine{173 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_EDG\_VERSION\_\_}}
\DoxyCodeLine{174 }
\DoxyCodeLine{176 \textcolor{comment}{// Digital Mars}}
\DoxyCodeLine{177 \textcolor{preprocessor}{\#ifdef \_\_DMC\_\_}}
\DoxyCodeLine{178 }
\DoxyCodeLine{179 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_DMC\_\_}}
\DoxyCodeLine{180 }
\DoxyCodeLine{182 \textcolor{comment}{// GCC}}
\DoxyCodeLine{183 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 \textcolor{preprocessor}{\#   if \_\_GNUC\_\_ == 4 \&\& \_\_GNUC\_MINOR\_\_ >= 6 \&\& defined(\_\_GXX\_EXPERIMENTAL\_CXX0X\_\_)}}
\DoxyCodeLine{186 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{187 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{188 }
\DoxyCodeLine{189 \textcolor{comment}{// -\/ otherwise more recent versions define \_\_cplusplus >= 201103L}}
\DoxyCodeLine{190 \textcolor{comment}{// and will get picked up below}}
\DoxyCodeLine{191 }
\DoxyCodeLine{192 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_GNUC\_\_}}
\DoxyCodeLine{193 }
\DoxyCodeLine{195 \textcolor{comment}{// Visual C++}}
\DoxyCodeLine{196 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{197 }
\DoxyCodeLine{198 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{199 }
\DoxyCodeLine{200 \textcolor{preprocessor}{\#if (\_MSC\_VER >= 1600)}}
\DoxyCodeLine{201 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{202 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_CONFIG\_CPP11\_UNIQUE\_PTR}}
\DoxyCodeLine{203 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205 \textcolor{preprocessor}{\#if (\_MSC\_VER >= 1900 ) }\textcolor{comment}{// (VC++ 13 (VS2015))}}
\DoxyCodeLine{206 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{207 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_CPP11\_SHUFFLE}}
\DoxyCodeLine{209 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_CPP11\_TYPE\_TRAITS}}
\DoxyCodeLine{210 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{211 }
\DoxyCodeLine{212 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{213 }
\DoxyCodeLine{215 }
\DoxyCodeLine{216 \textcolor{comment}{// Use variadic macros if the compiler supports them}}
\DoxyCodeLine{217 \textcolor{preprocessor}{\#if ( defined \_MSC\_VER \&\& \_MSC\_VER > 1400 \&\& !defined \_\_EDGE\_\_) || \(\backslash\)}}
\DoxyCodeLine{218 \textcolor{preprocessor}{    ( defined \_\_WAVE\_\_ \&\& \_\_WAVE\_HAS\_VARIADICS ) || \(\backslash\)}}
\DoxyCodeLine{219 \textcolor{preprocessor}{    ( defined \_\_GNUC\_\_ \&\& \_\_GNUC\_\_ >= 3 ) || \(\backslash\)}}
\DoxyCodeLine{220 \textcolor{preprocessor}{    ( !defined \_\_cplusplus \&\& \_\_STDC\_VERSION\_\_ >= 199901L || \_\_cplusplus >= 201103L )}}
\DoxyCodeLine{221 }
\DoxyCodeLine{222 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{223 }
\DoxyCodeLine{224 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{225 }
\DoxyCodeLine{226 \textcolor{comment}{// Use \_\_COUNTER\_\_ if the compiler supports it}}
\DoxyCodeLine{227 \textcolor{preprocessor}{\#if ( defined \_MSC\_VER \&\& \_MSC\_VER >= 1300 ) || \(\backslash\)}}
\DoxyCodeLine{228 \textcolor{preprocessor}{    ( defined \_\_GNUC\_\_  \&\& ( \_\_GNUC\_\_ > 4 || (\_\_GNUC\_\_ == 4 \&\& \_\_GNUC\_MINOR\_\_ >= 3 )) ) || \(\backslash\)}}
\DoxyCodeLine{229 \textcolor{preprocessor}{    ( defined \_\_clang\_\_ \&\& \_\_clang\_major\_\_ >= 3 )}}
\DoxyCodeLine{230 }
\DoxyCodeLine{231 \textcolor{comment}{// Use of \_\_COUNTER\_\_ is suppressed during code analysis in CLion/AppCode 2017.2.x and former,}}
\DoxyCodeLine{232 \textcolor{comment}{// because \_\_COUNTER\_\_ is not properly handled by it.}}
\DoxyCodeLine{233 \textcolor{comment}{// This does not affect compilation}}
\DoxyCodeLine{234 \textcolor{preprocessor}{\#if ( !defined \_\_JETBRAINS\_IDE\_\_ || \_\_JETBRAINS\_IDE\_\_ >= 20170300L )}}
\DoxyCodeLine{235 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_COUNTER}}
\DoxyCodeLine{236 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{237 }
\DoxyCodeLine{238 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{239 }
\DoxyCodeLine{241 \textcolor{comment}{// C++ language feature support}}
\DoxyCodeLine{242 }
\DoxyCodeLine{243 \textcolor{comment}{// catch all support for C++11}}
\DoxyCodeLine{244 \textcolor{preprocessor}{\#if defined(CATCH\_CPP11\_OR\_GREATER)}}
\DoxyCodeLine{245 }
\DoxyCodeLine{246 \textcolor{preprocessor}{\#  if !defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_NULLPTR)}}
\DoxyCodeLine{247 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{248 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{249 }
\DoxyCodeLine{250 \textcolor{preprocessor}{\#  ifndef CATCH\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{251 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{252 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{253 }
\DoxyCodeLine{254 \textcolor{preprocessor}{\#  ifndef CATCH\_INTERNAL\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{255 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{256 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{257 }
\DoxyCodeLine{258 \textcolor{preprocessor}{\#  ifndef CATCH\_INTERNAL\_CONFIG\_CPP11\_IS\_ENUM}}
\DoxyCodeLine{259 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_IS\_ENUM}}
\DoxyCodeLine{260 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{261 }
\DoxyCodeLine{262 \textcolor{preprocessor}{\#  ifndef CATCH\_INTERNAL\_CONFIG\_CPP11\_TUPLE}}
\DoxyCodeLine{263 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_TUPLE}}
\DoxyCodeLine{264 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266 \textcolor{preprocessor}{\#  ifndef CATCH\_INTERNAL\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{267 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{268 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{269 }
\DoxyCodeLine{270 \textcolor{preprocessor}{\#  if !defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_LONG\_LONG)}}
\DoxyCodeLine{271 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_LONG\_LONG}}
\DoxyCodeLine{272 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{273 }
\DoxyCodeLine{274 \textcolor{preprocessor}{\#  if !defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_OVERRIDE)}}
\DoxyCodeLine{275 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_OVERRIDE}}
\DoxyCodeLine{276 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{277 \textcolor{preprocessor}{\#  if !defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_UNIQUE\_PTR)}}
\DoxyCodeLine{278 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP11\_UNIQUE\_PTR}}
\DoxyCodeLine{279 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{280 \textcolor{preprocessor}{\# if !defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_SHUFFLE)}}
\DoxyCodeLine{281 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_CONFIG\_CPP11\_SHUFFLE}}
\DoxyCodeLine{282 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{283 \textcolor{preprocessor}{\# if !defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_TYPE\_TRAITS)}}
\DoxyCodeLine{284 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_CPP11\_TYPE\_TRAITS}}
\DoxyCodeLine{285 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_cplusplus >= 201103L}}
\DoxyCodeLine{288 }
\DoxyCodeLine{289 \textcolor{comment}{// Now set the actual defines based on the above + anything the user has configured}}
\DoxyCodeLine{290 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_NULLPTR) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_NULLPTR) \&\& !defined(CATCH\_CONFIG\_CPP11\_NULLPTR) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{291 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{292 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{293 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_NOEXCEPT) \&\& !defined(CATCH\_CONFIG\_CPP11\_NOEXCEPT) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{294 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{295 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{296 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_GENERATED\_METHODS) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_GENERATED\_METHODS) \&\& !defined(CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{297 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{298 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{299 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_IS\_ENUM) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_IS\_ENUM) \&\& !defined(CATCH\_CONFIG\_CPP11\_IS\_ENUM) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{300 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_IS\_ENUM}}
\DoxyCodeLine{301 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{302 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_TUPLE) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_TUPLE) \&\& !defined(CATCH\_CONFIG\_CPP11\_TUPLE) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{303 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_TUPLE}}
\DoxyCodeLine{304 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{305 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_VARIADIC\_MACROS) \&\& !defined(CATCH\_CONFIG\_NO\_VARIADIC\_MACROS) \&\& !defined(CATCH\_CONFIG\_VARIADIC\_MACROS)}}
\DoxyCodeLine{306 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{307 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{308 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_LONG\_LONG) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_LONG\_LONG) \&\& !defined(CATCH\_CONFIG\_CPP11\_LONG\_LONG) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{309 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_LONG\_LONG}}
\DoxyCodeLine{310 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{311 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_OVERRIDE) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_OVERRIDE) \&\& !defined(CATCH\_CONFIG\_CPP11\_OVERRIDE) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{312 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_OVERRIDE}}
\DoxyCodeLine{313 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{314 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_UNIQUE\_PTR) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_UNIQUE\_PTR) \&\& !defined(CATCH\_CONFIG\_CPP11\_UNIQUE\_PTR) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{315 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_UNIQUE\_PTR}}
\DoxyCodeLine{316 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{317 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_COUNTER) \&\& !defined(CATCH\_CONFIG\_NO\_COUNTER) \&\& !defined(CATCH\_CONFIG\_COUNTER)}}
\DoxyCodeLine{318 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{319 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{320 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_SHUFFLE) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_SHUFFLE) \&\& !defined(CATCH\_CONFIG\_CPP11\_SHUFFLE) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{321 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_CPP11\_SHUFFLE}}
\DoxyCodeLine{322 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{323 \textcolor{preprocessor}{\# if defined(CATCH\_INTERNAL\_CONFIG\_CPP11\_TYPE\_TRAITS) \&\& !defined(CATCH\_CONFIG\_CPP11\_NO\_TYPE\_TRAITS) \&\& !defined(CATCH\_CONFIG\_CPP11\_TYPE\_TRAITS) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{324 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP11\_TYPE\_TRAITS}}
\DoxyCodeLine{325 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{326 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_NO\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_WINDOWS\_SEH)}}
\DoxyCodeLine{327 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{328 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{329 \textcolor{comment}{// This is set by default, because we assume that unix compilers are posix-\/signal-\/compatible by default.}}
\DoxyCodeLine{330 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_POSIX\_SIGNALS)}}
\DoxyCodeLine{331 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{332 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{333 }
\DoxyCodeLine{334 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS)}}
\DoxyCodeLine{335 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS}}
\DoxyCodeLine{336 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_UNSUPPRESS\_PARENTHESES\_WARNINGS}}
\DoxyCodeLine{337 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{338 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS)}}
\DoxyCodeLine{339 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS}}
\DoxyCodeLine{340 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS}}
\DoxyCodeLine{341 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{342 }
\DoxyCodeLine{343 \textcolor{comment}{// noexcept support:}}
\DoxyCodeLine{344 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_NOEXCEPT) \&\& !defined(CATCH\_NOEXCEPT)}}
\DoxyCodeLine{345 \textcolor{preprocessor}{\#  define CATCH\_NOEXCEPT noexcept}}
\DoxyCodeLine{346 \textcolor{preprocessor}{\#  define CATCH\_NOEXCEPT\_IS(x) noexcept(x)}}
\DoxyCodeLine{347 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{348 \textcolor{preprocessor}{\#  define CATCH\_NOEXCEPT throw()}}
\DoxyCodeLine{349 \textcolor{preprocessor}{\#  define CATCH\_NOEXCEPT\_IS(x)}}
\DoxyCodeLine{350 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{351 }
\DoxyCodeLine{352 \textcolor{comment}{// nullptr support}}
\DoxyCodeLine{353 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{354 \textcolor{preprocessor}{\#   define CATCH\_NULL nullptr}}
\DoxyCodeLine{355 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{356 \textcolor{preprocessor}{\#   define CATCH\_NULL NULL}}
\DoxyCodeLine{357 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{358 }
\DoxyCodeLine{359 \textcolor{comment}{// override support}}
\DoxyCodeLine{360 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_OVERRIDE}}
\DoxyCodeLine{361 \textcolor{preprocessor}{\#   define CATCH\_OVERRIDE override}}
\DoxyCodeLine{362 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{363 \textcolor{preprocessor}{\#   define CATCH\_OVERRIDE}}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{365 }
\DoxyCodeLine{366 \textcolor{comment}{// unique\_ptr support}}
\DoxyCodeLine{367 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_UNIQUE\_PTR}}
\DoxyCodeLine{368 \textcolor{preprocessor}{\#   define CATCH\_AUTO\_PTR( T ) std::unique\_ptr<T>}}
\DoxyCodeLine{369 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{370 \textcolor{preprocessor}{\#   define CATCH\_AUTO\_PTR( T ) std::auto\_ptr<T>}}
\DoxyCodeLine{371 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{372 }
\DoxyCodeLine{373 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line ) name\#\#line}}
\DoxyCodeLine{374 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, line ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line )}}
\DoxyCodeLine{375 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{376 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_COUNTER\_\_ )}}
\DoxyCodeLine{377 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{378 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_LINE\_\_ )}}
\DoxyCodeLine{379 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{380 }
\DoxyCodeLine{381 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIFY2( expr ) \#expr}}
\DoxyCodeLine{382 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIFY( expr ) INTERNAL\_CATCH\_STRINGIFY2( expr )}}
\DoxyCodeLine{383 }
\DoxyCodeLine{384 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{385 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{386 }
\DoxyCodeLine{387 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{388 }
\DoxyCodeLine{389     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{390 }
\DoxyCodeLine{391     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1CaseSensitive}{CaseSensitive}} \{ \textcolor{keyword}{enum} Choice \{}
\DoxyCodeLine{392         Yes,}
\DoxyCodeLine{393         No}
\DoxyCodeLine{394     \}; \};}
\DoxyCodeLine{395 }
\DoxyCodeLine{396     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{397 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{398         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \textcolor{keyword}{const}\& )              = \textcolor{keyword}{delete};}
\DoxyCodeLine{399         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \&\& )                  = \textcolor{keyword}{delete};}
\DoxyCodeLine{400         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{401         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \&\& )     = \textcolor{keyword}{delete};}
\DoxyCodeLine{402 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{403         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{404         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \textcolor{keyword}{const}\& );}
\DoxyCodeLine{405 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{406 }
\DoxyCodeLine{407     \textcolor{keyword}{protected}:}
\DoxyCodeLine{408         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}() \{\}}
\DoxyCodeLine{409         \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1NonCopyable}{\string~NonCopyable}}();}
\DoxyCodeLine{410     \};}
\DoxyCodeLine{411 }
\DoxyCodeLine{412     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1SafeBool}{SafeBool}} \{}
\DoxyCodeLine{413     \textcolor{keyword}{public}:}
\DoxyCodeLine{414         \textcolor{keyword}{typedef} void (\mbox{\hyperlink{classCatch_1_1SafeBool}{SafeBool}}::*type)() \textcolor{keyword}{const};}
\DoxyCodeLine{415 }
\DoxyCodeLine{416         \textcolor{keyword}{static} type makeSafe( \textcolor{keywordtype}{bool} value ) \{}
\DoxyCodeLine{417             \textcolor{keywordflow}{return} value ? \&SafeBool::trueValue : 0;}
\DoxyCodeLine{418         \}}
\DoxyCodeLine{419     \textcolor{keyword}{private}:}
\DoxyCodeLine{420         \textcolor{keywordtype}{void} trueValue()\textcolor{keyword}{ const }\{\}}
\DoxyCodeLine{421     \};}
\DoxyCodeLine{422 }
\DoxyCodeLine{423     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ContainerT>}
\DoxyCodeLine{424     \textcolor{keywordtype}{void} deleteAll( ContainerT\& container ) \{}
\DoxyCodeLine{425         \textcolor{keyword}{typename} ContainerT::const\_iterator it = container.begin();}
\DoxyCodeLine{426         \textcolor{keyword}{typename} ContainerT::const\_iterator itEnd = container.end();}
\DoxyCodeLine{427         \textcolor{keywordflow}{for}(; it != itEnd; ++it )}
\DoxyCodeLine{428             \textcolor{keyword}{delete} *it;}
\DoxyCodeLine{429     \}}
\DoxyCodeLine{430     \textcolor{keyword}{template}<\textcolor{keyword}{typename} AssociativeContainerT>}
\DoxyCodeLine{431     \textcolor{keywordtype}{void} deleteAllValues( AssociativeContainerT\& container ) \{}
\DoxyCodeLine{432         \textcolor{keyword}{typename} AssociativeContainerT::const\_iterator it = container.begin();}
\DoxyCodeLine{433         \textcolor{keyword}{typename} AssociativeContainerT::const\_iterator itEnd = container.end();}
\DoxyCodeLine{434         \textcolor{keywordflow}{for}(; it != itEnd; ++it )}
\DoxyCodeLine{435             \textcolor{keyword}{delete} it-\/>second;}
\DoxyCodeLine{436     \}}
\DoxyCodeLine{437 }
\DoxyCodeLine{438     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix );}
\DoxyCodeLine{439     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix );}
\DoxyCodeLine{440     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix );}
\DoxyCodeLine{441     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix );}
\DoxyCodeLine{442     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix );}
\DoxyCodeLine{443     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s );}
\DoxyCodeLine{444     std::string toLower( std::string \textcolor{keyword}{const}\& s );}
\DoxyCodeLine{445     std::string trim( std::string \textcolor{keyword}{const}\& str );}
\DoxyCodeLine{446     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis );}
\DoxyCodeLine{447 }
\DoxyCodeLine{448     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}} \{}
\DoxyCodeLine{449         \mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}}( std::size\_t count, std::string \textcolor{keyword}{const}\& label );}
\DoxyCodeLine{450 }
\DoxyCodeLine{451         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}} \textcolor{keyword}{const}\& pluraliser );}
\DoxyCodeLine{452 }
\DoxyCodeLine{453         std::size\_t m\_count;}
\DoxyCodeLine{454         std::string m\_label;}
\DoxyCodeLine{455     \};}
\DoxyCodeLine{456 }
\DoxyCodeLine{457     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \{}
\DoxyCodeLine{458 }
\DoxyCodeLine{459         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}();}
\DoxyCodeLine{460         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \_file, std::size\_t \_line );}
\DoxyCodeLine{461 \textcolor{preprocessor}{\#  ifdef CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{462         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}(\mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other)          = \textcolor{keywordflow}{default};}
\DoxyCodeLine{463         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{464         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{465         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{466 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{467         \textcolor{keywordtype}{bool} empty() \textcolor{keyword}{const};}
\DoxyCodeLine{468         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{469         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{470 }
\DoxyCodeLine{471         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* file;}
\DoxyCodeLine{472         std::size\_t line;}
\DoxyCodeLine{473     \};}
\DoxyCodeLine{474 }
\DoxyCodeLine{475     std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{476 }
\DoxyCodeLine{477     \textcolor{comment}{// This is just here to avoid compiler warnings with macro constants and boolean literals}}
\DoxyCodeLine{478     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isTrue( \textcolor{keywordtype}{bool} value )\{ \textcolor{keywordflow}{return} value; \}}
\DoxyCodeLine{479     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} alwaysTrue() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{480     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} alwaysFalse() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{481 }
\DoxyCodeLine{482     \textcolor{keywordtype}{void} throwLogicError( std::string \textcolor{keyword}{const}\& message, SourceLineInfo \textcolor{keyword}{const}\& locationInfo );}
\DoxyCodeLine{483 }
\DoxyCodeLine{484     \textcolor{keywordtype}{void} seedRng( IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{485     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{486 }
\DoxyCodeLine{487     \textcolor{comment}{// Use this in variadic streaming macros to allow}}
\DoxyCodeLine{488     \textcolor{comment}{//    >> +StreamEndStop}}
\DoxyCodeLine{489     \textcolor{comment}{// as well as}}
\DoxyCodeLine{490     \textcolor{comment}{//    >> stuff +StreamEndStop}}
\DoxyCodeLine{491     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StreamEndStop}{StreamEndStop}} \{}
\DoxyCodeLine{492         std::string operator+() \{}
\DoxyCodeLine{493             \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{494         \}}
\DoxyCodeLine{495     \};}
\DoxyCodeLine{496     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{497     T \textcolor{keyword}{const}\& operator + ( T \textcolor{keyword}{const}\& value, \mbox{\hyperlink{structCatch_1_1StreamEndStop}{StreamEndStop}} ) \{}
\DoxyCodeLine{498         \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{499     \}}
\DoxyCodeLine{500 \}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_LINEINFO ::Catch::SourceLineInfo( \_\_FILE\_\_, static\_cast<std::size\_t>( \_\_LINE\_\_ ) )}}
\DoxyCodeLine{503 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_ERROR( msg ) ::Catch::throwLogicError( msg, CATCH\_INTERNAL\_LINEINFO );}}
\DoxyCodeLine{504 }
\DoxyCodeLine{505 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{506 }
\DoxyCodeLine{507     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1NotImplementedException}{NotImplementedException}} : \textcolor{keyword}{public} std::exception}
\DoxyCodeLine{508     \{}
\DoxyCodeLine{509     \textcolor{keyword}{public}:}
\DoxyCodeLine{510         \mbox{\hyperlink{classCatch_1_1NotImplementedException}{NotImplementedException}}( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{511 }
\DoxyCodeLine{512         \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1NotImplementedException}{\string~NotImplementedException}}() CATCH\_NOEXCEPT \{\}}
\DoxyCodeLine{513 }
\DoxyCodeLine{514         \textcolor{keyword}{virtual} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() \textcolor{keyword}{const} CATCH\_NOEXCEPT;}
\DoxyCodeLine{515 }
\DoxyCodeLine{516     \textcolor{keyword}{private}:}
\DoxyCodeLine{517         std::string m\_what;}
\DoxyCodeLine{518         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} m\_lineInfo;}
\DoxyCodeLine{519     \};}
\DoxyCodeLine{520 }
\DoxyCodeLine{521 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{522 }
\DoxyCodeLine{524 \textcolor{preprocessor}{\#define CATCH\_NOT\_IMPLEMENTED throw Catch::NotImplementedException( CATCH\_INTERNAL\_LINEINFO )}}
\DoxyCodeLine{525 }
\DoxyCodeLine{526 \textcolor{comment}{// \#included from: internal/catch\_context.h}}
\DoxyCodeLine{527 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_CONTEXT\_H\_INCLUDED}}
\DoxyCodeLine{528 }
\DoxyCodeLine{529 \textcolor{comment}{// \#included from: catch\_interfaces\_generators.h}}
\DoxyCodeLine{530 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_GENERATORS\_H\_INCLUDED}}
\DoxyCodeLine{531 }
\DoxyCodeLine{532 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{533 }
\DoxyCodeLine{534 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{535 }
\DoxyCodeLine{536     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IGeneratorInfo}{IGeneratorInfo}} \{}
\DoxyCodeLine{537         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IGeneratorInfo}{\string~IGeneratorInfo}}();}
\DoxyCodeLine{538         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} moveNext() = 0;}
\DoxyCodeLine{539         \textcolor{keyword}{virtual} std::size\_t getCurrentIndex() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{540     \};}
\DoxyCodeLine{541 }
\DoxyCodeLine{542     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IGeneratorsForTest}{IGeneratorsForTest}} \{}
\DoxyCodeLine{543         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IGeneratorsForTest}{\string~IGeneratorsForTest}}();}
\DoxyCodeLine{544 }
\DoxyCodeLine{545         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IGeneratorInfo}{IGeneratorInfo}}\& getGeneratorInfo( std::string \textcolor{keyword}{const}\& fileInfo, std::size\_t size ) = 0;}
\DoxyCodeLine{546         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} moveNext() = 0;}
\DoxyCodeLine{547     \};}
\DoxyCodeLine{548 }
\DoxyCodeLine{549     \mbox{\hyperlink{structCatch_1_1IGeneratorsForTest}{IGeneratorsForTest}}* createGeneratorsForTest();}
\DoxyCodeLine{550 }
\DoxyCodeLine{551 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{552 }
\DoxyCodeLine{553 \textcolor{comment}{// \#included from: catch\_ptr.hpp}}
\DoxyCodeLine{554 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_PTR\_HPP\_INCLUDED}}
\DoxyCodeLine{555 }
\DoxyCodeLine{556 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{557 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{558 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{559 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{562 }
\DoxyCodeLine{563     \textcolor{comment}{// An intrusive reference counting smart pointer.}}
\DoxyCodeLine{564     \textcolor{comment}{// T must implement addRef() and release() methods}}
\DoxyCodeLine{565     \textcolor{comment}{// typically implementing the IShared interface}}
\DoxyCodeLine{566     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{567     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}} \{}
\DoxyCodeLine{568     \textcolor{keyword}{public}:}
\DoxyCodeLine{569         \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}}() : m\_p( CATCH\_NULL )\{\}}
\DoxyCodeLine{570         \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}}( T* p ) : m\_p( p )\{}
\DoxyCodeLine{571             \textcolor{keywordflow}{if}( m\_p )}
\DoxyCodeLine{572                 m\_p-\/>addRef();}
\DoxyCodeLine{573         \}}
\DoxyCodeLine{574         \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}}( \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}} \textcolor{keyword}{const}\& other ) : m\_p( other.m\_p )\{}
\DoxyCodeLine{575             \textcolor{keywordflow}{if}( m\_p )}
\DoxyCodeLine{576                 m\_p-\/>addRef();}
\DoxyCodeLine{577         \}}
\DoxyCodeLine{578         \mbox{\hyperlink{classCatch_1_1Ptr}{\string~Ptr}}()\{}
\DoxyCodeLine{579             \textcolor{keywordflow}{if}( m\_p )}
\DoxyCodeLine{580                 m\_p-\/>release();}
\DoxyCodeLine{581         \}}
\DoxyCodeLine{582         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{583             \textcolor{keywordflow}{if}( m\_p )}
\DoxyCodeLine{584                 m\_p-\/>release();}
\DoxyCodeLine{585             m\_p = CATCH\_NULL;}
\DoxyCodeLine{586         \}}
\DoxyCodeLine{587         \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}}\& operator = ( T* p )\{}
\DoxyCodeLine{588             \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}} temp( p );}
\DoxyCodeLine{589             swap( temp );}
\DoxyCodeLine{590             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{591         \}}
\DoxyCodeLine{592         \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}}\& operator = ( \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}} \textcolor{keyword}{const}\& other )\{}
\DoxyCodeLine{593             \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}} temp( other );}
\DoxyCodeLine{594             swap( temp );}
\DoxyCodeLine{595             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{596         \}}
\DoxyCodeLine{597         \textcolor{keywordtype}{void} swap( \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr}}\& other ) \{ std::swap( m\_p, other.m\_p ); \}}
\DoxyCodeLine{598         T* get()\textcolor{keyword}{ const}\{ \textcolor{keywordflow}{return} m\_p; \}}
\DoxyCodeLine{599         T\& operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *m\_p; \}}
\DoxyCodeLine{600         T* operator-\/>()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_p; \}}
\DoxyCodeLine{601         \textcolor{keywordtype}{bool} operator !()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_p == CATCH\_NULL; \}}
\DoxyCodeLine{602         \textcolor{keyword}{operator} SafeBool::type()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} SafeBool::makeSafe( m\_p != CATCH\_NULL ); \}}
\DoxyCodeLine{603 }
\DoxyCodeLine{604     \textcolor{keyword}{private}:}
\DoxyCodeLine{605         T* m\_p;}
\DoxyCodeLine{606     \};}
\DoxyCodeLine{607 }
\DoxyCodeLine{608     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IShared}{IShared}} : \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{609         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IShared}{\string~IShared}}();}
\DoxyCodeLine{610         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} addRef() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{611         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} release() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{612     \};}
\DoxyCodeLine{613 }
\DoxyCodeLine{614     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T = IShared>}
\DoxyCodeLine{615     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SharedImpl}{SharedImpl}} : T \{}
\DoxyCodeLine{616 }
\DoxyCodeLine{617         \mbox{\hyperlink{structCatch_1_1SharedImpl}{SharedImpl}}() : m\_rc( 0 )\{\}}
\DoxyCodeLine{618 }
\DoxyCodeLine{619         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} addRef()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{620             ++m\_rc;}
\DoxyCodeLine{621         \}}
\DoxyCodeLine{622         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} release()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{623             \textcolor{keywordflow}{if}( -\/-\/m\_rc == 0 )}
\DoxyCodeLine{624                 \textcolor{keyword}{delete} \textcolor{keyword}{this};}
\DoxyCodeLine{625         \}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627         \textcolor{keyword}{mutable} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} m\_rc;}
\DoxyCodeLine{628     \};}
\DoxyCodeLine{629 }
\DoxyCodeLine{630 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{631 }
\DoxyCodeLine{632 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{633 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{634 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{635 }
\DoxyCodeLine{636 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{637 }
\DoxyCodeLine{638     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{639     \textcolor{keyword}{class }Stream;}
\DoxyCodeLine{640     \textcolor{keyword}{struct }IResultCapture;}
\DoxyCodeLine{641     \textcolor{keyword}{struct }IRunner;}
\DoxyCodeLine{642     \textcolor{keyword}{struct }IGeneratorsForTest;}
\DoxyCodeLine{643     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{644 }
\DoxyCodeLine{645     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IContext}{IContext}}}
\DoxyCodeLine{646     \{}
\DoxyCodeLine{647         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IContext}{\string~IContext}}();}
\DoxyCodeLine{648 }
\DoxyCodeLine{649         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}* getResultCapture() = 0;}
\DoxyCodeLine{650         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IRunner}{IRunner}}* getRunner() = 0;}
\DoxyCodeLine{651         \textcolor{keyword}{virtual} \textcolor{keywordtype}{size\_t} getGeneratorIndex( std::string \textcolor{keyword}{const}\& fileInfo, \textcolor{keywordtype}{size\_t} totalSize ) = 0;}
\DoxyCodeLine{652         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} advanceGeneratorsForCurrentTest() = 0;}
\DoxyCodeLine{653         \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr<IConfig const>}} getConfig() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{654     \};}
\DoxyCodeLine{655 }
\DoxyCodeLine{656     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IMutableContext}{IMutableContext}} : \mbox{\hyperlink{structCatch_1_1IContext}{IContext}}}
\DoxyCodeLine{657     \{}
\DoxyCodeLine{658         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IMutableContext}{\string~IMutableContext}}();}
\DoxyCodeLine{659         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setResultCapture( \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}* resultCapture ) = 0;}
\DoxyCodeLine{660         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setRunner( \mbox{\hyperlink{structCatch_1_1IRunner}{IRunner}}* runner ) = 0;}
\DoxyCodeLine{661         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setConfig( \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr<IConfig const>}} \textcolor{keyword}{const}\& config ) = 0;}
\DoxyCodeLine{662     \};}
\DoxyCodeLine{663 }
\DoxyCodeLine{664     \mbox{\hyperlink{structCatch_1_1IContext}{IContext}}\& getCurrentContext();}
\DoxyCodeLine{665     \mbox{\hyperlink{structCatch_1_1IMutableContext}{IMutableContext}}\& getCurrentMutableContext();}
\DoxyCodeLine{666     \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{667     Stream createStream( std::string \textcolor{keyword}{const}\& streamName );}
\DoxyCodeLine{668 }
\DoxyCodeLine{669 \}}
\DoxyCodeLine{670 }
\DoxyCodeLine{671 \textcolor{comment}{// \#included from: internal/catch\_test\_registry.hpp}}
\DoxyCodeLine{672 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TEST\_REGISTRY\_HPP\_INCLUDED}}
\DoxyCodeLine{673 }
\DoxyCodeLine{674 \textcolor{comment}{// \#included from: catch\_interfaces\_testcase.h}}
\DoxyCodeLine{675 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_TESTCASE\_H\_INCLUDED}}
\DoxyCodeLine{676 }
\DoxyCodeLine{677 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{678 }
\DoxyCodeLine{679 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{680 }
\DoxyCodeLine{681     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{682 }
\DoxyCodeLine{683     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITestCase}{ITestCase}} : \mbox{\hyperlink{structCatch_1_1IShared}{IShared}} \{}
\DoxyCodeLine{684         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke () \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{685     \textcolor{keyword}{protected}:}
\DoxyCodeLine{686         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITestCase}{\string~ITestCase}}();}
\DoxyCodeLine{687     \};}
\DoxyCodeLine{688 }
\DoxyCodeLine{689     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}};}
\DoxyCodeLine{690     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{691 }
\DoxyCodeLine{692     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{ITestCaseRegistry}} \{}
\DoxyCodeLine{693         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{\string~ITestCaseRegistry}}();}
\DoxyCodeLine{694         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{695         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{696     \};}
\DoxyCodeLine{697 }
\DoxyCodeLine{698     \textcolor{keywordtype}{bool} matchTest( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{699     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{700     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{701 }
\DoxyCodeLine{702 \}}
\DoxyCodeLine{703 }
\DoxyCodeLine{704 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{705 }
\DoxyCodeLine{706 \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{707 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1MethodTestCase}{MethodTestCase}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1SharedImpl}{SharedImpl}}<ITestCase> \{}
\DoxyCodeLine{708 }
\DoxyCodeLine{709 \textcolor{keyword}{public}:}
\DoxyCodeLine{710     \mbox{\hyperlink{classCatch_1_1MethodTestCase}{MethodTestCase}}( \textcolor{keywordtype}{void} (C::*method)() ) : m\_method( method ) \{\}}
\DoxyCodeLine{711 }
\DoxyCodeLine{712     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{713         C obj;}
\DoxyCodeLine{714         (obj.*m\_method)();}
\DoxyCodeLine{715     \}}
\DoxyCodeLine{716 }
\DoxyCodeLine{717 \textcolor{keyword}{private}:}
\DoxyCodeLine{718     \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1MethodTestCase}{\string~MethodTestCase}}() \{\}}
\DoxyCodeLine{719 }
\DoxyCodeLine{720     void (C::*m\_method)();}
\DoxyCodeLine{721 \};}
\DoxyCodeLine{722 }
\DoxyCodeLine{723 \textcolor{keyword}{typedef} void(*TestFunction)();}
\DoxyCodeLine{724 }
\DoxyCodeLine{725 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1NameAndDesc}{NameAndDesc}} \{}
\DoxyCodeLine{726     \mbox{\hyperlink{structCatch_1_1NameAndDesc}{NameAndDesc}}( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \_name = \textcolor{stringliteral}{"{}"{}}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \_description= \textcolor{stringliteral}{"{}"{}} )}
\DoxyCodeLine{727     : name( \_name ), description( \_description )}
\DoxyCodeLine{728     \{\}}
\DoxyCodeLine{729 }
\DoxyCodeLine{730     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name;}
\DoxyCodeLine{731     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* description;}
\DoxyCodeLine{732 \};}
\DoxyCodeLine{733 }
\DoxyCodeLine{734 \textcolor{keywordtype}{void} registerTestCase}
\DoxyCodeLine{735     (   \mbox{\hyperlink{structCatch_1_1ITestCase}{ITestCase}}* testCase,}
\DoxyCodeLine{736         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* className,}
\DoxyCodeLine{737         \mbox{\hyperlink{structCatch_1_1NameAndDesc}{NameAndDesc}} \textcolor{keyword}{const}\& nameAndDesc,}
\DoxyCodeLine{738         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{739 }
\DoxyCodeLine{740 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}} \{}
\DoxyCodeLine{741 }
\DoxyCodeLine{742     \mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}}}
\DoxyCodeLine{743         (   TestFunction function,}
\DoxyCodeLine{744             \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{745             \mbox{\hyperlink{structCatch_1_1NameAndDesc}{NameAndDesc}} \textcolor{keyword}{const}\& nameAndDesc );}
\DoxyCodeLine{746 }
\DoxyCodeLine{747     \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{748     \mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}}}
\DoxyCodeLine{749         (   \textcolor{keywordtype}{void} (C::*method)(),}
\DoxyCodeLine{750             \textcolor{keywordtype}{char} \textcolor{keyword}{const}* className,}
\DoxyCodeLine{751             \mbox{\hyperlink{structCatch_1_1NameAndDesc}{NameAndDesc}} \textcolor{keyword}{const}\& nameAndDesc,}
\DoxyCodeLine{752             \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) \{}
\DoxyCodeLine{753 }
\DoxyCodeLine{754         registerTestCase}
\DoxyCodeLine{755             (   \textcolor{keyword}{new} \mbox{\hyperlink{classCatch_1_1MethodTestCase}{MethodTestCase<C>}}( method ),}
\DoxyCodeLine{756                 className,}
\DoxyCodeLine{757                 nameAndDesc,}
\DoxyCodeLine{758                 lineInfo );}
\DoxyCodeLine{759     \}}
\DoxyCodeLine{760 }
\DoxyCodeLine{761     \mbox{\hyperlink{structCatch_1_1AutoReg}{\string~AutoReg}}();}
\DoxyCodeLine{762 }
\DoxyCodeLine{763 \textcolor{keyword}{private}:}
\DoxyCodeLine{764     \mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}}( \mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}} \textcolor{keyword}{const}\& );}
\DoxyCodeLine{765     \textcolor{keywordtype}{void} operator= ( \mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}} \textcolor{keyword}{const}\& );}
\DoxyCodeLine{766 \};}
\DoxyCodeLine{767 }
\DoxyCodeLine{768 \textcolor{keywordtype}{void} registerTestCaseFunction}
\DoxyCodeLine{769     (   TestFunction function,}
\DoxyCodeLine{770         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{771         \mbox{\hyperlink{structCatch_1_1NameAndDesc}{NameAndDesc}} \textcolor{keyword}{const}\& nameAndDesc );}
\DoxyCodeLine{772 }
\DoxyCodeLine{773 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{774 }
\DoxyCodeLine{775 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{777 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE2( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{778 \textcolor{preprocessor}{        static void TestName(); \(\backslash\)}}
\DoxyCodeLine{779 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{780 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( \&TestName, CATCH\_INTERNAL\_LINEINFO, Catch::NameAndDesc( \_\_VA\_ARGS\_\_ ) ); \} }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{781 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{782 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{783 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE( ... ) \(\backslash\)}}
\DoxyCodeLine{784 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TESTCASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{785 }
\DoxyCodeLine{787 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( QualifiedMethod, ... ) \(\backslash\)}}
\DoxyCodeLine{788 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{789 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( \&QualifiedMethod, "{}\&"{}} \#QualifiedMethod, Catch::NameAndDesc( \_\_VA\_ARGS\_\_ ), CATCH\_INTERNAL\_LINEINFO ); \} \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{790 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS}}
\DoxyCodeLine{791 }
\DoxyCodeLine{793 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( TestName, ClassName, ... )\(\backslash\)}}
\DoxyCodeLine{794 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{795 \textcolor{preprocessor}{        namespace\{ \(\backslash\)}}
\DoxyCodeLine{796 \textcolor{preprocessor}{            struct TestName : ClassName\{ \(\backslash\)}}
\DoxyCodeLine{797 \textcolor{preprocessor}{                void test(); \(\backslash\)}}
\DoxyCodeLine{798 \textcolor{preprocessor}{            \}; \(\backslash\)}}
\DoxyCodeLine{799 \textcolor{preprocessor}{            Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar ) ( \&TestName::test, \#ClassName, Catch::NameAndDesc( \_\_VA\_ARGS\_\_ ), CATCH\_INTERNAL\_LINEINFO ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{800 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{801 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{802 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{803 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD( ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{804 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), ClassName, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{805 }
\DoxyCodeLine{807 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, ... ) \(\backslash\)}}
\DoxyCodeLine{808 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{809 \textcolor{preprocessor}{        Catch::AutoReg( Function, CATCH\_INTERNAL\_LINEINFO, Catch::NameAndDesc( \_\_VA\_ARGS\_\_ ) ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{810 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS}}
\DoxyCodeLine{811 }
\DoxyCodeLine{812 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{814 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE2( TestName, Name, Desc ) \(\backslash\)}}
\DoxyCodeLine{815 \textcolor{preprocessor}{        static void TestName(); \(\backslash\)}}
\DoxyCodeLine{816 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{817 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( \&TestName, CATCH\_INTERNAL\_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); \} }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{818 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{819 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{820 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE( Name, Desc ) \(\backslash\)}}
\DoxyCodeLine{821 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TESTCASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), Name, Desc )}}
\DoxyCodeLine{822 }
\DoxyCodeLine{824 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( QualifiedMethod, Name, Desc ) \(\backslash\)}}
\DoxyCodeLine{825 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{826 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( \&QualifiedMethod, "{}\&"{}} \#QualifiedMethod, Catch::NameAndDesc( Name, Desc ), CATCH\_INTERNAL\_LINEINFO ); \} \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{827 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS}}
\DoxyCodeLine{828 }
\DoxyCodeLine{830 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( TestCaseName, ClassName, TestName, Desc )\(\backslash\)}}
\DoxyCodeLine{831 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{832 \textcolor{preprocessor}{        namespace\{ \(\backslash\)}}
\DoxyCodeLine{833 \textcolor{preprocessor}{            struct TestCaseName : ClassName\{ \(\backslash\)}}
\DoxyCodeLine{834 \textcolor{preprocessor}{                void test(); \(\backslash\)}}
\DoxyCodeLine{835 \textcolor{preprocessor}{            \}; \(\backslash\)}}
\DoxyCodeLine{836 \textcolor{preprocessor}{            Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar ) ( \&TestCaseName::test, \#ClassName, Catch::NameAndDesc( TestName, Desc ), CATCH\_INTERNAL\_LINEINFO ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{837 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{838 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{839 \textcolor{preprocessor}{        void TestCaseName::test()}}
\DoxyCodeLine{840 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD( ClassName, TestName, Desc )\(\backslash\)}}
\DoxyCodeLine{841 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), ClassName, TestName, Desc )}}
\DoxyCodeLine{842 }
\DoxyCodeLine{844 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, Name, Desc ) \(\backslash\)}}
\DoxyCodeLine{845 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{846 \textcolor{preprocessor}{        Catch::AutoReg( Function, CATCH\_INTERNAL\_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{847 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS}}
\DoxyCodeLine{848 }
\DoxyCodeLine{849 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{850 }
\DoxyCodeLine{851 \textcolor{comment}{// \#included from: internal/catch\_capture.hpp}}
\DoxyCodeLine{852 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_CAPTURE\_HPP\_INCLUDED}}
\DoxyCodeLine{853 }
\DoxyCodeLine{854 \textcolor{comment}{// \#included from: catch\_result\_builder.h}}
\DoxyCodeLine{855 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_RESULT\_BUILDER\_H\_INCLUDED}}
\DoxyCodeLine{856 }
\DoxyCodeLine{857 \textcolor{comment}{// \#included from: catch\_result\_type.h}}
\DoxyCodeLine{858 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_RESULT\_TYPE\_H\_INCLUDED}}
\DoxyCodeLine{859 }
\DoxyCodeLine{860 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{861 }
\DoxyCodeLine{862     \textcolor{comment}{// ResultWas::OfType enum}}
\DoxyCodeLine{863     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ResultWas}{ResultWas}} \{ \textcolor{keyword}{enum} OfType \{}
\DoxyCodeLine{864         Unknown = -\/1,}
\DoxyCodeLine{865         Ok = 0,}
\DoxyCodeLine{866         Info = 1,}
\DoxyCodeLine{867         Warning = 2,}
\DoxyCodeLine{868 }
\DoxyCodeLine{869         FailureBit = 0x10,}
\DoxyCodeLine{870 }
\DoxyCodeLine{871         ExpressionFailed = FailureBit | 1,}
\DoxyCodeLine{872         ExplicitFailure = FailureBit | 2,}
\DoxyCodeLine{873 }
\DoxyCodeLine{874         Exception = 0x100 | FailureBit,}
\DoxyCodeLine{875 }
\DoxyCodeLine{876         ThrewException = Exception | 1,}
\DoxyCodeLine{877         DidntThrowException = Exception | 2,}
\DoxyCodeLine{878 }
\DoxyCodeLine{879         FatalErrorCondition = 0x200 | FailureBit}
\DoxyCodeLine{880 }
\DoxyCodeLine{881     \}; \};}
\DoxyCodeLine{882 }
\DoxyCodeLine{883     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType ) \{}
\DoxyCodeLine{884         \textcolor{keywordflow}{return} ( resultType \& ResultWas::FailureBit ) == 0;}
\DoxyCodeLine{885     \}}
\DoxyCodeLine{886     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags ) \{}
\DoxyCodeLine{887         \textcolor{keywordflow}{return} flags == ResultWas::Info;}
\DoxyCodeLine{888     \}}
\DoxyCodeLine{889 }
\DoxyCodeLine{890     \textcolor{comment}{// ResultDisposition::Flags enum}}
\DoxyCodeLine{891     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ResultDisposition}{ResultDisposition}} \{ \textcolor{keyword}{enum} Flags \{}
\DoxyCodeLine{892         Normal = 0x01,}
\DoxyCodeLine{893 }
\DoxyCodeLine{894         ContinueOnFailure = 0x02,   \textcolor{comment}{// Failures fail test, but execution continues}}
\DoxyCodeLine{895         FalseTest = 0x04,           \textcolor{comment}{// Prefix expression with !}}
\DoxyCodeLine{896         SuppressFail = 0x08         \textcolor{comment}{// Failures are reported but do not fail the test}}
\DoxyCodeLine{897     \}; \};}
\DoxyCodeLine{898 }
\DoxyCodeLine{899     \textcolor{keyword}{inline} ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) \{}
\DoxyCodeLine{900         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}ResultDisposition::Flags\textcolor{keyword}{>}( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( lhs ) | \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{901     \}}
\DoxyCodeLine{902 }
\DoxyCodeLine{903     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags )    \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::ContinueOnFailure ) != 0; \}}
\DoxyCodeLine{904     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isFalseTest( \textcolor{keywordtype}{int} flags )                \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::FalseTest ) != 0; \}}
\DoxyCodeLine{905     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags )      \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::SuppressFail ) != 0; \}}
\DoxyCodeLine{906 }
\DoxyCodeLine{907 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{908 }
\DoxyCodeLine{909 \textcolor{comment}{// \#included from: catch\_assertionresult.h}}
\DoxyCodeLine{910 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_ASSERTIONRESULT\_H\_INCLUDED}}
\DoxyCodeLine{911 }
\DoxyCodeLine{912 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{913 }
\DoxyCodeLine{914 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{915 }
\DoxyCodeLine{916     \textcolor{keyword}{struct }STATIC\_ASSERT\_Expression\_Too\_Complex\_Please\_Rewrite\_As\_Binary\_Comparison;}
\DoxyCodeLine{917 }
\DoxyCodeLine{918     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}}}
\DoxyCodeLine{919     \{}
\DoxyCodeLine{920         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{\string~DecomposedExpression}}() \{\}}
\DoxyCodeLine{921         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isBinaryExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{922             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{923         \}}
\DoxyCodeLine{924         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} reconstructExpression( std::string\& dest ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{925 }
\DoxyCodeLine{926         \textcolor{comment}{// Only simple binary comparisons can be decomposed.}}
\DoxyCodeLine{927         \textcolor{comment}{// If more complex check is required then wrap sub-\/expressions in parentheses.}}
\DoxyCodeLine{928         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> STATIC\_ASSERT\_Expression\_Too\_Complex\_Please\_Rewrite\_As\_Binary\_Comparison\& operator + ( T \textcolor{keyword}{const}\& );}
\DoxyCodeLine{929         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> STATIC\_ASSERT\_Expression\_Too\_Complex\_Please\_Rewrite\_As\_Binary\_Comparison\& operator -\/ ( T \textcolor{keyword}{const}\& );}
\DoxyCodeLine{930         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> STATIC\_ASSERT\_Expression\_Too\_Complex\_Please\_Rewrite\_As\_Binary\_Comparison\& operator * ( T \textcolor{keyword}{const}\& );}
\DoxyCodeLine{931         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> STATIC\_ASSERT\_Expression\_Too\_Complex\_Please\_Rewrite\_As\_Binary\_Comparison\& operator / ( T \textcolor{keyword}{const}\& );}
\DoxyCodeLine{932         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> STATIC\_ASSERT\_Expression\_Too\_Complex\_Please\_Rewrite\_As\_Binary\_Comparison\& operator \% ( T \textcolor{keyword}{const}\& );}
\DoxyCodeLine{933         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> STATIC\_ASSERT\_Expression\_Too\_Complex\_Please\_Rewrite\_As\_Binary\_Comparison\& operator \&\& ( T \textcolor{keyword}{const}\& );}
\DoxyCodeLine{934         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> STATIC\_ASSERT\_Expression\_Too\_Complex\_Please\_Rewrite\_As\_Binary\_Comparison\& operator || ( T \textcolor{keyword}{const}\& );}
\DoxyCodeLine{935 }
\DoxyCodeLine{936     \textcolor{keyword}{private}:}
\DoxyCodeLine{937         \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}}\& operator = (\mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}} \textcolor{keyword}{const}\&);}
\DoxyCodeLine{938     \};}
\DoxyCodeLine{939 }
\DoxyCodeLine{940     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}}}
\DoxyCodeLine{941     \{}
\DoxyCodeLine{942         \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}}();}
\DoxyCodeLine{943         \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}}(  \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \_macroName,}
\DoxyCodeLine{944                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{945                         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \_capturedExpression,}
\DoxyCodeLine{946                         ResultDisposition::Flags \_resultDisposition,}
\DoxyCodeLine{947                         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \_secondArg = \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{948 }
\DoxyCodeLine{949         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * macroName;}
\DoxyCodeLine{950         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{951         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * capturedExpression;}
\DoxyCodeLine{952         ResultDisposition::Flags resultDisposition;}
\DoxyCodeLine{953         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * secondArg;}
\DoxyCodeLine{954     \};}
\DoxyCodeLine{955 }
\DoxyCodeLine{956     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AssertionResultData}{AssertionResultData}}}
\DoxyCodeLine{957     \{}
\DoxyCodeLine{958         \mbox{\hyperlink{structCatch_1_1AssertionResultData}{AssertionResultData}}() : decomposedExpression( CATCH\_NULL )}
\DoxyCodeLine{959                               , resultType( ResultWas::Unknown )}
\DoxyCodeLine{960                               , negated( \textcolor{keyword}{false} )}
\DoxyCodeLine{961                               , parenthesized( \textcolor{keyword}{false} ) \{\}}
\DoxyCodeLine{962 }
\DoxyCodeLine{963         \textcolor{keywordtype}{void} negate( \textcolor{keywordtype}{bool} parenthesize ) \{}
\DoxyCodeLine{964             negated = !negated;}
\DoxyCodeLine{965             parenthesized = parenthesize;}
\DoxyCodeLine{966             \textcolor{keywordflow}{if}( resultType == ResultWas::Ok )}
\DoxyCodeLine{967                 resultType = ResultWas::ExpressionFailed;}
\DoxyCodeLine{968             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( resultType == ResultWas::ExpressionFailed )}
\DoxyCodeLine{969                 resultType = ResultWas::Ok;}
\DoxyCodeLine{970         \}}
\DoxyCodeLine{971 }
\DoxyCodeLine{972         std::string \textcolor{keyword}{const}\& reconstructExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{973             \textcolor{keywordflow}{if}( decomposedExpression != CATCH\_NULL ) \{}
\DoxyCodeLine{974                 decomposedExpression-\/>reconstructExpression( reconstructedExpression );}
\DoxyCodeLine{975                 \textcolor{keywordflow}{if}( parenthesized ) \{}
\DoxyCodeLine{976                     reconstructedExpression.insert( 0, 1, \textcolor{charliteral}{'('} );}
\DoxyCodeLine{977                     reconstructedExpression.append( 1, \textcolor{charliteral}{')'} );}
\DoxyCodeLine{978                 \}}
\DoxyCodeLine{979                 \textcolor{keywordflow}{if}( negated ) \{}
\DoxyCodeLine{980                     reconstructedExpression.insert( 0, 1, \textcolor{charliteral}{'!'} );}
\DoxyCodeLine{981                 \}}
\DoxyCodeLine{982                 decomposedExpression = CATCH\_NULL;}
\DoxyCodeLine{983             \}}
\DoxyCodeLine{984             \textcolor{keywordflow}{return} reconstructedExpression;}
\DoxyCodeLine{985         \}}
\DoxyCodeLine{986 }
\DoxyCodeLine{987         \textcolor{keyword}{mutable} \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}} \textcolor{keyword}{const}* decomposedExpression;}
\DoxyCodeLine{988         \textcolor{keyword}{mutable} std::string reconstructedExpression;}
\DoxyCodeLine{989         std::string message;}
\DoxyCodeLine{990         ResultWas::OfType resultType;}
\DoxyCodeLine{991         \textcolor{keywordtype}{bool} negated;}
\DoxyCodeLine{992         \textcolor{keywordtype}{bool} parenthesized;}
\DoxyCodeLine{993     \};}
\DoxyCodeLine{994 }
\DoxyCodeLine{995     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} \{}
\DoxyCodeLine{996     \textcolor{keyword}{public}:}
\DoxyCodeLine{997         \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}}();}
\DoxyCodeLine{998         \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}}( \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info, \mbox{\hyperlink{structCatch_1_1AssertionResultData}{AssertionResultData}} \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{999         \mbox{\hyperlink{classCatch_1_1AssertionResult}{\string~AssertionResult}}();}
\DoxyCodeLine{1000 \textcolor{preprocessor}{\#  ifdef CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{1001          \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}}( \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1002          \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}}( \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1003          \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}}\& operator = ( \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1004          \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}}\& operator = ( \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1005 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{1006 }
\DoxyCodeLine{1007         \textcolor{keywordtype}{bool} isOk() \textcolor{keyword}{const};}
\DoxyCodeLine{1008         \textcolor{keywordtype}{bool} succeeded() \textcolor{keyword}{const};}
\DoxyCodeLine{1009         ResultWas::OfType getResultType() \textcolor{keyword}{const};}
\DoxyCodeLine{1010         \textcolor{keywordtype}{bool} hasExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{1011         \textcolor{keywordtype}{bool} hasMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{1012         std::string getExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{1013         std::string getExpressionInMacro() \textcolor{keyword}{const};}
\DoxyCodeLine{1014         \textcolor{keywordtype}{bool} hasExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{1015         std::string getExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{1016         std::string getMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{1017         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} getSourceInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{1018         std::string getTestMacroName() \textcolor{keyword}{const};}
\DoxyCodeLine{1019         \textcolor{keywordtype}{void} discardDecomposedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{1020         \textcolor{keywordtype}{void} expandDecomposedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{1021 }
\DoxyCodeLine{1022     \textcolor{keyword}{protected}:}
\DoxyCodeLine{1023         \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} m\_info;}
\DoxyCodeLine{1024         \mbox{\hyperlink{structCatch_1_1AssertionResultData}{AssertionResultData}} m\_resultData;}
\DoxyCodeLine{1025     \};}
\DoxyCodeLine{1026 }
\DoxyCodeLine{1027 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1028 }
\DoxyCodeLine{1029 \textcolor{comment}{// \#included from: catch\_matchers.hpp}}
\DoxyCodeLine{1030 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_MATCHERS\_HPP\_INCLUDED}}
\DoxyCodeLine{1031 }
\DoxyCodeLine{1032 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1033 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{1034     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{1035 }
\DoxyCodeLine{1036         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchAllOf;}
\DoxyCodeLine{1037         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchAnyOf;}
\DoxyCodeLine{1038         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchNotOf;}
\DoxyCodeLine{1039 }
\DoxyCodeLine{1040         \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} \{}
\DoxyCodeLine{1041         \textcolor{keyword}{public}:}
\DoxyCodeLine{1042             std::string toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1043                 \textcolor{keywordflow}{if}( m\_cachedToString.empty() )}
\DoxyCodeLine{1044                     m\_cachedToString = describe();}
\DoxyCodeLine{1045                 \textcolor{keywordflow}{return} m\_cachedToString;}
\DoxyCodeLine{1046             \}}
\DoxyCodeLine{1047 }
\DoxyCodeLine{1048         \textcolor{keyword}{protected}:}
\DoxyCodeLine{1049             \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{\string~MatcherUntypedBase}}();}
\DoxyCodeLine{1050             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{1051             \textcolor{keyword}{mutable} std::string m\_cachedToString;}
\DoxyCodeLine{1052         \textcolor{keyword}{private}:}
\DoxyCodeLine{1053             \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}\& operator = ( \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} \textcolor{keyword}{const}\& );}
\DoxyCodeLine{1054         \};}
\DoxyCodeLine{1055 }
\DoxyCodeLine{1056         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT>}
\DoxyCodeLine{1057         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{MatcherMethod}} \{}
\DoxyCodeLine{1058             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( ObjectT \textcolor{keyword}{const}\& arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{1059         \};}
\DoxyCodeLine{1060         \textcolor{keyword}{template}<\textcolor{keyword}{typename} PtrT>}
\DoxyCodeLine{1061         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{MatcherMethod}}<PtrT*> \{}
\DoxyCodeLine{1062             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( PtrT* arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{1063         \};}
\DoxyCodeLine{1064 }
\DoxyCodeLine{1065         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT, \textcolor{keyword}{typename} ComparatorT = ObjectT>}
\DoxyCodeLine{1066         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} : \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}, \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{MatcherMethod}}<ObjectT> \{}
\DoxyCodeLine{1067 }
\DoxyCodeLine{1068             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<ComparatorT>}} operator \&\& ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{1069             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{MatchAnyOf<ComparatorT>}} operator || ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{1070             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{MatchNotOf<ComparatorT>}} operator ! () \textcolor{keyword}{const};}
\DoxyCodeLine{1071         \};}
\DoxyCodeLine{1072 }
\DoxyCodeLine{1073         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{1074         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{1075             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1076                 \textcolor{keywordflow}{for}( std::size\_t i = 0; i < m\_matchers.size(); ++i ) \{}
\DoxyCodeLine{1077                     \textcolor{keywordflow}{if} (!m\_matchers[i]-\/>match(arg))}
\DoxyCodeLine{1078                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1079                 \}}
\DoxyCodeLine{1080                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1081             \}}
\DoxyCodeLine{1082             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1083                 std::string description;}
\DoxyCodeLine{1084                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{1085                 description += \textcolor{stringliteral}{"{}( "{}};}
\DoxyCodeLine{1086                 \textcolor{keywordflow}{for}( std::size\_t i = 0; i < m\_matchers.size(); ++i ) \{}
\DoxyCodeLine{1087                     \textcolor{keywordflow}{if}( i != 0 )}
\DoxyCodeLine{1088                         description += \textcolor{stringliteral}{"{} and "{}};}
\DoxyCodeLine{1089                     description += m\_matchers[i]-\/>toString();}
\DoxyCodeLine{1090                 \}}
\DoxyCodeLine{1091                 description += \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{1092                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{1093             \}}
\DoxyCodeLine{1094 }
\DoxyCodeLine{1095             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<ArgT>}}\& operator \&\& ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{1096                 m\_matchers.push\_back( \&other );}
\DoxyCodeLine{1097                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1098             \}}
\DoxyCodeLine{1099 }
\DoxyCodeLine{1100             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{1101         \};}
\DoxyCodeLine{1102         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{1103         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{MatchAnyOf}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{1104 }
\DoxyCodeLine{1105             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1106                 \textcolor{keywordflow}{for}( std::size\_t i = 0; i < m\_matchers.size(); ++i ) \{}
\DoxyCodeLine{1107                     \textcolor{keywordflow}{if} (m\_matchers[i]-\/>match(arg))}
\DoxyCodeLine{1108                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1109                 \}}
\DoxyCodeLine{1110                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1111             \}}
\DoxyCodeLine{1112             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1113                 std::string description;}
\DoxyCodeLine{1114                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{1115                 description += \textcolor{stringliteral}{"{}( "{}};}
\DoxyCodeLine{1116                 \textcolor{keywordflow}{for}( std::size\_t i = 0; i < m\_matchers.size(); ++i ) \{}
\DoxyCodeLine{1117                     \textcolor{keywordflow}{if}( i != 0 )}
\DoxyCodeLine{1118                         description += \textcolor{stringliteral}{"{} or "{}};}
\DoxyCodeLine{1119                     description += m\_matchers[i]-\/>toString();}
\DoxyCodeLine{1120                 \}}
\DoxyCodeLine{1121                 description += \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{1122                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{1123             \}}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{MatchAnyOf<ArgT>}}\& operator || ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{1126                 m\_matchers.push\_back( \&other );}
\DoxyCodeLine{1127                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1128             \}}
\DoxyCodeLine{1129 }
\DoxyCodeLine{1130             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{1131         \};}
\DoxyCodeLine{1132 }
\DoxyCodeLine{1133         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{1134         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{MatchNotOf}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{1135 }
\DoxyCodeLine{1136             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{MatchNotOf}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& underlyingMatcher ) : m\_underlyingMatcher( underlyingMatcher ) \{\}}
\DoxyCodeLine{1137 }
\DoxyCodeLine{1138             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1139                 \textcolor{keywordflow}{return} !m\_underlyingMatcher.match( arg );}
\DoxyCodeLine{1140             \}}
\DoxyCodeLine{1141 }
\DoxyCodeLine{1142             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1143                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}not "{}} + m\_underlyingMatcher.toString();}
\DoxyCodeLine{1144             \}}
\DoxyCodeLine{1145             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& m\_underlyingMatcher;}
\DoxyCodeLine{1146         \};}
\DoxyCodeLine{1147 }
\DoxyCodeLine{1148         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT, \textcolor{keyword}{typename} ComparatorT>}
\DoxyCodeLine{1149         \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<ComparatorT>}} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ObjectT, ComparatorT>::operator \&\& }}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1150             \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<ComparatorT>}}() \&\& *\textcolor{keyword}{this} \&\& other;}
\DoxyCodeLine{1151         \}}
\DoxyCodeLine{1152         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT, \textcolor{keyword}{typename} ComparatorT>}
\DoxyCodeLine{1153         MatchAnyOf<ComparatorT> \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ObjectT, ComparatorT>::operator || }}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1154             \textcolor{keywordflow}{return} MatchAnyOf<ComparatorT>() || *\textcolor{keyword}{this} || other;}
\DoxyCodeLine{1155         \}}
\DoxyCodeLine{1156         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT, \textcolor{keyword}{typename} ComparatorT>}
\DoxyCodeLine{1157         MatchNotOf<ComparatorT> \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ObjectT, ComparatorT>::operator ! }}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1158             \textcolor{keywordflow}{return} MatchNotOf<ComparatorT>( *\textcolor{keyword}{this} );}
\DoxyCodeLine{1159         \}}
\DoxyCodeLine{1160 }
\DoxyCodeLine{1161     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{1162 }
\DoxyCodeLine{1163     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{1164     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{1165     \textcolor{comment}{// -\/ deprecated: prefer ||, \&\& and !}}
\DoxyCodeLine{1166     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1167     Impl::MatchNotOf<T> Not( Impl::MatcherBase<T> \textcolor{keyword}{const}\& underlyingMatcher ) \{}
\DoxyCodeLine{1168         \textcolor{keywordflow}{return} Impl::MatchNotOf<T>( underlyingMatcher );}
\DoxyCodeLine{1169     \}}
\DoxyCodeLine{1170     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1171     Impl::MatchAllOf<T> AllOf( Impl::MatcherBase<T> \textcolor{keyword}{const}\& m1, Impl::MatcherBase<T> \textcolor{keyword}{const}\& m2 ) \{}
\DoxyCodeLine{1172         \textcolor{keywordflow}{return} Impl::MatchAllOf<T>() \&\& m1 \&\& m2;}
\DoxyCodeLine{1173     \}}
\DoxyCodeLine{1174     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1175     Impl::MatchAllOf<T> AllOf( Impl::MatcherBase<T> \textcolor{keyword}{const}\& m1, Impl::MatcherBase<T> \textcolor{keyword}{const}\& m2, Impl::MatcherBase<T> \textcolor{keyword}{const}\& m3 ) \{}
\DoxyCodeLine{1176         \textcolor{keywordflow}{return} Impl::MatchAllOf<T>() \&\& m1 \&\& m2 \&\& m3;}
\DoxyCodeLine{1177     \}}
\DoxyCodeLine{1178     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1179     Impl::MatchAnyOf<T> AnyOf( Impl::MatcherBase<T> \textcolor{keyword}{const}\& m1, Impl::MatcherBase<T> \textcolor{keyword}{const}\& m2 ) \{}
\DoxyCodeLine{1180         \textcolor{keywordflow}{return} Impl::MatchAnyOf<T>() || m1 || m2;}
\DoxyCodeLine{1181     \}}
\DoxyCodeLine{1182     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1183     Impl::MatchAnyOf<T> AnyOf( Impl::MatcherBase<T> \textcolor{keyword}{const}\& m1, Impl::MatcherBase<T> \textcolor{keyword}{const}\& m2, Impl::MatcherBase<T> \textcolor{keyword}{const}\& m3 ) \{}
\DoxyCodeLine{1184         \textcolor{keywordflow}{return} Impl::MatchAnyOf<T>() || m1 || m2 || m3;}
\DoxyCodeLine{1185     \}}
\DoxyCodeLine{1186 }
\DoxyCodeLine{1187 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{1188 }
\DoxyCodeLine{1189 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{1190 \textcolor{keyword}{using }Matchers::Impl::MatcherBase;}
\DoxyCodeLine{1191 }
\DoxyCodeLine{1192 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{1193 }
\DoxyCodeLine{1194 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1195 }
\DoxyCodeLine{1196     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1TestFailureException}{TestFailureException}}\{\};}
\DoxyCodeLine{1197 }
\DoxyCodeLine{1198     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ExpressionLhs}{ExpressionLhs}};}
\DoxyCodeLine{1199 }
\DoxyCodeLine{1200     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}} \{}
\DoxyCodeLine{1201         \mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}}() \{\}}
\DoxyCodeLine{1202         \mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}}( \mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{1203             oss << other.oss.str();}
\DoxyCodeLine{1204         \}}
\DoxyCodeLine{1205         \mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}}\& operator=( \mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{1206             oss.str(std::string());}
\DoxyCodeLine{1207             oss << other.oss.str();}
\DoxyCodeLine{1208             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1209         \}}
\DoxyCodeLine{1210         std::ostringstream oss;}
\DoxyCodeLine{1211     \};}
\DoxyCodeLine{1212 }
\DoxyCodeLine{1213     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}} \{}
\DoxyCodeLine{1214     \textcolor{keyword}{public}:}
\DoxyCodeLine{1215         \mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}}(  \textcolor{keywordtype}{char} \textcolor{keyword}{const}* macroName,}
\DoxyCodeLine{1216                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{1217                         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* capturedExpression,}
\DoxyCodeLine{1218                         ResultDisposition::Flags resultDisposition,}
\DoxyCodeLine{1219                         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* secondArg = \textcolor{stringliteral}{"{}"{}} );}
\DoxyCodeLine{1220         \mbox{\hyperlink{classCatch_1_1ResultBuilder}{\string~ResultBuilder}}();}
\DoxyCodeLine{1221 }
\DoxyCodeLine{1222         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1223         \mbox{\hyperlink{classCatch_1_1ExpressionLhs}{ExpressionLhs<T const\&>}} operator <= ( T \textcolor{keyword}{const}\& operand );}
\DoxyCodeLine{1224         \mbox{\hyperlink{classCatch_1_1ExpressionLhs}{ExpressionLhs<bool>}} operator <= ( \textcolor{keywordtype}{bool} value );}
\DoxyCodeLine{1225 }
\DoxyCodeLine{1226         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1227         \mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{1228             stream().oss << value;}
\DoxyCodeLine{1229             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1230         \}}
\DoxyCodeLine{1231 }
\DoxyCodeLine{1232         \mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}}\& setResultType( ResultWas::OfType result );}
\DoxyCodeLine{1233         \mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}}\& setResultType( \textcolor{keywordtype}{bool} result );}
\DoxyCodeLine{1234 }
\DoxyCodeLine{1235         \textcolor{keywordtype}{void} endExpression( \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{1236 }
\DoxyCodeLine{1237         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} reconstructExpression( std::string\& dest ) \textcolor{keyword}{const} CATCH\_OVERRIDE;}
\DoxyCodeLine{1238 }
\DoxyCodeLine{1239         \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} build() \textcolor{keyword}{const};}
\DoxyCodeLine{1240         \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} build( \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}} \textcolor{keyword}{const}\& expr ) \textcolor{keyword}{const};}
\DoxyCodeLine{1241 }
\DoxyCodeLine{1242         \textcolor{keywordtype}{void} useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );}
\DoxyCodeLine{1243         \textcolor{keywordtype}{void} captureResult( ResultWas::OfType resultType );}
\DoxyCodeLine{1244         \textcolor{keywordtype}{void} captureExpression();}
\DoxyCodeLine{1245         \textcolor{keywordtype}{void} captureExpectedException( std::string \textcolor{keyword}{const}\& expectedMessage );}
\DoxyCodeLine{1246         \textcolor{keywordtype}{void} captureExpectedException( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{Matchers::Impl::MatcherBase<std::string>}} \textcolor{keyword}{const}\& matcher );}
\DoxyCodeLine{1247         \textcolor{keywordtype}{void} handleResult( \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} \textcolor{keyword}{const}\& result );}
\DoxyCodeLine{1248         \textcolor{keywordtype}{void} react();}
\DoxyCodeLine{1249         \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const};}
\DoxyCodeLine{1250         \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const};}
\DoxyCodeLine{1251 }
\DoxyCodeLine{1252         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{1253         \textcolor{keywordtype}{void} captureMatch( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* matcherString );}
\DoxyCodeLine{1254 }
\DoxyCodeLine{1255         \textcolor{keywordtype}{void} setExceptionGuard();}
\DoxyCodeLine{1256         \textcolor{keywordtype}{void} unsetExceptionGuard();}
\DoxyCodeLine{1257 }
\DoxyCodeLine{1258     \textcolor{keyword}{private}:}
\DoxyCodeLine{1259         \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} m\_assertionInfo;}
\DoxyCodeLine{1260         \mbox{\hyperlink{structCatch_1_1AssertionResultData}{AssertionResultData}} m\_data;}
\DoxyCodeLine{1261 }
\DoxyCodeLine{1262         \mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}} \&stream()}
\DoxyCodeLine{1263         \{}
\DoxyCodeLine{1264             \textcolor{keywordflow}{if}(!m\_usedStream)}
\DoxyCodeLine{1265             \{}
\DoxyCodeLine{1266                 m\_usedStream = \textcolor{keyword}{true};}
\DoxyCodeLine{1267                 m\_stream().oss.str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1268             \}}
\DoxyCodeLine{1269             \textcolor{keywordflow}{return} m\_stream();}
\DoxyCodeLine{1270         \}}
\DoxyCodeLine{1271 }
\DoxyCodeLine{1272         \textcolor{keyword}{static} \mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}} \&m\_stream()}
\DoxyCodeLine{1273         \{}
\DoxyCodeLine{1274             \textcolor{keyword}{static} \mbox{\hyperlink{structCatch_1_1CopyableStream}{CopyableStream}} s;}
\DoxyCodeLine{1275             \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{1276         \}}
\DoxyCodeLine{1277 }
\DoxyCodeLine{1278         \textcolor{keywordtype}{bool} m\_shouldDebugBreak;}
\DoxyCodeLine{1279         \textcolor{keywordtype}{bool} m\_shouldThrow;}
\DoxyCodeLine{1280         \textcolor{keywordtype}{bool} m\_guardException;}
\DoxyCodeLine{1281         \textcolor{keywordtype}{bool} m\_usedStream;}
\DoxyCodeLine{1282     \};}
\DoxyCodeLine{1283 }
\DoxyCodeLine{1284 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{1285 }
\DoxyCodeLine{1286 \textcolor{comment}{// Include after due to circular dependency:}}
\DoxyCodeLine{1287 \textcolor{comment}{// \#included from: catch\_expression\_lhs.hpp}}
\DoxyCodeLine{1288 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_EXPRESSION\_LHS\_HPP\_INCLUDED}}
\DoxyCodeLine{1289 }
\DoxyCodeLine{1290 \textcolor{comment}{// \#included from: catch\_evaluate.hpp}}
\DoxyCodeLine{1291 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_EVALUATE\_HPP\_INCLUDED}}
\DoxyCodeLine{1292 }
\DoxyCodeLine{1293 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{1294 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{1295 \textcolor{preprocessor}{\#pragma warning(disable:4389) }\textcolor{comment}{// '==' : signed/unsigned mismatch}}
\DoxyCodeLine{1296 \textcolor{preprocessor}{\#pragma warning(disable:4018) }\textcolor{comment}{// more "{}signed/unsigned mismatch"{}}}
\DoxyCodeLine{1297 \textcolor{preprocessor}{\#pragma warning(disable:4312) }\textcolor{comment}{// Converting int to T* using reinterpret\_cast (issue on x64 platform)}}
\DoxyCodeLine{1298 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1299 }
\DoxyCodeLine{1300 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{1301 }
\DoxyCodeLine{1302 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1303 \textcolor{keyword}{namespace }Internal \{}
\DoxyCodeLine{1304 }
\DoxyCodeLine{1305     \textcolor{keyword}{enum} Operator \{}
\DoxyCodeLine{1306         IsEqualTo,}
\DoxyCodeLine{1307         IsNotEqualTo,}
\DoxyCodeLine{1308         IsLessThan,}
\DoxyCodeLine{1309         IsGreaterThan,}
\DoxyCodeLine{1310         IsLessThanOrEqualTo,}
\DoxyCodeLine{1311         IsGreaterThanOrEqualTo}
\DoxyCodeLine{1312     \};}
\DoxyCodeLine{1313 }
\DoxyCodeLine{1314     \textcolor{keyword}{template}<Operator Op> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1OperatorTraits}{OperatorTraits}}             \{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* getName()\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}*error*"{}}; \} \};}
\DoxyCodeLine{1315     \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1OperatorTraits}{OperatorTraits}}<IsEqualTo>             \{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* getName()\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}=="{}}; \} \};}
\DoxyCodeLine{1316     \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1OperatorTraits}{OperatorTraits}}<IsNotEqualTo>          \{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* getName()\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}!="{}}; \} \};}
\DoxyCodeLine{1317     \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1OperatorTraits}{OperatorTraits}}<IsLessThan>            \{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* getName()\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}<"{}}; \} \};}
\DoxyCodeLine{1318     \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1OperatorTraits}{OperatorTraits}}<IsGreaterThan>         \{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* getName()\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}>"{}}; \} \};}
\DoxyCodeLine{1319     \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1OperatorTraits}{OperatorTraits}}<IsLessThanOrEqualTo>   \{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* getName()\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}<="{}}; \} \};}
\DoxyCodeLine{1320     \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1OperatorTraits}{OperatorTraits}}<IsGreaterThanOrEqualTo>\{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* getName()\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}>="{}}; \} \};}
\DoxyCodeLine{1321 }
\DoxyCodeLine{1322     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1323     T\& opCast(T \textcolor{keyword}{const}\& t) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{const\_cast<}T\&\textcolor{keyword}{>}(t); \}}
\DoxyCodeLine{1324 }
\DoxyCodeLine{1325 \textcolor{comment}{// nullptr\_t support based on pull request \#154 from Konstantin Baumann}}
\DoxyCodeLine{1326 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{1327     \textcolor{keyword}{inline} std::nullptr\_t opCast(std::nullptr\_t) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{1328 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{1329 }
\DoxyCodeLine{1330     \textcolor{comment}{// So the compare overloads can be operator agnostic we convey the operator as a template}}
\DoxyCodeLine{1331     \textcolor{comment}{// enum, which is used to specialise an Evaluator for doing the comparison.}}
\DoxyCodeLine{1332     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, Operator Op>}
\DoxyCodeLine{1333     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1Evaluator}{Evaluator}}\{\};}
\DoxyCodeLine{1334 }
\DoxyCodeLine{1335     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1336     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1Evaluator}{Evaluator}}<T1, T2, IsEqualTo> \{}
\DoxyCodeLine{1337         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} evaluate( T1 \textcolor{keyword}{const}\& lhs, T2 \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{1338             \textcolor{keywordflow}{return} bool( opCast( lhs ) ==  opCast( rhs ) );}
\DoxyCodeLine{1339         \}}
\DoxyCodeLine{1340     \};}
\DoxyCodeLine{1341     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1342     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1Evaluator}{Evaluator}}<T1, T2, IsNotEqualTo> \{}
\DoxyCodeLine{1343         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} evaluate( T1 \textcolor{keyword}{const}\& lhs, T2 \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1344             \textcolor{keywordflow}{return} bool( opCast( lhs ) != opCast( rhs ) );}
\DoxyCodeLine{1345         \}}
\DoxyCodeLine{1346     \};}
\DoxyCodeLine{1347     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1348     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1Evaluator}{Evaluator}}<T1, T2, IsLessThan> \{}
\DoxyCodeLine{1349         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} evaluate( T1 \textcolor{keyword}{const}\& lhs, T2 \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1350             \textcolor{keywordflow}{return} bool( opCast( lhs ) < opCast( rhs ) );}
\DoxyCodeLine{1351         \}}
\DoxyCodeLine{1352     \};}
\DoxyCodeLine{1353     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1354     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1Evaluator}{Evaluator}}<T1, T2, IsGreaterThan> \{}
\DoxyCodeLine{1355         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} evaluate( T1 \textcolor{keyword}{const}\& lhs, T2 \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1356             \textcolor{keywordflow}{return} bool( opCast( lhs ) > opCast( rhs ) );}
\DoxyCodeLine{1357         \}}
\DoxyCodeLine{1358     \};}
\DoxyCodeLine{1359     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1360     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1Evaluator}{Evaluator}}<T1, T2, IsGreaterThanOrEqualTo> \{}
\DoxyCodeLine{1361         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} evaluate( T1 \textcolor{keyword}{const}\& lhs, T2 \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1362             \textcolor{keywordflow}{return} bool( opCast( lhs ) >= opCast( rhs ) );}
\DoxyCodeLine{1363         \}}
\DoxyCodeLine{1364     \};}
\DoxyCodeLine{1365     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1366     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Internal_1_1Evaluator}{Evaluator}}<T1, T2, IsLessThanOrEqualTo> \{}
\DoxyCodeLine{1367         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} evaluate( T1 \textcolor{keyword}{const}\& lhs, T2 \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1368             \textcolor{keywordflow}{return} bool( opCast( lhs ) <= opCast( rhs ) );}
\DoxyCodeLine{1369         \}}
\DoxyCodeLine{1370     \};}
\DoxyCodeLine{1371 }
\DoxyCodeLine{1372     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1373     \textcolor{keywordtype}{bool} applyEvaluator( T1 \textcolor{keyword}{const}\& lhs, T2 \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1374         \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Internal_1_1Evaluator}{Evaluator<T1, T2, Op>::evaluate}}( lhs, rhs );}
\DoxyCodeLine{1375     \}}
\DoxyCodeLine{1376 }
\DoxyCodeLine{1377     \textcolor{comment}{// This level of indirection allows us to specialise for integer types}}
\DoxyCodeLine{1378     \textcolor{comment}{// to avoid signed/ unsigned warnings}}
\DoxyCodeLine{1379 }
\DoxyCodeLine{1380     \textcolor{comment}{// "{}base"{} overload}}
\DoxyCodeLine{1381     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1382     \textcolor{keywordtype}{bool} compare( T1 \textcolor{keyword}{const}\& lhs, T2 \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1383         \textcolor{keywordflow}{return} Evaluator<T1, T2, Op>::evaluate( lhs, rhs );}
\DoxyCodeLine{1384     \}}
\DoxyCodeLine{1385 }
\DoxyCodeLine{1386     \textcolor{comment}{// unsigned X to int}}
\DoxyCodeLine{1387     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lhs, \textcolor{keywordtype}{int} rhs ) \{}
\DoxyCodeLine{1388         \textcolor{keywordflow}{return} applyEvaluator<Op>( lhs, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1389     \}}
\DoxyCodeLine{1390     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{int} rhs ) \{}
\DoxyCodeLine{1391         \textcolor{keywordflow}{return} applyEvaluator<Op>( lhs, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1392     \}}
\DoxyCodeLine{1393     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} lhs, \textcolor{keywordtype}{int} rhs ) \{}
\DoxyCodeLine{1394         \textcolor{keywordflow}{return} applyEvaluator<Op>( lhs, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1395     \}}
\DoxyCodeLine{1396 }
\DoxyCodeLine{1397     \textcolor{comment}{// unsigned X to long}}
\DoxyCodeLine{1398     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lhs, \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1399         \textcolor{keywordflow}{return} applyEvaluator<Op>( lhs, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1400     \}}
\DoxyCodeLine{1401     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1402         \textcolor{keywordflow}{return} applyEvaluator<Op>( lhs, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1403     \}}
\DoxyCodeLine{1404     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} lhs, \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1405         \textcolor{keywordflow}{return} applyEvaluator<Op>( lhs, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1406     \}}
\DoxyCodeLine{1407 }
\DoxyCodeLine{1408     \textcolor{comment}{// int to unsigned X}}
\DoxyCodeLine{1409     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{int} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rhs ) \{}
\DoxyCodeLine{1410         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1411     \}}
\DoxyCodeLine{1412     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{int} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1413         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1414     \}}
\DoxyCodeLine{1415     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{int} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} rhs ) \{}
\DoxyCodeLine{1416         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1417     \}}
\DoxyCodeLine{1418 }
\DoxyCodeLine{1419     \textcolor{comment}{// long to unsigned X}}
\DoxyCodeLine{1420     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rhs ) \{}
\DoxyCodeLine{1421         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1422     \}}
\DoxyCodeLine{1423     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1424         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1425     \}}
\DoxyCodeLine{1426     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} rhs ) \{}
\DoxyCodeLine{1427         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1428     \}}
\DoxyCodeLine{1429 }
\DoxyCodeLine{1430     \textcolor{comment}{// pointer to long (when comparing against NULL)}}
\DoxyCodeLine{1431     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} lhs, T* rhs ) \{}
\DoxyCodeLine{1432         \textcolor{keywordflow}{return} Evaluator<T*, T*, Op>::evaluate( \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1433     \}}
\DoxyCodeLine{1434     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} compare( T* lhs, \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1435         \textcolor{keywordflow}{return} Evaluator<T*, T*, Op>::evaluate( lhs, \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1436     \}}
\DoxyCodeLine{1437 }
\DoxyCodeLine{1438     \textcolor{comment}{// pointer to int (when comparing against NULL)}}
\DoxyCodeLine{1439     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{int} lhs, T* rhs ) \{}
\DoxyCodeLine{1440         \textcolor{keywordflow}{return} Evaluator<T*, T*, Op>::evaluate( \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1441     \}}
\DoxyCodeLine{1442     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} compare( T* lhs, \textcolor{keywordtype}{int} rhs ) \{}
\DoxyCodeLine{1443         \textcolor{keywordflow}{return} Evaluator<T*, T*, Op>::evaluate( lhs, \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1444     \}}
\DoxyCodeLine{1445 }
\DoxyCodeLine{1446 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_LONG\_LONG}}
\DoxyCodeLine{1447     \textcolor{comment}{// long long to unsigned X}}
\DoxyCodeLine{1448     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rhs ) \{}
\DoxyCodeLine{1449         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1450     \}}
\DoxyCodeLine{1451     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1452         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1453     \}}
\DoxyCodeLine{1454     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1455         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1456     \}}
\DoxyCodeLine{1457     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} rhs ) \{}
\DoxyCodeLine{1458         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1459     \}}
\DoxyCodeLine{1460 }
\DoxyCodeLine{1461     \textcolor{comment}{// unsigned long long to X}}
\DoxyCodeLine{1462     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{int} rhs ) \{}
\DoxyCodeLine{1463         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1464     \}}
\DoxyCodeLine{1465     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1466         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1467     \}}
\DoxyCodeLine{1468     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1469         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1470     \}}
\DoxyCodeLine{1471     \textcolor{keyword}{template}<Operator Op> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, \textcolor{keywordtype}{char} rhs ) \{}
\DoxyCodeLine{1472         \textcolor{keywordflow}{return} applyEvaluator<Op>( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long}\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1473     \}}
\DoxyCodeLine{1474 }
\DoxyCodeLine{1475     \textcolor{comment}{// pointer to long long (when comparing against NULL)}}
\DoxyCodeLine{1476     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} compare( \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} lhs, T* rhs ) \{}
\DoxyCodeLine{1477         \textcolor{keywordflow}{return} Evaluator<T*, T*, Op>::evaluate( \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}( lhs ), rhs );}
\DoxyCodeLine{1478     \}}
\DoxyCodeLine{1479     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} compare( T* lhs, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} rhs ) \{}
\DoxyCodeLine{1480         \textcolor{keywordflow}{return} Evaluator<T*, T*, Op>::evaluate( lhs, \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{1481     \}}
\DoxyCodeLine{1482 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_CPP11\_LONG\_LONG}}
\DoxyCodeLine{1483 }
\DoxyCodeLine{1484 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{1485     \textcolor{comment}{// pointer to nullptr\_t (when comparing against nullptr)}}
\DoxyCodeLine{1486     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} compare( std::nullptr\_t, T* rhs ) \{}
\DoxyCodeLine{1487         \textcolor{keywordflow}{return} Evaluator<T*, T*, Op>::evaluate( \textcolor{keyword}{nullptr}, rhs );}
\DoxyCodeLine{1488     \}}
\DoxyCodeLine{1489     \textcolor{keyword}{template}<Operator Op, \textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} compare( T* lhs, std::nullptr\_t ) \{}
\DoxyCodeLine{1490         \textcolor{keywordflow}{return} Evaluator<T*, T*, Op>::evaluate( lhs, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{1491     \}}
\DoxyCodeLine{1492 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{1493 }
\DoxyCodeLine{1494 \} \textcolor{comment}{// end of namespace Internal}}
\DoxyCodeLine{1495 \} \textcolor{comment}{// end of namespace Catch}}
\DoxyCodeLine{1496 }
\DoxyCodeLine{1497 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{1498 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{1499 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1500 }
\DoxyCodeLine{1501 \textcolor{comment}{// \#included from: catch\_tostring.h}}
\DoxyCodeLine{1502 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TOSTRING\_H\_INCLUDED}}
\DoxyCodeLine{1503 }
\DoxyCodeLine{1504 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{1505 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{1506 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{1507 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{1508 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{1509 }
\DoxyCodeLine{1510 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{1511 \textcolor{comment}{// \#included from: catch\_objc\_arc.hpp}}
\DoxyCodeLine{1512 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_OBJC\_ARC\_HPP\_INCLUDED}}
\DoxyCodeLine{1513 }
\DoxyCodeLine{1514 \textcolor{preprocessor}{\#import <Foundation/Foundation.h>}}
\DoxyCodeLine{1515 }
\DoxyCodeLine{1516 \textcolor{preprocessor}{\#ifdef \_\_has\_feature}}
\DoxyCodeLine{1517 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED \_\_has\_feature(objc\_arc)}}
\DoxyCodeLine{1518 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1519 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED 0}}
\DoxyCodeLine{1520 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1521 }
\DoxyCodeLine{1522 \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj );}
\DoxyCodeLine{1523 \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel );}
\DoxyCodeLine{1524 }
\DoxyCodeLine{1525 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{1526 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj ) \{}
\DoxyCodeLine{1527     [obj release];}
\DoxyCodeLine{1528 \}}
\DoxyCodeLine{1529 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{1530     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{1531         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{1532     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{1533 \}}
\DoxyCodeLine{1534 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED}}
\DoxyCodeLine{1535 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG}}
\DoxyCodeLine{1536 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1537 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* )\{\}}
\DoxyCodeLine{1538 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{1539 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1540 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{1541 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Warc-\/performSelector-\/leaks"{}}}
\DoxyCodeLine{1542 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1543     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{1544         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{1545 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1546 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{1547 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1548     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{1549 \}}
\DoxyCodeLine{1550 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED \_\_unsafe\_unretained}}
\DoxyCodeLine{1551 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG \_\_strong}}
\DoxyCodeLine{1552 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1553 }
\DoxyCodeLine{1554 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1555 }
\DoxyCodeLine{1556 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_TUPLE}}
\DoxyCodeLine{1557 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{1558 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1559 }
\DoxyCodeLine{1560 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_IS\_ENUM}}
\DoxyCodeLine{1561 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{1562 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1563 }
\DoxyCodeLine{1564 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1565 }
\DoxyCodeLine{1566 \textcolor{comment}{// Why we're here.}}
\DoxyCodeLine{1567 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1568 std::string toString( T \textcolor{keyword}{const}\& value );}
\DoxyCodeLine{1569 }
\DoxyCodeLine{1570 \textcolor{comment}{// Built in overloads}}
\DoxyCodeLine{1571 }
\DoxyCodeLine{1572 std::string toString( std::string \textcolor{keyword}{const}\& value );}
\DoxyCodeLine{1573 std::string toString( std::wstring \textcolor{keyword}{const}\& value );}
\DoxyCodeLine{1574 std::string toString( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{keyword}{const} value );}
\DoxyCodeLine{1575 std::string toString( \textcolor{keywordtype}{char}* \textcolor{keyword}{const} value );}
\DoxyCodeLine{1576 std::string toString( \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* \textcolor{keyword}{const} value );}
\DoxyCodeLine{1577 std::string toString( \textcolor{keywordtype}{wchar\_t}* \textcolor{keyword}{const} value );}
\DoxyCodeLine{1578 std::string toString( \textcolor{keywordtype}{int} value );}
\DoxyCodeLine{1579 std::string toString( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value );}
\DoxyCodeLine{1580 std::string toString( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value );}
\DoxyCodeLine{1581 std::string toString( \textcolor{keyword}{const} \textcolor{keywordtype}{double} value );}
\DoxyCodeLine{1582 std::string toString( \textcolor{keyword}{const} \textcolor{keywordtype}{float} value );}
\DoxyCodeLine{1583 std::string toString( \textcolor{keywordtype}{bool} value );}
\DoxyCodeLine{1584 std::string toString( \textcolor{keywordtype}{char} value );}
\DoxyCodeLine{1585 std::string toString( \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} value );}
\DoxyCodeLine{1586 std::string toString( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} value );}
\DoxyCodeLine{1587 }
\DoxyCodeLine{1588 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_LONG\_LONG}}
\DoxyCodeLine{1589 std::string toString( \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value );}
\DoxyCodeLine{1590 std::string toString( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value );}
\DoxyCodeLine{1591 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1592 }
\DoxyCodeLine{1593 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{1594 std::string toString( std::nullptr\_t );}
\DoxyCodeLine{1595 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1596 }
\DoxyCodeLine{1597 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{1598     std::string toString( NSString \textcolor{keyword}{const} * \textcolor{keyword}{const}\& nsstring );}
\DoxyCodeLine{1599     std::string toString( NSString * CATCH\_ARC\_STRONG \& nsstring );}
\DoxyCodeLine{1600     std::string toString( NSObject* \textcolor{keyword}{const}\& nsObject );}
\DoxyCodeLine{1601 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1602 }
\DoxyCodeLine{1603 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1604 }
\DoxyCodeLine{1605     \textcolor{keyword}{extern} \textcolor{keyword}{const} std::string unprintableString;}
\DoxyCodeLine{1606 }
\DoxyCodeLine{1607 \textcolor{preprocessor}{ \#if !defined(CATCH\_CONFIG\_CPP11\_STREAM\_INSERTABLE\_CHECK)}}
\DoxyCodeLine{1608     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Detail_1_1BorgType}{BorgType}} \{}
\DoxyCodeLine{1609         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \mbox{\hyperlink{structCatch_1_1Detail_1_1BorgType}{BorgType}}( T \textcolor{keyword}{const}\& );}
\DoxyCodeLine{1610     \};}
\DoxyCodeLine{1611 }
\DoxyCodeLine{1612     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Detail_1_1TrueType}{TrueType}} \{ \textcolor{keywordtype}{char} sizer[1]; \};}
\DoxyCodeLine{1613     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Detail_1_1FalseType}{FalseType}} \{ \textcolor{keywordtype}{char} sizer[2]; \};}
\DoxyCodeLine{1614 }
\DoxyCodeLine{1615     \mbox{\hyperlink{structCatch_1_1Detail_1_1TrueType}{TrueType}}\& testStreamable( std::ostream\& );}
\DoxyCodeLine{1616     \mbox{\hyperlink{structCatch_1_1Detail_1_1FalseType}{FalseType}} testStreamable( \mbox{\hyperlink{structCatch_1_1Detail_1_1FalseType}{FalseType}} );}
\DoxyCodeLine{1617 }
\DoxyCodeLine{1618     \mbox{\hyperlink{structCatch_1_1Detail_1_1FalseType}{FalseType}} operator<<( std::ostream \textcolor{keyword}{const}\&, \mbox{\hyperlink{structCatch_1_1Detail_1_1BorgType}{BorgType}} \textcolor{keyword}{const}\& );}
\DoxyCodeLine{1619 }
\DoxyCodeLine{1620     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1621     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Detail_1_1IsStreamInsertable}{IsStreamInsertable}} \{}
\DoxyCodeLine{1622         \textcolor{keyword}{static} std::ostream \&s;}
\DoxyCodeLine{1623         \textcolor{keyword}{static} T  \textcolor{keyword}{const}\&t;}
\DoxyCodeLine{1624         \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{sizeof}( testStreamable(s << t) ) == \textcolor{keyword}{sizeof}( \mbox{\hyperlink{structCatch_1_1Detail_1_1TrueType}{TrueType}} ) \};}
\DoxyCodeLine{1625     \};}
\DoxyCodeLine{1626 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1627     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1628     \textcolor{keyword}{class }\mbox{\hyperlink{structCatch_1_1Detail_1_1IsStreamInsertable}{IsStreamInsertable}} \{}
\DoxyCodeLine{1629         \textcolor{keyword}{template}<\textcolor{keyword}{typename} SS, \textcolor{keyword}{typename} TT>}
\DoxyCodeLine{1630         \textcolor{keyword}{static} \textcolor{keyword}{auto} test(\textcolor{keywordtype}{int})}
\DoxyCodeLine{1631         -\/> \textcolor{keyword}{decltype}( std::declval<SS\&>() << std::declval<TT>(), std::true\_type() );}
\DoxyCodeLine{1632 }
\DoxyCodeLine{1633         \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}>}
\DoxyCodeLine{1634         \textcolor{keyword}{static} \textcolor{keyword}{auto} test(...) -\/> std::false\_type;}
\DoxyCodeLine{1635 }
\DoxyCodeLine{1636     \textcolor{keyword}{public}:}
\DoxyCodeLine{1637         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{decltype}(test<std::ostream,const T\&>(0))::value;}
\DoxyCodeLine{1638     \};}
\DoxyCodeLine{1639 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1640 }
\DoxyCodeLine{1641 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_IS\_ENUM)}}
\DoxyCodeLine{1642     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T,}
\DoxyCodeLine{1643              \textcolor{keywordtype}{bool} IsEnum = std::is\_enum<T>::value}
\DoxyCodeLine{1644              >}
\DoxyCodeLine{1645     \textcolor{keyword}{struct }EnumStringMaker}
\DoxyCodeLine{1646     \{}
\DoxyCodeLine{1647         \textcolor{keyword}{static} std::string convert( T \textcolor{keyword}{const}\& ) \{ \textcolor{keywordflow}{return} unprintableString; \}}
\DoxyCodeLine{1648     \};}
\DoxyCodeLine{1649 }
\DoxyCodeLine{1650     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1651     \textcolor{keyword}{struct }EnumStringMaker<T,true>}
\DoxyCodeLine{1652     \{}
\DoxyCodeLine{1653         \textcolor{keyword}{static} std::string convert( T \textcolor{keyword}{const}\& v )}
\DoxyCodeLine{1654         \{}
\DoxyCodeLine{1655             return ::Catch::toString(}
\DoxyCodeLine{1656                 \textcolor{keyword}{static\_cast<}typename std::underlying\_type<T>::type\textcolor{keyword}{>}(v)}
\DoxyCodeLine{1657                 );}
\DoxyCodeLine{1658         \}}
\DoxyCodeLine{1659     \};}
\DoxyCodeLine{1660 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1661     \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} C>}
\DoxyCodeLine{1662     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Detail_1_1StringMakerBase}{StringMakerBase}} \{}
\DoxyCodeLine{1663 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_IS\_ENUM)}}
\DoxyCodeLine{1664         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1665         \textcolor{keyword}{static} std::string convert( T \textcolor{keyword}{const}\& v )}
\DoxyCodeLine{1666         \{}
\DoxyCodeLine{1667             \textcolor{keywordflow}{return} EnumStringMaker<T>::convert( v );}
\DoxyCodeLine{1668         \}}
\DoxyCodeLine{1669 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1670         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1671         \textcolor{keyword}{static} std::string convert( T \textcolor{keyword}{const}\& ) \{ \textcolor{keywordflow}{return} unprintableString; \}}
\DoxyCodeLine{1672 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1673     \};}
\DoxyCodeLine{1674 }
\DoxyCodeLine{1675     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1676     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Detail_1_1StringMakerBase}{StringMakerBase}}<true> \{}
\DoxyCodeLine{1677         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1678         \textcolor{keyword}{static} std::string convert( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{1679             std::ostringstream oss;}
\DoxyCodeLine{1680             oss << \_value;}
\DoxyCodeLine{1681             \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{1682         \}}
\DoxyCodeLine{1683     \};}
\DoxyCodeLine{1684 }
\DoxyCodeLine{1685     std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size );}
\DoxyCodeLine{1686 }
\DoxyCodeLine{1687     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1688     std::string rawMemoryToString( \textcolor{keyword}{const} T\& \textcolor{keywordtype}{object} ) \{}
\DoxyCodeLine{1689       \textcolor{keywordflow}{return} rawMemoryToString( \&\textcolor{keywordtype}{object}, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{object}) );}
\DoxyCodeLine{1690     \}}
\DoxyCodeLine{1691 }
\DoxyCodeLine{1692 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{1693 }
\DoxyCodeLine{1694 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1695 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}} :}
\DoxyCodeLine{1696     \mbox{\hyperlink{structCatch_1_1Detail_1_1StringMakerBase}{Detail::StringMakerBase}}<Detail::IsStreamInsertable<T>::value> \{\};}
\DoxyCodeLine{1697 }
\DoxyCodeLine{1698 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1699 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<T*> \{}
\DoxyCodeLine{1700     \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{1701     \textcolor{keyword}{static} std::string convert( U* p ) \{}
\DoxyCodeLine{1702         \textcolor{keywordflow}{if}( !p )}
\DoxyCodeLine{1703             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}NULL"{}};}
\DoxyCodeLine{1704         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1705             \textcolor{keywordflow}{return} Detail::rawMemoryToString( p );}
\DoxyCodeLine{1706     \}}
\DoxyCodeLine{1707 \};}
\DoxyCodeLine{1708 }
\DoxyCodeLine{1709 \textcolor{keyword}{template}<\textcolor{keyword}{typename} R, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{1710 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<R C::*> \{}
\DoxyCodeLine{1711     \textcolor{keyword}{static} std::string convert( R C::* p ) \{}
\DoxyCodeLine{1712         \textcolor{keywordflow}{if}( !p )}
\DoxyCodeLine{1713             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}NULL"{}};}
\DoxyCodeLine{1714         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1715             \textcolor{keywordflow}{return} Detail::rawMemoryToString( p );}
\DoxyCodeLine{1716     \}}
\DoxyCodeLine{1717 \};}
\DoxyCodeLine{1718 }
\DoxyCodeLine{1719 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1720     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterator>}
\DoxyCodeLine{1721     std::string rangeToString( InputIterator first, InputIterator last );}
\DoxyCodeLine{1722 \}}
\DoxyCodeLine{1723 }
\DoxyCodeLine{1724 \textcolor{comment}{//template<typename T, typename Allocator>}}
\DoxyCodeLine{1725 \textcolor{comment}{//struct StringMaker<std::vector<T, Allocator> > \{}}
\DoxyCodeLine{1726 \textcolor{comment}{//    static std::string convert( std::vector<T,Allocator> const\& v ) \{}}
\DoxyCodeLine{1727 \textcolor{comment}{//        return Detail::rangeToString( v.begin(), v.end() );}}
\DoxyCodeLine{1728 \textcolor{comment}{//    \}}}
\DoxyCodeLine{1729 \textcolor{comment}{//\};}}
\DoxyCodeLine{1730 }
\DoxyCodeLine{1731 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{1732 std::string toString( std::vector<T,Allocator> \textcolor{keyword}{const}\& v ) \{}
\DoxyCodeLine{1733     \textcolor{keywordflow}{return} Detail::rangeToString( v.begin(), v.end() );}
\DoxyCodeLine{1734 \}}
\DoxyCodeLine{1735 }
\DoxyCodeLine{1736 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_TUPLE}}
\DoxyCodeLine{1737 }
\DoxyCodeLine{1738 \textcolor{comment}{// toString for tuples}}
\DoxyCodeLine{1739 \textcolor{keyword}{namespace }TupleDetail \{}
\DoxyCodeLine{1740   \textcolor{keyword}{template}<}
\DoxyCodeLine{1741       \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{1742       std::size\_t N = 0,}
\DoxyCodeLine{1743       \textcolor{keywordtype}{bool} = (N < std::tuple\_size<Tuple>::value)}
\DoxyCodeLine{1744       >}
\DoxyCodeLine{1745   \textcolor{keyword}{struct} ElementPrinter \{}
\DoxyCodeLine{1746       \textcolor{keyword}{static} \textcolor{keywordtype}{void} print( \textcolor{keyword}{const} Tuple\& tuple, std::ostream\& os )}
\DoxyCodeLine{1747       \{}
\DoxyCodeLine{1748           os << ( N ? \textcolor{stringliteral}{"{}, "{}} : \textcolor{stringliteral}{"{} "{}} )}
\DoxyCodeLine{1749              << Catch::toString(std::get<N>(tuple));}
\DoxyCodeLine{1750           ElementPrinter<Tuple,N+1>::print(tuple,os);}
\DoxyCodeLine{1751       \}}
\DoxyCodeLine{1752   \};}
\DoxyCodeLine{1753 }
\DoxyCodeLine{1754   \textcolor{keyword}{template}<}
\DoxyCodeLine{1755       \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{1756       std::size\_t N}
\DoxyCodeLine{1757       >}
\DoxyCodeLine{1758   \textcolor{keyword}{struct }ElementPrinter<Tuple,N,false> \{}
\DoxyCodeLine{1759       \textcolor{keyword}{static} \textcolor{keywordtype}{void} print( \textcolor{keyword}{const} Tuple\&, std::ostream\& ) \{\}}
\DoxyCodeLine{1760   \};}
\DoxyCodeLine{1761 }
\DoxyCodeLine{1762 \}}
\DoxyCodeLine{1763 }
\DoxyCodeLine{1764 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...Types>}
\DoxyCodeLine{1765 \textcolor{keyword}{struct }StringMaker<std::tuple<Types...>> \{}
\DoxyCodeLine{1766 }
\DoxyCodeLine{1767     \textcolor{keyword}{static} std::string convert( \textcolor{keyword}{const} std::tuple<Types...>\& tuple )}
\DoxyCodeLine{1768     \{}
\DoxyCodeLine{1769         std::ostringstream os;}
\DoxyCodeLine{1770         os << \textcolor{charliteral}{'\{'};}
\DoxyCodeLine{1771         TupleDetail::ElementPrinter<std::tuple<Types...>>::print( tuple, os );}
\DoxyCodeLine{1772         os << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1773         \textcolor{keywordflow}{return} os.str();}
\DoxyCodeLine{1774     \}}
\DoxyCodeLine{1775 \};}
\DoxyCodeLine{1776 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_CPP11\_TUPLE}}
\DoxyCodeLine{1777 }
\DoxyCodeLine{1778 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1779     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1780     std::string makeString( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{1781         \textcolor{keywordflow}{return} StringMaker<T>::convert( value );}
\DoxyCodeLine{1782     \}}
\DoxyCodeLine{1783 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{1784 }
\DoxyCodeLine{1792 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1793 std::string toString( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{1794     \textcolor{keywordflow}{return} StringMaker<T>::convert( value );}
\DoxyCodeLine{1795 \}}
\DoxyCodeLine{1796 }
\DoxyCodeLine{1797     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1798     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterator>}
\DoxyCodeLine{1799     std::string rangeToString( InputIterator first, InputIterator last ) \{}
\DoxyCodeLine{1800         std::ostringstream oss;}
\DoxyCodeLine{1801         oss << \textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{1802         \textcolor{keywordflow}{if}( first != last ) \{}
\DoxyCodeLine{1803             oss << Catch::toString( *first );}
\DoxyCodeLine{1804             \textcolor{keywordflow}{for}( ++first ; first != last ; ++first )}
\DoxyCodeLine{1805                 oss << \textcolor{stringliteral}{"{}, "{}} << Catch::toString( *first );}
\DoxyCodeLine{1806         \}}
\DoxyCodeLine{1807         oss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1808         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{1809     \}}
\DoxyCodeLine{1810 \}}
\DoxyCodeLine{1811 }
\DoxyCodeLine{1812 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1813 }
\DoxyCodeLine{1814 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1815 }
\DoxyCodeLine{1816 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, Internal::Operator Op, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1817 \textcolor{keyword}{class }BinaryExpression;}
\DoxyCodeLine{1818 }
\DoxyCodeLine{1819 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{1820 \textcolor{keyword}{class }MatchExpression;}
\DoxyCodeLine{1821 }
\DoxyCodeLine{1822 \textcolor{comment}{// Wraps the LHS of an expression and overloads comparison operators}}
\DoxyCodeLine{1823 \textcolor{comment}{// for also capturing those and RHS (if any)}}
\DoxyCodeLine{1824 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1825 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ExpressionLhs}{ExpressionLhs}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}} \{}
\DoxyCodeLine{1826 \textcolor{keyword}{public}:}
\DoxyCodeLine{1827     \mbox{\hyperlink{classCatch_1_1ExpressionLhs}{ExpressionLhs}}( \mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}}\& rb, T lhs ) : m\_rb( rb ), m\_lhs( lhs ), m\_truthy(\textcolor{keyword}{false}) \{\}}
\DoxyCodeLine{1828 }
\DoxyCodeLine{1829     \mbox{\hyperlink{classCatch_1_1ExpressionLhs}{ExpressionLhs}}\& operator = ( \textcolor{keyword}{const} \mbox{\hyperlink{classCatch_1_1ExpressionLhs}{ExpressionLhs}}\& );}
\DoxyCodeLine{1830 }
\DoxyCodeLine{1831     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1832     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Internal::IsEqualTo, RhsT const\&>}}}
\DoxyCodeLine{1833     operator == ( RhsT \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1834         \textcolor{keywordflow}{return} captureExpression<Internal::IsEqualTo>( rhs );}
\DoxyCodeLine{1835     \}}
\DoxyCodeLine{1836 }
\DoxyCodeLine{1837     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1838     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Internal::IsNotEqualTo, RhsT const\&>}}}
\DoxyCodeLine{1839     operator != ( RhsT \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1840         \textcolor{keywordflow}{return} captureExpression<Internal::IsNotEqualTo>( rhs );}
\DoxyCodeLine{1841     \}}
\DoxyCodeLine{1842 }
\DoxyCodeLine{1843     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1844     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Internal::IsLessThan, RhsT const\&>}}}
\DoxyCodeLine{1845     operator < ( RhsT \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1846         \textcolor{keywordflow}{return} captureExpression<Internal::IsLessThan>( rhs );}
\DoxyCodeLine{1847     \}}
\DoxyCodeLine{1848 }
\DoxyCodeLine{1849     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1850     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Internal::IsGreaterThan, RhsT const\&>}}}
\DoxyCodeLine{1851     operator > ( RhsT \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1852         \textcolor{keywordflow}{return} captureExpression<Internal::IsGreaterThan>( rhs );}
\DoxyCodeLine{1853     \}}
\DoxyCodeLine{1854 }
\DoxyCodeLine{1855     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1856     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Internal::IsLessThanOrEqualTo, RhsT const\&>}}}
\DoxyCodeLine{1857     operator <= ( RhsT \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1858         \textcolor{keywordflow}{return} captureExpression<Internal::IsLessThanOrEqualTo>( rhs );}
\DoxyCodeLine{1859     \}}
\DoxyCodeLine{1860 }
\DoxyCodeLine{1861     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1862     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Internal::IsGreaterThanOrEqualTo, RhsT const\&>}}}
\DoxyCodeLine{1863     operator >= ( RhsT \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{1864         \textcolor{keywordflow}{return} captureExpression<Internal::IsGreaterThanOrEqualTo>( rhs );}
\DoxyCodeLine{1865     \}}
\DoxyCodeLine{1866 }
\DoxyCodeLine{1867     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Internal::IsEqualTo, bool>}} operator == ( \textcolor{keywordtype}{bool} rhs ) \{}
\DoxyCodeLine{1868         \textcolor{keywordflow}{return} captureExpression<Internal::IsEqualTo>( rhs );}
\DoxyCodeLine{1869     \}}
\DoxyCodeLine{1870 }
\DoxyCodeLine{1871     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Internal::IsNotEqualTo, bool>}} operator != ( \textcolor{keywordtype}{bool} rhs ) \{}
\DoxyCodeLine{1872         \textcolor{keywordflow}{return} captureExpression<Internal::IsNotEqualTo>( rhs );}
\DoxyCodeLine{1873     \}}
\DoxyCodeLine{1874 }
\DoxyCodeLine{1875     \textcolor{keywordtype}{void} endExpression() \{}
\DoxyCodeLine{1876         m\_truthy = m\_lhs ? true : \textcolor{keyword}{false};}
\DoxyCodeLine{1877         m\_rb}
\DoxyCodeLine{1878             .setResultType( m\_truthy )}
\DoxyCodeLine{1879             .endExpression( *\textcolor{keyword}{this} );}
\DoxyCodeLine{1880     \}}
\DoxyCodeLine{1881 }
\DoxyCodeLine{1882     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} reconstructExpression( std::string\& dest ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1883         dest = Catch::toString( m\_lhs );}
\DoxyCodeLine{1884     \}}
\DoxyCodeLine{1885 }
\DoxyCodeLine{1886 \textcolor{keyword}{private}:}
\DoxyCodeLine{1887     \textcolor{keyword}{template}<Internal::Operator Op, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1888     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Op, RhsT\&>}} captureExpression( RhsT\& rhs )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1889         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Op, RhsT\&>}}( m\_rb, m\_lhs, rhs );}
\DoxyCodeLine{1890     \}}
\DoxyCodeLine{1891 }
\DoxyCodeLine{1892     \textcolor{keyword}{template}<Internal::Operator Op>}
\DoxyCodeLine{1893     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Op, bool>}} captureExpression( \textcolor{keywordtype}{bool} rhs )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1894         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression<T, Op, bool>}}( m\_rb, m\_lhs, rhs );}
\DoxyCodeLine{1895     \}}
\DoxyCodeLine{1896 }
\DoxyCodeLine{1897 \textcolor{keyword}{private}:}
\DoxyCodeLine{1898     \mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}}\& m\_rb;}
\DoxyCodeLine{1899     T m\_lhs;}
\DoxyCodeLine{1900     \textcolor{keywordtype}{bool} m\_truthy;}
\DoxyCodeLine{1901 \};}
\DoxyCodeLine{1902 }
\DoxyCodeLine{1903 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, Internal::Operator Op, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{1904 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}} \{}
\DoxyCodeLine{1905 \textcolor{keyword}{public}:}
\DoxyCodeLine{1906     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression}}( \mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}}\& rb, LhsT lhs, RhsT rhs )}
\DoxyCodeLine{1907         : m\_rb( rb ), m\_lhs( lhs ), m\_rhs( rhs ) \{\}}
\DoxyCodeLine{1908 }
\DoxyCodeLine{1909     \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression}}\& operator = ( \mbox{\hyperlink{classCatch_1_1BinaryExpression}{BinaryExpression}}\& );}
\DoxyCodeLine{1910 }
\DoxyCodeLine{1911     \textcolor{keywordtype}{void} endExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1912         m\_rb}
\DoxyCodeLine{1913             .setResultType( Internal::compare<Op>( m\_lhs, m\_rhs ) )}
\DoxyCodeLine{1914             .endExpression( *\textcolor{keyword}{this} );}
\DoxyCodeLine{1915     \}}
\DoxyCodeLine{1916 }
\DoxyCodeLine{1917     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isBinaryExpression() \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1918         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1919     \}}
\DoxyCodeLine{1920 }
\DoxyCodeLine{1921     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} reconstructExpression( std::string\& dest ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1922         std::string lhs = Catch::toString( m\_lhs );}
\DoxyCodeLine{1923         std::string rhs = Catch::toString( m\_rhs );}
\DoxyCodeLine{1924         \textcolor{keywordtype}{char} delim = lhs.size() + rhs.size() < 40 \&\&}
\DoxyCodeLine{1925                      lhs.find(\textcolor{charliteral}{'\(\backslash\)n'}) == std::string::npos \&\&}
\DoxyCodeLine{1926                      rhs.find(\textcolor{charliteral}{'\(\backslash\)n'}) == std::string::npos ? \textcolor{charliteral}{' '} : \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{1927         dest.reserve( 7 + lhs.size() + rhs.size() );}
\DoxyCodeLine{1928                    \textcolor{comment}{// 2 for spaces around operator}}
\DoxyCodeLine{1929                    \textcolor{comment}{// 2 for operator}}
\DoxyCodeLine{1930                    \textcolor{comment}{// 2 for parentheses (conditionally added later)}}
\DoxyCodeLine{1931                    \textcolor{comment}{// 1 for negation (conditionally added later)}}
\DoxyCodeLine{1932         dest = lhs;}
\DoxyCodeLine{1933         dest += delim;}
\DoxyCodeLine{1934         dest += \mbox{\hyperlink{structCatch_1_1Internal_1_1OperatorTraits}{Internal::OperatorTraits<Op>::getName}}();}
\DoxyCodeLine{1935         dest += delim;}
\DoxyCodeLine{1936         dest += rhs;}
\DoxyCodeLine{1937     \}}
\DoxyCodeLine{1938 }
\DoxyCodeLine{1939 \textcolor{keyword}{private}:}
\DoxyCodeLine{1940     \mbox{\hyperlink{classCatch_1_1ResultBuilder}{ResultBuilder}}\& m\_rb;}
\DoxyCodeLine{1941     LhsT m\_lhs;}
\DoxyCodeLine{1942     RhsT m\_rhs;}
\DoxyCodeLine{1943 \};}
\DoxyCodeLine{1944 }
\DoxyCodeLine{1945 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{1946 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1MatchExpression}{MatchExpression}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1DecomposedExpression}{DecomposedExpression}} \{}
\DoxyCodeLine{1947 \textcolor{keyword}{public}:}
\DoxyCodeLine{1948     \mbox{\hyperlink{classCatch_1_1MatchExpression}{MatchExpression}}( ArgT arg, MatcherT matcher, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* matcherString )}
\DoxyCodeLine{1949         : m\_arg( arg ), m\_matcher( matcher ), m\_matcherString( matcherString ) \{\}}
\DoxyCodeLine{1950 }
\DoxyCodeLine{1951     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isBinaryExpression() \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1952         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1953     \}}
\DoxyCodeLine{1954 }
\DoxyCodeLine{1955     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} reconstructExpression( std::string\& dest ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{1956         std::string matcherAsString = m\_matcher.toString();}
\DoxyCodeLine{1957         dest = Catch::toString( m\_arg );}
\DoxyCodeLine{1958         dest += \textcolor{charliteral}{' '};}
\DoxyCodeLine{1959         \textcolor{keywordflow}{if}( matcherAsString == Detail::unprintableString )}
\DoxyCodeLine{1960             dest += m\_matcherString;}
\DoxyCodeLine{1961         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1962             dest += matcherAsString;}
\DoxyCodeLine{1963     \}}
\DoxyCodeLine{1964 }
\DoxyCodeLine{1965 \textcolor{keyword}{private}:}
\DoxyCodeLine{1966     ArgT m\_arg;}
\DoxyCodeLine{1967     MatcherT m\_matcher;}
\DoxyCodeLine{1968     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* m\_matcherString;}
\DoxyCodeLine{1969 \};}
\DoxyCodeLine{1970 }
\DoxyCodeLine{1971 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1972 }
\DoxyCodeLine{1973 }
\DoxyCodeLine{1974 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1975 }
\DoxyCodeLine{1976     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1977     ExpressionLhs<T const\&> ResultBuilder::operator <= ( T \textcolor{keyword}{const}\& operand ) \{}
\DoxyCodeLine{1978         \textcolor{keywordflow}{return} ExpressionLhs<T const\&>( *\textcolor{keyword}{this}, operand );}
\DoxyCodeLine{1979     \}}
\DoxyCodeLine{1980 }
\DoxyCodeLine{1981     \textcolor{keyword}{inline} ExpressionLhs<bool> ResultBuilder::operator <= ( \textcolor{keywordtype}{bool} value ) \{}
\DoxyCodeLine{1982         \textcolor{keywordflow}{return} ExpressionLhs<bool>( *\textcolor{keyword}{this}, value );}
\DoxyCodeLine{1983     \}}
\DoxyCodeLine{1984 }
\DoxyCodeLine{1985     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{1986     \textcolor{keywordtype}{void} ResultBuilder::captureMatch( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher,}
\DoxyCodeLine{1987                                              \textcolor{keywordtype}{char} \textcolor{keyword}{const}* matcherString ) \{}
\DoxyCodeLine{1988         MatchExpression<ArgT const\&, MatcherT const\&> expr( arg, matcher, matcherString );}
\DoxyCodeLine{1989         setResultType( matcher.match( arg ) );}
\DoxyCodeLine{1990         endExpression( expr );}
\DoxyCodeLine{1991     \}}
\DoxyCodeLine{1992 }
\DoxyCodeLine{1993 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{1994 }
\DoxyCodeLine{1995 \textcolor{comment}{// \#included from: catch\_message.h}}
\DoxyCodeLine{1996 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_MESSAGE\_H\_INCLUDED}}
\DoxyCodeLine{1997 }
\DoxyCodeLine{1998 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{1999 }
\DoxyCodeLine{2000 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2001 }
\DoxyCodeLine{2002     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \{}
\DoxyCodeLine{2003         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}}(    std::string \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{2004                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2005                         ResultWas::OfType \_type );}
\DoxyCodeLine{2006 }
\DoxyCodeLine{2007         std::string macroName;}
\DoxyCodeLine{2008         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{2009         ResultWas::OfType type;}
\DoxyCodeLine{2010         std::string message;}
\DoxyCodeLine{2011         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sequence;}
\DoxyCodeLine{2012 }
\DoxyCodeLine{2013         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2014             \textcolor{keywordflow}{return} sequence == other.sequence;}
\DoxyCodeLine{2015         \}}
\DoxyCodeLine{2016         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2017             \textcolor{keywordflow}{return} sequence < other.sequence;}
\DoxyCodeLine{2018         \}}
\DoxyCodeLine{2019     \textcolor{keyword}{private}:}
\DoxyCodeLine{2020         \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} globalCount;}
\DoxyCodeLine{2021     \};}
\DoxyCodeLine{2022 }
\DoxyCodeLine{2023     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}} \{}
\DoxyCodeLine{2024         \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}}( std::string \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{2025                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{2026                         ResultWas::OfType type )}
\DoxyCodeLine{2027         : m\_info( macroName, lineInfo, type )}
\DoxyCodeLine{2028         \{\}}
\DoxyCodeLine{2029 }
\DoxyCodeLine{2030         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2031         \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2032             m\_stream << value;}
\DoxyCodeLine{2033             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2034         \}}
\DoxyCodeLine{2035 }
\DoxyCodeLine{2036         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} m\_info;}
\DoxyCodeLine{2037         std::ostringstream m\_stream;}
\DoxyCodeLine{2038     \};}
\DoxyCodeLine{2039 }
\DoxyCodeLine{2040     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}} \{}
\DoxyCodeLine{2041     \textcolor{keyword}{public}:}
\DoxyCodeLine{2042         \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}( \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}} \textcolor{keyword}{const}\& builder );}
\DoxyCodeLine{2043         \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}( \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2044         \mbox{\hyperlink{classCatch_1_1ScopedMessage}{\string~ScopedMessage}}();}
\DoxyCodeLine{2045 }
\DoxyCodeLine{2046         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} m\_info;}
\DoxyCodeLine{2047     \};}
\DoxyCodeLine{2048 }
\DoxyCodeLine{2049 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2050 }
\DoxyCodeLine{2051 \textcolor{comment}{// \#included from: catch\_interfaces\_capture.h}}
\DoxyCodeLine{2052 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_CAPTURE\_H\_INCLUDED}}
\DoxyCodeLine{2053 }
\DoxyCodeLine{2054 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2055 }
\DoxyCodeLine{2056 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2057 }
\DoxyCodeLine{2058     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{2059     \textcolor{keyword}{class }AssertionResult;}
\DoxyCodeLine{2060     \textcolor{keyword}{struct }AssertionInfo;}
\DoxyCodeLine{2061     \textcolor{keyword}{struct }SectionInfo;}
\DoxyCodeLine{2062     \textcolor{keyword}{struct }SectionEndInfo;}
\DoxyCodeLine{2063     \textcolor{keyword}{struct }MessageInfo;}
\DoxyCodeLine{2064     \textcolor{keyword}{class }ScopedMessageBuilder;}
\DoxyCodeLine{2065     \textcolor{keyword}{struct }Counts;}
\DoxyCodeLine{2066 }
\DoxyCodeLine{2067     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}} \{}
\DoxyCodeLine{2068 }
\DoxyCodeLine{2069         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IResultCapture}{\string~IResultCapture}}();}
\DoxyCodeLine{2070 }
\DoxyCodeLine{2071         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionEnded( \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}} \textcolor{keyword}{const}\& result ) = 0;}
\DoxyCodeLine{2072         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} sectionStarted(    \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \textcolor{keyword}{const}\& sectionInfo,}
\DoxyCodeLine{2073                                         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}}\& assertions ) = 0;}
\DoxyCodeLine{2074         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( \mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{2075         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEndedEarly( \mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{2076         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} pushScopedMessage( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2077         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} popScopedMessage( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2078 }
\DoxyCodeLine{2079         \textcolor{keyword}{virtual} std::string getCurrentTestName() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2080         \textcolor{keyword}{virtual} \textcolor{keyword}{const} \mbox{\hyperlink{classCatch_1_1AssertionResult}{AssertionResult}}* getLastResult() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2081 }
\DoxyCodeLine{2082         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} exceptionEarlyReported() = 0;}
\DoxyCodeLine{2083 }
\DoxyCodeLine{2084         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleFatalErrorCondition( std::string \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2085 }
\DoxyCodeLine{2086         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} lastAssertionPassed() = 0;}
\DoxyCodeLine{2087         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionPassed() = 0;}
\DoxyCodeLine{2088         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionRun() = 0;}
\DoxyCodeLine{2089     \};}
\DoxyCodeLine{2090 }
\DoxyCodeLine{2091     \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}\& getResultCapture();}
\DoxyCodeLine{2092 \}}
\DoxyCodeLine{2093 }
\DoxyCodeLine{2094 \textcolor{comment}{// \#included from: catch\_debugger.h}}
\DoxyCodeLine{2095 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_DEBUGGER\_H\_INCLUDED}}
\DoxyCodeLine{2096 }
\DoxyCodeLine{2097 \textcolor{comment}{// \#included from: catch\_platform.h}}
\DoxyCodeLine{2098 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_PLATFORM\_H\_INCLUDED}}
\DoxyCodeLine{2099 }
\DoxyCodeLine{2100 \textcolor{preprocessor}{\#if defined(\_\_MAC\_OS\_X\_VERSION\_MIN\_REQUIRED)}}
\DoxyCodeLine{2101 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{2102 \textcolor{preprocessor}{\#elif  defined(\_\_IPHONE\_OS\_VERSION\_MIN\_REQUIRED)}}
\DoxyCodeLine{2103 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_IPHONE}}
\DoxyCodeLine{2104 \textcolor{preprocessor}{\#elif defined(linux) || defined(\_\_linux) || defined(\_\_linux\_\_)}}
\DoxyCodeLine{2105 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_LINUX}}
\DoxyCodeLine{2106 \textcolor{preprocessor}{\#elif defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER)}}
\DoxyCodeLine{2107 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{2108 \textcolor{preprocessor}{\#  if !defined(NOMINMAX) \&\& !defined(CATCH\_CONFIG\_NO\_NOMINMAX)}}
\DoxyCodeLine{2109 \textcolor{preprocessor}{\#    define CATCH\_DEFINES\_NOMINMAX}}
\DoxyCodeLine{2110 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{2111 \textcolor{preprocessor}{\#  if !defined(WIN32\_LEAN\_AND\_MEAN) \&\& !defined(CATCH\_CONFIG\_NO\_WIN32\_LEAN\_AND\_MEAN)}}
\DoxyCodeLine{2112 \textcolor{preprocessor}{\#    define CATCH\_DEFINES\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{2113 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{2114 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2115 }
\DoxyCodeLine{2116 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2117 }
\DoxyCodeLine{2118 \textcolor{keyword}{namespace }Catch\{}
\DoxyCodeLine{2119 }
\DoxyCodeLine{2120     \textcolor{keywordtype}{bool} isDebuggerActive();}
\DoxyCodeLine{2121     \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text );}
\DoxyCodeLine{2122 \}}
\DoxyCodeLine{2123 }
\DoxyCodeLine{2124 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{2125 }
\DoxyCodeLine{2126     \textcolor{comment}{// The following code snippet based on:}}
\DoxyCodeLine{2127     \textcolor{comment}{// http://cocoawithlove.com/2008/03/break-\/into-\/debugger.html}}
\DoxyCodeLine{2128 \textcolor{preprocessor}{    \#if defined(\_\_ppc64\_\_) || defined(\_\_ppc\_\_)}}
\DoxyCodeLine{2129 \textcolor{preprocessor}{        \#define CATCH\_TRAP() \(\backslash\)}}
\DoxyCodeLine{2130 \textcolor{preprocessor}{                \_\_asm\_\_("{}li r0, 20\(\backslash\)nsc\(\backslash\)nnop\(\backslash\)nli r0, 37\(\backslash\)nli r4, 2\(\backslash\)nsc\(\backslash\)nnop\(\backslash\)n"{}} \(\backslash\)}
\DoxyCodeLine{2131                 : : : "{}memory"{},"{}r0"{},"{}r3"{},"{}r4"{} ) \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{2132 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{2133 \textcolor{preprocessor}{        \#define CATCH\_TRAP() \_\_asm\_\_("{}int \$3\(\backslash\)n"{}} : : \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ )}}
\DoxyCodeLine{2134 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2135 }
\DoxyCodeLine{2136 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{2137     \textcolor{comment}{// If we can use inline assembler, do it because this allows us to break}}
\DoxyCodeLine{2138     \textcolor{comment}{// directly at the location of the failing check instead of breaking inside}}
\DoxyCodeLine{2139     \textcolor{comment}{// raise() called from it, i.e. one stack frame below.}}
\DoxyCodeLine{2140 \textcolor{preprocessor}{    \#if defined(\_\_GNUC\_\_) \&\& (defined(\_\_i386) || defined(\_\_x86\_64))}}
\DoxyCodeLine{2141 \textcolor{preprocessor}{        \#define CATCH\_TRAP() asm volatile ("{}int \$3"{}}) \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{2142 \textcolor{preprocessor}{    \#else }\textcolor{comment}{// Fall back to the generic way.}}
\DoxyCodeLine{2143 \textcolor{preprocessor}{        \#include <signal.h>}}
\DoxyCodeLine{2144 }
\DoxyCodeLine{2145 \textcolor{preprocessor}{        \#define CATCH\_TRAP() raise(SIGTRAP)}}
\DoxyCodeLine{2146 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2147 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{2148 \textcolor{preprocessor}{    \#define CATCH\_TRAP() \_\_debugbreak()}}
\DoxyCodeLine{2149 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{2150     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{void} \_\_stdcall DebugBreak();}
\DoxyCodeLine{2151 \textcolor{preprocessor}{    \#define CATCH\_TRAP() DebugBreak()}}
\DoxyCodeLine{2152 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2153 }
\DoxyCodeLine{2154 \textcolor{preprocessor}{\#ifdef CATCH\_TRAP}}
\DoxyCodeLine{2155 \textcolor{preprocessor}{    \#define CATCH\_BREAK\_INTO\_DEBUGGER() if( Catch::isDebuggerActive() ) \{ CATCH\_TRAP(); \}}}
\DoxyCodeLine{2156 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2157 \textcolor{preprocessor}{    \#define CATCH\_BREAK\_INTO\_DEBUGGER() Catch::alwaysTrue();}}
\DoxyCodeLine{2158 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2159 }
\DoxyCodeLine{2160 \textcolor{comment}{// \#included from: catch\_interfaces\_runner.h}}
\DoxyCodeLine{2161 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_RUNNER\_H\_INCLUDED}}
\DoxyCodeLine{2162 }
\DoxyCodeLine{2163 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2164     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{2165 }
\DoxyCodeLine{2166     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IRunner}{IRunner}} \{}
\DoxyCodeLine{2167         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IRunner}{\string~IRunner}}();}
\DoxyCodeLine{2168         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} aborting() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2169     \};}
\DoxyCodeLine{2170 \}}
\DoxyCodeLine{2171 }
\DoxyCodeLine{2172 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_STRINGIFICATION)}}
\DoxyCodeLine{2173 \textcolor{preprocessor}{\# define CATCH\_INTERNAL\_STRINGIFY(expr) \#expr}}
\DoxyCodeLine{2174 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2175 \textcolor{preprocessor}{\# define CATCH\_INTERNAL\_STRINGIFY(expr) "{}Disabled by CATCH\_CONFIG\_DISABLE\_STRINGIFICATION"{}}}
\DoxyCodeLine{2176 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2177 }
\DoxyCodeLine{2178 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE)}}
\DoxyCodeLine{2180 \textcolor{comment}{// We can speedup compilation significantly by breaking into debugger lower in}}
\DoxyCodeLine{2181 \textcolor{comment}{// the callstack, because then we don't have to expand CATCH\_BREAK\_INTO\_DEBUGGER}}
\DoxyCodeLine{2182 \textcolor{comment}{// macro in each assertion}}
\DoxyCodeLine{2183 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REACT( resultBuilder ) \(\backslash\)}}
\DoxyCodeLine{2184 \textcolor{preprocessor}{    resultBuilder.react();}}
\DoxyCodeLine{2185 }
\DoxyCodeLine{2187 \textcolor{comment}{// Another way to speed-\/up compilation is to omit local try-\/catch for REQUIRE*}}
\DoxyCodeLine{2188 \textcolor{comment}{// macros.}}
\DoxyCodeLine{2189 \textcolor{comment}{// This can potentially cause false negative, if the test code catches}}
\DoxyCodeLine{2190 \textcolor{comment}{// the exception before it propagates back up to the runner.}}
\DoxyCodeLine{2191 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEST\_NO\_TRY( macroName, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2192 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2193 \textcolor{preprocessor}{        Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2194 \textcolor{preprocessor}{        \_\_catchResult.setExceptionGuard(); \(\backslash\)}}
\DoxyCodeLine{2195 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2196 \textcolor{preprocessor}{        ( \_\_catchResult <= expr ).endExpression(); \(\backslash\)}}
\DoxyCodeLine{2197 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2198 \textcolor{preprocessor}{        \_\_catchResult.unsetExceptionGuard(); \(\backslash\)}}
\DoxyCodeLine{2199 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}}
\DoxyCodeLine{2200 \textcolor{preprocessor}{    \} while( Catch::isTrue( false \&\& static\_cast<bool>( !!(expr) ) ) ) }\textcolor{comment}{// expr here is never evaluated at runtime but it forces the compiler to give it a look}}
\DoxyCodeLine{2201 \textcolor{comment}{// The double negation silences MSVC's C4800 warning, the static\_cast forces short-\/circuit evaluation if the type has overloaded \&\&.}}
\DoxyCodeLine{2202 }
\DoxyCodeLine{2203 \textcolor{preprocessor}{\#define INTERNAL\_CHECK\_THAT\_NO\_TRY( macroName, matcher, resultDisposition, arg ) \(\backslash\)}}
\DoxyCodeLine{2204 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2205 \textcolor{preprocessor}{        Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(arg) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2206         \_\_catchResult.setExceptionGuard(); \(\backslash\)}
\DoxyCodeLine{2207         \_\_catchResult.captureMatch( arg, matcher, CATCH\_INTERNAL\_STRINGIFY(matcher) ); \(\backslash\)}
\DoxyCodeLine{2208         \_\_catchResult.unsetExceptionGuard(); \(\backslash\)}
\DoxyCodeLine{2209         INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}
\DoxyCodeLine{2210     \} while( Catch::alwaysFalse() )}
\DoxyCodeLine{2211 }
\DoxyCodeLine{2212 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2214 \textcolor{comment}{// In the event of a failure works out if the debugger needs to be invoked}}
\DoxyCodeLine{2215 \textcolor{comment}{// and/or an exception thrown and takes appropriate action.}}
\DoxyCodeLine{2216 \textcolor{comment}{// This needs to be done as a macro so the debugger will stop in the user}}
\DoxyCodeLine{2217 \textcolor{comment}{// source code rather than in Catch library code}}
\DoxyCodeLine{2218 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REACT( resultBuilder ) \(\backslash\)}}
\DoxyCodeLine{2219 \textcolor{preprocessor}{    if( resultBuilder.shouldDebugBreak() ) CATCH\_BREAK\_INTO\_DEBUGGER(); \(\backslash\)}}
\DoxyCodeLine{2220 \textcolor{preprocessor}{    resultBuilder.react();}}
\DoxyCodeLine{2221 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2222 }
\DoxyCodeLine{2224 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEST( macroName, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2225 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2226 \textcolor{preprocessor}{        Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2227 \textcolor{preprocessor}{        try \{ \(\backslash\)}}
\DoxyCodeLine{2228 \textcolor{preprocessor}{            CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2229 \textcolor{preprocessor}{            ( \_\_catchResult <= expr ).endExpression(); \(\backslash\)}}
\DoxyCodeLine{2230 \textcolor{preprocessor}{            CATCH\_INTERNAL\_UNSUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2231 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2232 \textcolor{preprocessor}{        catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2233 \textcolor{preprocessor}{            \_\_catchResult.useActiveException( resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2234 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2235 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}}
\DoxyCodeLine{2236 \textcolor{preprocessor}{    \} while( Catch::isTrue( false \&\& static\_cast<bool>( !!(expr) ) ) ) }\textcolor{comment}{// expr here is never evaluated at runtime but it forces the compiler to give it a look}}
\DoxyCodeLine{2237     \textcolor{comment}{// The double negation silences MSVC's C4800 warning, the static\_cast forces short-\/circuit evaluation if the type has overloaded \&\&.}}
\DoxyCodeLine{2238 }
\DoxyCodeLine{2240 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_IF( macroName, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2241 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, expr ); \(\backslash\)}}
\DoxyCodeLine{2242 \textcolor{preprocessor}{    if( Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{2243 }
\DoxyCodeLine{2245 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_ELSE( macroName, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2246 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, expr ); \(\backslash\)}}
\DoxyCodeLine{2247 \textcolor{preprocessor}{    if( !Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{2248 }
\DoxyCodeLine{2250 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NO\_THROW( macroName, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2251 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2252 \textcolor{preprocessor}{        Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2253 \textcolor{preprocessor}{        try \{ \(\backslash\)}}
\DoxyCodeLine{2254 \textcolor{preprocessor}{            static\_cast<void>(expr); \(\backslash\)}}
\DoxyCodeLine{2255 \textcolor{preprocessor}{            \_\_catchResult.captureResult( Catch::ResultWas::Ok ); \(\backslash\)}}
\DoxyCodeLine{2256 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2257 \textcolor{preprocessor}{        catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2258 \textcolor{preprocessor}{            \_\_catchResult.useActiveException( resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2259 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2260 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}}
\DoxyCodeLine{2261 \textcolor{preprocessor}{    \} while( Catch::alwaysFalse() )}}
\DoxyCodeLine{2262 }
\DoxyCodeLine{2264 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS( macroName, resultDisposition, matcher, expr ) \(\backslash\)}}
\DoxyCodeLine{2265 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2266 \textcolor{preprocessor}{        Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr), resultDisposition, CATCH\_INTERNAL\_STRINGIFY(matcher) ); \(\backslash\)}}
\DoxyCodeLine{2267 \textcolor{preprocessor}{        if( \_\_catchResult.allowThrows() ) \(\backslash\)}}
\DoxyCodeLine{2268 \textcolor{preprocessor}{            try \{ \(\backslash\)}}
\DoxyCodeLine{2269 \textcolor{preprocessor}{                static\_cast<void>(expr); \(\backslash\)}}
\DoxyCodeLine{2270 \textcolor{preprocessor}{                \_\_catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \(\backslash\)}}
\DoxyCodeLine{2271 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{2272 \textcolor{preprocessor}{            catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2273 \textcolor{preprocessor}{                \_\_catchResult.captureExpectedException( matcher ); \(\backslash\)}}
\DoxyCodeLine{2274 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{2275 \textcolor{preprocessor}{        else \(\backslash\)}}
\DoxyCodeLine{2276 \textcolor{preprocessor}{            \_\_catchResult.captureResult( Catch::ResultWas::Ok ); \(\backslash\)}}
\DoxyCodeLine{2277 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}}
\DoxyCodeLine{2278 \textcolor{preprocessor}{    \} while( Catch::alwaysFalse() )}}
\DoxyCodeLine{2279 }
\DoxyCodeLine{2281 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_AS( macroName, exceptionType, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2282 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2283 \textcolor{preprocessor}{        Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(exceptionType), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2284         if( \_\_catchResult.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{2285             try \{ \(\backslash\)}
\DoxyCodeLine{2286                 static\_cast<void>(expr); \(\backslash\)}
\DoxyCodeLine{2287                 \_\_catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \(\backslash\)}
\DoxyCodeLine{2288             \} \(\backslash\)}
\DoxyCodeLine{2289             catch( exceptionType ) \{ \(\backslash\)}
\DoxyCodeLine{2290                 \_\_catchResult.captureResult( Catch::ResultWas::Ok ); \(\backslash\)}
\DoxyCodeLine{2291             \} \(\backslash\)}
\DoxyCodeLine{2292             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{2293                 \_\_catchResult.useActiveException( resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2294             \} \(\backslash\)}
\DoxyCodeLine{2295         else \(\backslash\)}
\DoxyCodeLine{2296             \_\_catchResult.captureResult( Catch::ResultWas::Ok ); \(\backslash\)}
\DoxyCodeLine{2297         INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}
\DoxyCodeLine{2298     \} while( Catch::alwaysFalse() )}
\DoxyCodeLine{2299 }
\DoxyCodeLine{2301 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{2302 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_MSG( macroName, messageType, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2303 \textcolor{preprocessor}{        do \{ \(\backslash\)}}
\DoxyCodeLine{2304 \textcolor{preprocessor}{            Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, "{}"{}}, resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2305             \_\_catchResult << \_\_VA\_ARGS\_\_ + ::Catch::StreamEndStop(); \(\backslash\)}
\DoxyCodeLine{2306             \_\_catchResult.captureResult( messageType ); \(\backslash\)}
\DoxyCodeLine{2307             INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}
\DoxyCodeLine{2308         \} while( Catch::alwaysFalse() )}
\DoxyCodeLine{2309 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2310 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_MSG( macroName, messageType, resultDisposition, log ) \(\backslash\)}}
\DoxyCodeLine{2311 \textcolor{preprocessor}{        do \{ \(\backslash\)}}
\DoxyCodeLine{2312 \textcolor{preprocessor}{            Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, "{}"{}}, resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2313             \_\_catchResult << log + ::Catch::StreamEndStop(); \(\backslash\)}
\DoxyCodeLine{2314             \_\_catchResult.captureResult( messageType ); \(\backslash\)}
\DoxyCodeLine{2315             INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}
\DoxyCodeLine{2316         \} while( Catch::alwaysFalse() )}
\DoxyCodeLine{2317 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2318 }
\DoxyCodeLine{2320 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_INFO( macroName, log ) \(\backslash\)}}
\DoxyCodeLine{2321 \textcolor{preprocessor}{    Catch::ScopedMessage INTERNAL\_CATCH\_UNIQUE\_NAME( scopedMessage ) = Catch::MessageBuilder( macroName, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info ) << log;}}
\DoxyCodeLine{2322 }
\DoxyCodeLine{2324 \textcolor{preprocessor}{\#define INTERNAL\_CHECK\_THAT( macroName, matcher, resultDisposition, arg ) \(\backslash\)}}
\DoxyCodeLine{2325 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2326 \textcolor{preprocessor}{        Catch::ResultBuilder \_\_catchResult( macroName, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(arg) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2327         try \{ \(\backslash\)}
\DoxyCodeLine{2328             \_\_catchResult.captureMatch( arg, matcher, CATCH\_INTERNAL\_STRINGIFY(matcher) ); \(\backslash\)}
\DoxyCodeLine{2329         \} catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{2330             \_\_catchResult.useActiveException( resultDisposition | Catch::ResultDisposition::ContinueOnFailure ); \(\backslash\)}
\DoxyCodeLine{2331         \} \(\backslash\)}
\DoxyCodeLine{2332         INTERNAL\_CATCH\_REACT( \_\_catchResult ) \(\backslash\)}
\DoxyCodeLine{2333     \} while( Catch::alwaysFalse() )}
\DoxyCodeLine{2334 }
\DoxyCodeLine{2335 \textcolor{comment}{// \#included from: internal/catch\_section.h}}
\DoxyCodeLine{2336 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_SECTION\_H\_INCLUDED}}
\DoxyCodeLine{2337 }
\DoxyCodeLine{2338 \textcolor{comment}{// \#included from: catch\_section\_info.h}}
\DoxyCodeLine{2339 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_SECTION\_INFO\_H\_INCLUDED}}
\DoxyCodeLine{2340 }
\DoxyCodeLine{2341 \textcolor{comment}{// \#included from: catch\_totals.hpp}}
\DoxyCodeLine{2342 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TOTALS\_HPP\_INCLUDED}}
\DoxyCodeLine{2343 }
\DoxyCodeLine{2344 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{2345 }
\DoxyCodeLine{2346 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2347 }
\DoxyCodeLine{2348     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \{}
\DoxyCodeLine{2349         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}}() : passed( 0 ), failed( 0 ), failedButOk( 0 ) \{\}}
\DoxyCodeLine{2350 }
\DoxyCodeLine{2351         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} operator -\/ ( \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2352             \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} diff;}
\DoxyCodeLine{2353             diff.passed = passed -\/ other.passed;}
\DoxyCodeLine{2354             diff.failed = failed -\/ other.failed;}
\DoxyCodeLine{2355             diff.failedButOk = failedButOk -\/ other.failedButOk;}
\DoxyCodeLine{2356             \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{2357         \}}
\DoxyCodeLine{2358         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}}\& operator += ( \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{2359             passed += other.passed;}
\DoxyCodeLine{2360             failed += other.failed;}
\DoxyCodeLine{2361             failedButOk += other.failedButOk;}
\DoxyCodeLine{2362             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2363         \}}
\DoxyCodeLine{2364 }
\DoxyCodeLine{2365         std::size\_t total()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2366             \textcolor{keywordflow}{return} passed + failed + failedButOk;}
\DoxyCodeLine{2367         \}}
\DoxyCodeLine{2368         \textcolor{keywordtype}{bool} allPassed()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2369             \textcolor{keywordflow}{return} failed == 0 \&\& failedButOk == 0;}
\DoxyCodeLine{2370         \}}
\DoxyCodeLine{2371         \textcolor{keywordtype}{bool} allOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2372             \textcolor{keywordflow}{return} failed == 0;}
\DoxyCodeLine{2373         \}}
\DoxyCodeLine{2374 }
\DoxyCodeLine{2375         std::size\_t passed;}
\DoxyCodeLine{2376         std::size\_t failed;}
\DoxyCodeLine{2377         std::size\_t failedButOk;}
\DoxyCodeLine{2378     \};}
\DoxyCodeLine{2379 }
\DoxyCodeLine{2380     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \{}
\DoxyCodeLine{2381 }
\DoxyCodeLine{2382         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} operator -\/ ( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2383             \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} diff;}
\DoxyCodeLine{2384             diff.assertions = assertions -\/ other.assertions;}
\DoxyCodeLine{2385             diff.testCases = testCases -\/ other.testCases;}
\DoxyCodeLine{2386             \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{2387         \}}
\DoxyCodeLine{2388 }
\DoxyCodeLine{2389         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} delta( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& prevTotals )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2390             \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} diff = *\textcolor{keyword}{this} -\/ prevTotals;}
\DoxyCodeLine{2391             \textcolor{keywordflow}{if}( diff.assertions.failed > 0 )}
\DoxyCodeLine{2392                 ++diff.testCases.failed;}
\DoxyCodeLine{2393             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( diff.assertions.failedButOk > 0 )}
\DoxyCodeLine{2394                 ++diff.testCases.failedButOk;}
\DoxyCodeLine{2395             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2396                 ++diff.testCases.passed;}
\DoxyCodeLine{2397             \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{2398         \}}
\DoxyCodeLine{2399 }
\DoxyCodeLine{2400         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}}\& operator += ( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{2401             assertions += other.assertions;}
\DoxyCodeLine{2402             testCases += other.testCases;}
\DoxyCodeLine{2403             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2404         \}}
\DoxyCodeLine{2405 }
\DoxyCodeLine{2406         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} assertions;}
\DoxyCodeLine{2407         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} testCases;}
\DoxyCodeLine{2408     \};}
\DoxyCodeLine{2409 \}}
\DoxyCodeLine{2410 }
\DoxyCodeLine{2411 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2412 }
\DoxyCodeLine{2413 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2414 }
\DoxyCodeLine{2415     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \{}
\DoxyCodeLine{2416         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}}}
\DoxyCodeLine{2417             (   \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2418                 std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{2419                 std::string \textcolor{keyword}{const}\& \_description = std::string() );}
\DoxyCodeLine{2420 }
\DoxyCodeLine{2421         std::string name;}
\DoxyCodeLine{2422         std::string description;}
\DoxyCodeLine{2423         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{2424     \};}
\DoxyCodeLine{2425 }
\DoxyCodeLine{2426     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \{}
\DoxyCodeLine{2427         \mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}}( \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \textcolor{keyword}{const}\& \_sectionInfo, \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \textcolor{keyword}{const}\& \_prevAssertions, \textcolor{keywordtype}{double} \_durationInSeconds )}
\DoxyCodeLine{2428         : sectionInfo( \_sectionInfo ), prevAssertions( \_prevAssertions ), durationInSeconds( \_durationInSeconds )}
\DoxyCodeLine{2429         \{\}}
\DoxyCodeLine{2430 }
\DoxyCodeLine{2431         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} sectionInfo;}
\DoxyCodeLine{2432         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} prevAssertions;}
\DoxyCodeLine{2433         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{2434     \};}
\DoxyCodeLine{2435 }
\DoxyCodeLine{2436 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2437 }
\DoxyCodeLine{2438 \textcolor{comment}{// \#included from: catch\_timer.h}}
\DoxyCodeLine{2439 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TIMER\_H\_INCLUDED}}
\DoxyCodeLine{2440 }
\DoxyCodeLine{2441 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2442 }
\DoxyCodeLine{2443 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2444     \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} UInt64;}
\DoxyCodeLine{2445 \}}
\DoxyCodeLine{2446 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2447 \textcolor{preprocessor}{\#include <stdint.h>}}
\DoxyCodeLine{2448 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2449     \textcolor{keyword}{typedef} uint64\_t UInt64;}
\DoxyCodeLine{2450 \}}
\DoxyCodeLine{2451 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2452 }
\DoxyCodeLine{2453 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2454     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Timer}{Timer}} \{}
\DoxyCodeLine{2455     \textcolor{keyword}{public}:}
\DoxyCodeLine{2456         \mbox{\hyperlink{classCatch_1_1Timer}{Timer}}() : m\_ticks( 0 ) \{\}}
\DoxyCodeLine{2457         \textcolor{keywordtype}{void} start();}
\DoxyCodeLine{2458         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} getElapsedMicroseconds() \textcolor{keyword}{const};}
\DoxyCodeLine{2459         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} getElapsedMilliseconds() \textcolor{keyword}{const};}
\DoxyCodeLine{2460         \textcolor{keywordtype}{double} getElapsedSeconds() \textcolor{keyword}{const};}
\DoxyCodeLine{2461 }
\DoxyCodeLine{2462     \textcolor{keyword}{private}:}
\DoxyCodeLine{2463         UInt64 m\_ticks;}
\DoxyCodeLine{2464     \};}
\DoxyCodeLine{2465 }
\DoxyCodeLine{2466 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2467 }
\DoxyCodeLine{2468 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2469 }
\DoxyCodeLine{2470 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2471 }
\DoxyCodeLine{2472     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Section}{Section}} : \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{2473     \textcolor{keyword}{public}:}
\DoxyCodeLine{2474         \mbox{\hyperlink{classCatch_1_1Section}{Section}}( \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{2475         \mbox{\hyperlink{classCatch_1_1Section}{\string~Section}}();}
\DoxyCodeLine{2476 }
\DoxyCodeLine{2477         \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{2478         \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{2479 }
\DoxyCodeLine{2480     \textcolor{keyword}{private}:}
\DoxyCodeLine{2481         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} m\_info;}
\DoxyCodeLine{2482 }
\DoxyCodeLine{2483         std::string m\_name;}
\DoxyCodeLine{2484         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} m\_assertions;}
\DoxyCodeLine{2485         \textcolor{keywordtype}{bool} m\_sectionIncluded;}
\DoxyCodeLine{2486         \mbox{\hyperlink{classCatch_1_1Timer}{Timer}} m\_timer;}
\DoxyCodeLine{2487     \};}
\DoxyCodeLine{2488 }
\DoxyCodeLine{2489 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2490 }
\DoxyCodeLine{2491 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{2492 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{2493 \textcolor{preprocessor}{        if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{2494 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2495 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_SECTION( name, desc ) \(\backslash\)}}
\DoxyCodeLine{2496 \textcolor{preprocessor}{        if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, name, desc ) )}}
\DoxyCodeLine{2497 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2498 }
\DoxyCodeLine{2499 \textcolor{comment}{// \#included from: internal/catch\_generators.hpp}}
\DoxyCodeLine{2500 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_GENERATORS\_HPP\_INCLUDED}}
\DoxyCodeLine{2501 }
\DoxyCodeLine{2502 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{2503 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2504 \textcolor{preprocessor}{\#include <stdlib.h>}}
\DoxyCodeLine{2505 }
\DoxyCodeLine{2506 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2507 }
\DoxyCodeLine{2508 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2509 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IGenerator}{IGenerator}} \{}
\DoxyCodeLine{2510     \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IGenerator}{\string~IGenerator}}() \{\}}
\DoxyCodeLine{2511     \textcolor{keyword}{virtual} T getValue( std::size\_t index ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2512     \textcolor{keyword}{virtual} std::size\_t size () \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2513 \};}
\DoxyCodeLine{2514 }
\DoxyCodeLine{2515 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2516 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1BetweenGenerator}{BetweenGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{2517 \textcolor{keyword}{public}:}
\DoxyCodeLine{2518     \mbox{\hyperlink{classCatch_1_1BetweenGenerator}{BetweenGenerator}}( T from, T to ) : m\_from( from ), m\_to( to )\{\}}
\DoxyCodeLine{2519 }
\DoxyCodeLine{2520     \textcolor{keyword}{virtual} T getValue( std::size\_t index )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2521         \textcolor{keywordflow}{return} m\_from+\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( index );}
\DoxyCodeLine{2522     \}}
\DoxyCodeLine{2523 }
\DoxyCodeLine{2524     \textcolor{keyword}{virtual} std::size\_t size()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2525         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}( 1+m\_to-\/m\_from );}
\DoxyCodeLine{2526     \}}
\DoxyCodeLine{2527 }
\DoxyCodeLine{2528 \textcolor{keyword}{private}:}
\DoxyCodeLine{2529 }
\DoxyCodeLine{2530     T m\_from;}
\DoxyCodeLine{2531     T m\_to;}
\DoxyCodeLine{2532 \};}
\DoxyCodeLine{2533 }
\DoxyCodeLine{2534 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2535 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ValuesGenerator}{ValuesGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{2536 \textcolor{keyword}{public}:}
\DoxyCodeLine{2537     \mbox{\hyperlink{classCatch_1_1ValuesGenerator}{ValuesGenerator}}()\{\}}
\DoxyCodeLine{2538 }
\DoxyCodeLine{2539     \textcolor{keywordtype}{void} add( T value ) \{}
\DoxyCodeLine{2540         m\_values.push\_back( value );}
\DoxyCodeLine{2541     \}}
\DoxyCodeLine{2542 }
\DoxyCodeLine{2543     \textcolor{keyword}{virtual} T getValue( std::size\_t index )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2544         \textcolor{keywordflow}{return} m\_values[index];}
\DoxyCodeLine{2545     \}}
\DoxyCodeLine{2546 }
\DoxyCodeLine{2547     \textcolor{keyword}{virtual} std::size\_t size()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2548         \textcolor{keywordflow}{return} m\_values.size();}
\DoxyCodeLine{2549     \}}
\DoxyCodeLine{2550 }
\DoxyCodeLine{2551 \textcolor{keyword}{private}:}
\DoxyCodeLine{2552     std::vector<T> m\_values;}
\DoxyCodeLine{2553 \};}
\DoxyCodeLine{2554 }
\DoxyCodeLine{2555 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2556 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}} \{}
\DoxyCodeLine{2557 \textcolor{keyword}{public}:}
\DoxyCodeLine{2558     \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}}() : m\_totalSize( 0 ) \{\}}
\DoxyCodeLine{2559 }
\DoxyCodeLine{2560     \textcolor{comment}{// *** Move semantics, similar to auto\_ptr ***}}
\DoxyCodeLine{2561     \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}}( \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}}\& other )}
\DoxyCodeLine{2562     :   m\_fileInfo( other.m\_fileInfo ),}
\DoxyCodeLine{2563         m\_totalSize( 0 )}
\DoxyCodeLine{2564     \{}
\DoxyCodeLine{2565         move( other );}
\DoxyCodeLine{2566     \}}
\DoxyCodeLine{2567 }
\DoxyCodeLine{2568     \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}}\& setFileInfo( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* fileInfo ) \{}
\DoxyCodeLine{2569         m\_fileInfo = fileInfo;}
\DoxyCodeLine{2570         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2571     \}}
\DoxyCodeLine{2572 }
\DoxyCodeLine{2573     \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{\string~CompositeGenerator}}() \{}
\DoxyCodeLine{2574         deleteAll( m\_composed );}
\DoxyCodeLine{2575     \}}
\DoxyCodeLine{2576 }
\DoxyCodeLine{2577     \textcolor{keyword}{operator} T ()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2578         \textcolor{keywordtype}{size\_t} overallIndex = getCurrentContext().getGeneratorIndex( m\_fileInfo, m\_totalSize );}
\DoxyCodeLine{2579 }
\DoxyCodeLine{2580         \textcolor{keyword}{typename} std::vector<const IGenerator<T>*>::const\_iterator it = m\_composed.begin();}
\DoxyCodeLine{2581         \textcolor{keyword}{typename} std::vector<const IGenerator<T>*>::const\_iterator itEnd = m\_composed.end();}
\DoxyCodeLine{2582         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} index = 0; it != itEnd; ++it )}
\DoxyCodeLine{2583         \{}
\DoxyCodeLine{2584             \textcolor{keyword}{const} \mbox{\hyperlink{structCatch_1_1IGenerator}{IGenerator<T>}}* generator = *it;}
\DoxyCodeLine{2585             \textcolor{keywordflow}{if}( overallIndex >= index \&\& overallIndex < index + generator-\/>size() )}
\DoxyCodeLine{2586             \{}
\DoxyCodeLine{2587                 \textcolor{keywordflow}{return} generator-\/>getValue( overallIndex-\/index );}
\DoxyCodeLine{2588             \}}
\DoxyCodeLine{2589             index += generator-\/>size();}
\DoxyCodeLine{2590         \}}
\DoxyCodeLine{2591         CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Indexed past end of generated range"{}} );}
\DoxyCodeLine{2592         \textcolor{keywordflow}{return} T(); \textcolor{comment}{// Suppress spurious "{}not all control paths return a value"{} warning in Visual Studio -\/ if you know how to fix this please do so}}
\DoxyCodeLine{2593     \}}
\DoxyCodeLine{2594 }
\DoxyCodeLine{2595     \textcolor{keywordtype}{void} add( \textcolor{keyword}{const} \mbox{\hyperlink{structCatch_1_1IGenerator}{IGenerator<T>}}* generator ) \{}
\DoxyCodeLine{2596         m\_totalSize += generator-\/>size();}
\DoxyCodeLine{2597         m\_composed.push\_back( generator );}
\DoxyCodeLine{2598     \}}
\DoxyCodeLine{2599 }
\DoxyCodeLine{2600     \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}}\& then( \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}}\& other ) \{}
\DoxyCodeLine{2601         move( other );}
\DoxyCodeLine{2602         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2603     \}}
\DoxyCodeLine{2604 }
\DoxyCodeLine{2605     \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}}\& then( T value ) \{}
\DoxyCodeLine{2606         \mbox{\hyperlink{classCatch_1_1ValuesGenerator}{ValuesGenerator<T>}}* valuesGen = \textcolor{keyword}{new} \mbox{\hyperlink{classCatch_1_1ValuesGenerator}{ValuesGenerator<T>}}();}
\DoxyCodeLine{2607         valuesGen-\/>add( value );}
\DoxyCodeLine{2608         add( valuesGen );}
\DoxyCodeLine{2609         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2610     \}}
\DoxyCodeLine{2611 }
\DoxyCodeLine{2612 \textcolor{keyword}{private}:}
\DoxyCodeLine{2613 }
\DoxyCodeLine{2614     \textcolor{keywordtype}{void} move( \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator}}\& other ) \{}
\DoxyCodeLine{2615         m\_composed.insert( m\_composed.end(), other.m\_composed.begin(), other.m\_composed.end() );}
\DoxyCodeLine{2616         m\_totalSize += other.m\_totalSize;}
\DoxyCodeLine{2617         other.m\_composed.clear();}
\DoxyCodeLine{2618     \}}
\DoxyCodeLine{2619 }
\DoxyCodeLine{2620     std::vector<const IGenerator<T>*> m\_composed;}
\DoxyCodeLine{2621     std::string m\_fileInfo;}
\DoxyCodeLine{2622     \textcolor{keywordtype}{size\_t} m\_totalSize;}
\DoxyCodeLine{2623 \};}
\DoxyCodeLine{2624 }
\DoxyCodeLine{2625 \textcolor{keyword}{namespace }Generators}
\DoxyCodeLine{2626 \{}
\DoxyCodeLine{2627     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2628     \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator<T>}} between( T from, T to ) \{}
\DoxyCodeLine{2629         \mbox{\hyperlink{classCatch_1_1CompositeGenerator}{CompositeGenerator<T>}} generators;}
\DoxyCodeLine{2630         generators.add( \textcolor{keyword}{new} \mbox{\hyperlink{classCatch_1_1BetweenGenerator}{BetweenGenerator<T>}}( from, to ) );}
\DoxyCodeLine{2631         \textcolor{keywordflow}{return} generators;}
\DoxyCodeLine{2632     \}}
\DoxyCodeLine{2633 }
\DoxyCodeLine{2634     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2635     CompositeGenerator<T> values( T val1, T val2 ) \{}
\DoxyCodeLine{2636         CompositeGenerator<T> generators;}
\DoxyCodeLine{2637         ValuesGenerator<T>* valuesGen = \textcolor{keyword}{new} ValuesGenerator<T>();}
\DoxyCodeLine{2638         valuesGen-\/>add( val1 );}
\DoxyCodeLine{2639         valuesGen-\/>add( val2 );}
\DoxyCodeLine{2640         generators.add( valuesGen );}
\DoxyCodeLine{2641         \textcolor{keywordflow}{return} generators;}
\DoxyCodeLine{2642     \}}
\DoxyCodeLine{2643 }
\DoxyCodeLine{2644     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2645     CompositeGenerator<T> values( T val1, T val2, T val3 )\{}
\DoxyCodeLine{2646         CompositeGenerator<T> generators;}
\DoxyCodeLine{2647         ValuesGenerator<T>* valuesGen = \textcolor{keyword}{new} ValuesGenerator<T>();}
\DoxyCodeLine{2648         valuesGen-\/>add( val1 );}
\DoxyCodeLine{2649         valuesGen-\/>add( val2 );}
\DoxyCodeLine{2650         valuesGen-\/>add( val3 );}
\DoxyCodeLine{2651         generators.add( valuesGen );}
\DoxyCodeLine{2652         \textcolor{keywordflow}{return} generators;}
\DoxyCodeLine{2653     \}}
\DoxyCodeLine{2654 }
\DoxyCodeLine{2655     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2656     CompositeGenerator<T> values( T val1, T val2, T val3, T val4 ) \{}
\DoxyCodeLine{2657         CompositeGenerator<T> generators;}
\DoxyCodeLine{2658         ValuesGenerator<T>* valuesGen = \textcolor{keyword}{new} ValuesGenerator<T>();}
\DoxyCodeLine{2659         valuesGen-\/>add( val1 );}
\DoxyCodeLine{2660         valuesGen-\/>add( val2 );}
\DoxyCodeLine{2661         valuesGen-\/>add( val3 );}
\DoxyCodeLine{2662         valuesGen-\/>add( val4 );}
\DoxyCodeLine{2663         generators.add( valuesGen );}
\DoxyCodeLine{2664         \textcolor{keywordflow}{return} generators;}
\DoxyCodeLine{2665     \}}
\DoxyCodeLine{2666 }
\DoxyCodeLine{2667 \} \textcolor{comment}{// end namespace Generators}}
\DoxyCodeLine{2668 }
\DoxyCodeLine{2669 \textcolor{keyword}{using namespace }Generators;}
\DoxyCodeLine{2670 }
\DoxyCodeLine{2671 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2672 }
\DoxyCodeLine{2673 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_LINESTR2( line ) \#line}}
\DoxyCodeLine{2674 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_LINESTR( line ) INTERNAL\_CATCH\_LINESTR2( line )}}
\DoxyCodeLine{2675 }
\DoxyCodeLine{2676 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_GENERATE( expr ) expr.setFileInfo( \_\_FILE\_\_ "{}("{}} INTERNAL\_CATCH\_LINESTR( \_\_LINE\_\_ ) "{})"{} )}
\DoxyCodeLine{2677 }
\DoxyCodeLine{2678 \textcolor{comment}{// \#included from: internal/catch\_interfaces\_exception.h}}
\DoxyCodeLine{2679 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_EXCEPTION\_H\_INCLUDED}}
\DoxyCodeLine{2680 }
\DoxyCodeLine{2681 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2682 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{2683 }
\DoxyCodeLine{2684 \textcolor{comment}{// \#included from: catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{2685 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_REGISTRY\_HUB\_H\_INCLUDED}}
\DoxyCodeLine{2686 }
\DoxyCodeLine{2687 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2688 }
\DoxyCodeLine{2689 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2690 }
\DoxyCodeLine{2691     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{2692     \textcolor{keyword}{struct }ITestCaseRegistry;}
\DoxyCodeLine{2693     \textcolor{keyword}{struct }IExceptionTranslatorRegistry;}
\DoxyCodeLine{2694     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{2695     \textcolor{keyword}{struct }IReporterRegistry;}
\DoxyCodeLine{2696     \textcolor{keyword}{struct }IReporterFactory;}
\DoxyCodeLine{2697     \textcolor{keyword}{struct }ITagAliasRegistry;}
\DoxyCodeLine{2698 }
\DoxyCodeLine{2699     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IRegistryHub}{IRegistryHub}} \{}
\DoxyCodeLine{2700         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IRegistryHub}{\string~IRegistryHub}}();}
\DoxyCodeLine{2701 }
\DoxyCodeLine{2702         \textcolor{keyword}{virtual} IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2703         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{ITestCaseRegistry}} \textcolor{keyword}{const}\& getTestCaseRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2704         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITagAliasRegistry}{ITagAliasRegistry}} \textcolor{keyword}{const}\& getTagAliasRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2705 }
\DoxyCodeLine{2706         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{IExceptionTranslatorRegistry}}\& getExceptionTranslatorRegistry() = 0;}
\DoxyCodeLine{2707     \};}
\DoxyCodeLine{2708 }
\DoxyCodeLine{2709     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{IMutableRegistryHub}} \{}
\DoxyCodeLine{2710         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{\string~IMutableRegistryHub}}();}
\DoxyCodeLine{2711         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr<IReporterFactory>}} \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{2712         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerListener( \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr<IReporterFactory>}} \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{2713         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{2714         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} \mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}}* translator ) = 0;}
\DoxyCodeLine{2715         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) = 0;}
\DoxyCodeLine{2716     \};}
\DoxyCodeLine{2717 }
\DoxyCodeLine{2718     \mbox{\hyperlink{structCatch_1_1IRegistryHub}{IRegistryHub}}\& getRegistryHub();}
\DoxyCodeLine{2719     \mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{IMutableRegistryHub}}\& getMutableRegistryHub();}
\DoxyCodeLine{2720     \textcolor{keywordtype}{void} cleanUp();}
\DoxyCodeLine{2721     std::string translateActiveException();}
\DoxyCodeLine{2722 }
\DoxyCodeLine{2723 \}}
\DoxyCodeLine{2724 }
\DoxyCodeLine{2725 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2726 }
\DoxyCodeLine{2727     \textcolor{keyword}{typedef} std::string(*exceptionTranslateFunction)();}
\DoxyCodeLine{2728 }
\DoxyCodeLine{2729     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{2730     \textcolor{keyword}{typedef} std::vector<const IExceptionTranslator*> ExceptionTranslators;}
\DoxyCodeLine{2731 }
\DoxyCodeLine{2732     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}} \{}
\DoxyCodeLine{2733         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{\string~IExceptionTranslator}}();}
\DoxyCodeLine{2734         \textcolor{keyword}{virtual} std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2735     \};}
\DoxyCodeLine{2736 }
\DoxyCodeLine{2737     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{IExceptionTranslatorRegistry}} \{}
\DoxyCodeLine{2738         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{\string~IExceptionTranslatorRegistry}}();}
\DoxyCodeLine{2739 }
\DoxyCodeLine{2740         \textcolor{keyword}{virtual} std::string translateActiveException() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2741     \};}
\DoxyCodeLine{2742 }
\DoxyCodeLine{2743     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar}{ExceptionTranslatorRegistrar}} \{}
\DoxyCodeLine{2744         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2745         \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar_1_1ExceptionTranslator}{ExceptionTranslator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}} \{}
\DoxyCodeLine{2746         \textcolor{keyword}{public}:}
\DoxyCodeLine{2747 }
\DoxyCodeLine{2748             \mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar_1_1ExceptionTranslator}{ExceptionTranslator}}( std::string(*translateFunction)( T\& ) )}
\DoxyCodeLine{2749             : m\_translateFunction( translateFunction )}
\DoxyCodeLine{2750             \{\}}
\DoxyCodeLine{2751 }
\DoxyCodeLine{2752             \textcolor{keyword}{virtual} std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{2753                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{2754                     \textcolor{keywordflow}{if}( it == itEnd )}
\DoxyCodeLine{2755                         \textcolor{keywordflow}{throw};}
\DoxyCodeLine{2756                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2757                         \textcolor{keywordflow}{return} (*it)-\/>translate( it+1, itEnd );}
\DoxyCodeLine{2758                 \}}
\DoxyCodeLine{2759                 \textcolor{keywordflow}{catch}( T\& ex ) \{}
\DoxyCodeLine{2760                     \textcolor{keywordflow}{return} m\_translateFunction( ex );}
\DoxyCodeLine{2761                 \}}
\DoxyCodeLine{2762             \}}
\DoxyCodeLine{2763 }
\DoxyCodeLine{2764         \textcolor{keyword}{protected}:}
\DoxyCodeLine{2765             std::string(*m\_translateFunction)( T\& );}
\DoxyCodeLine{2766         \};}
\DoxyCodeLine{2767 }
\DoxyCodeLine{2768     \textcolor{keyword}{public}:}
\DoxyCodeLine{2769         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2770         \mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar}{ExceptionTranslatorRegistrar}}( std::string(*translateFunction)( T\& ) ) \{}
\DoxyCodeLine{2771             getMutableRegistryHub().registerTranslator}
\DoxyCodeLine{2772                 ( \textcolor{keyword}{new} \mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar_1_1ExceptionTranslator}{ExceptionTranslator<T>}}( translateFunction ) );}
\DoxyCodeLine{2773         \}}
\DoxyCodeLine{2774     \};}
\DoxyCodeLine{2775 \}}
\DoxyCodeLine{2776 }
\DoxyCodeLine{2778 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( translatorName, signature ) \(\backslash\)}}
\DoxyCodeLine{2779 \textcolor{preprocessor}{    static std::string translatorName( signature ); \(\backslash\)}}
\DoxyCodeLine{2780 \textcolor{preprocessor}{    namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionRegistrar )( \&translatorName ); \}\(\backslash\)}}
\DoxyCodeLine{2781 \textcolor{preprocessor}{    static std::string translatorName( signature )}}
\DoxyCodeLine{2782 }
\DoxyCodeLine{2783 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{2784 }
\DoxyCodeLine{2785 \textcolor{comment}{// \#included from: internal/catch\_approx.hpp}}
\DoxyCodeLine{2786 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_APPROX\_HPP\_INCLUDED}}
\DoxyCodeLine{2787 }
\DoxyCodeLine{2788 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{2789 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{2790 }
\DoxyCodeLine{2791 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_TYPE\_TRAITS)}}
\DoxyCodeLine{2792 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{2793 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2794 }
\DoxyCodeLine{2795 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2796 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{2797 }
\DoxyCodeLine{2798     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \{}
\DoxyCodeLine{2799     \textcolor{keyword}{public}:}
\DoxyCodeLine{2800         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} ( \textcolor{keywordtype}{double} value )}
\DoxyCodeLine{2801         :   m\_epsilon( std::numeric\_limits<float>::epsilon()*100 ),}
\DoxyCodeLine{2802             m\_margin( 0.0 ),}
\DoxyCodeLine{2803             m\_scale( 1.0 ),}
\DoxyCodeLine{2804             m\_value( value )}
\DoxyCodeLine{2805         \{\}}
\DoxyCodeLine{2806 }
\DoxyCodeLine{2807         \textcolor{keyword}{static} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} custom() \{}
\DoxyCodeLine{2808             \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}( 0 );}
\DoxyCodeLine{2809         \}}
\DoxyCodeLine{2810 }
\DoxyCodeLine{2811 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_TYPE\_TRAITS)}}
\DoxyCodeLine{2812 }
\DoxyCodeLine{2813         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2814         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} operator()( T value ) \{}
\DoxyCodeLine{2815             \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} approx( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value) );}
\DoxyCodeLine{2816             approx.epsilon( m\_epsilon );}
\DoxyCodeLine{2817             approx.margin( m\_margin );}
\DoxyCodeLine{2818             approx.scale( m\_scale );}
\DoxyCodeLine{2819             \textcolor{keywordflow}{return} approx;}
\DoxyCodeLine{2820         \}}
\DoxyCodeLine{2821 }
\DoxyCodeLine{2822         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2823         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}( T value ): \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value))}
\DoxyCodeLine{2824         \{\}}
\DoxyCodeLine{2825 }
\DoxyCodeLine{2826         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2827         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \textcolor{keyword}{const} T\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{2828             \textcolor{comment}{// Thanks to Richard Harris for his help refining this formula}}
\DoxyCodeLine{2829             \textcolor{keyword}{auto} lhs\_v = double(lhs);}
\DoxyCodeLine{2830             \textcolor{keywordtype}{bool} relativeOK = std::fabs(lhs\_v -\/ rhs.m\_value) < rhs.m\_epsilon * (rhs.m\_scale + (std::max)(std::fabs(lhs\_v), std::fabs(rhs.m\_value)));}
\DoxyCodeLine{2831             \textcolor{keywordflow}{if} (relativeOK) \{}
\DoxyCodeLine{2832                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2833             \}}
\DoxyCodeLine{2834 }
\DoxyCodeLine{2835             \textcolor{keywordflow}{return} std::fabs(lhs\_v -\/ rhs.m\_value) <= rhs.m\_margin;}
\DoxyCodeLine{2836         \}}
\DoxyCodeLine{2837 }
\DoxyCodeLine{2838         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2839         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keyword}{const} T\& rhs ) \{}
\DoxyCodeLine{2840             \textcolor{keywordflow}{return} operator==( rhs, lhs );}
\DoxyCodeLine{2841         \}}
\DoxyCodeLine{2842 }
\DoxyCodeLine{2843         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2844         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( T lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{2845             \textcolor{keywordflow}{return} !operator==( lhs, rhs );}
\DoxyCodeLine{2846         \}}
\DoxyCodeLine{2847 }
\DoxyCodeLine{2848         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2849         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T rhs ) \{}
\DoxyCodeLine{2850             \textcolor{keywordflow}{return} !operator==( rhs, lhs );}
\DoxyCodeLine{2851         \}}
\DoxyCodeLine{2852 }
\DoxyCodeLine{2853         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2854         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( T lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{2855             \textcolor{keywordflow}{return} double(lhs) < rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{2856         \}}
\DoxyCodeLine{2857 }
\DoxyCodeLine{2858         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2859         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T rhs ) \{}
\DoxyCodeLine{2860             \textcolor{keywordflow}{return} lhs.m\_value < double(rhs) || lhs == rhs;}
\DoxyCodeLine{2861         \}}
\DoxyCodeLine{2862 }
\DoxyCodeLine{2863         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2864         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( T lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{2865             \textcolor{keywordflow}{return} double(lhs) > rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{2866         \}}
\DoxyCodeLine{2867 }
\DoxyCodeLine{2868         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2869         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T rhs ) \{}
\DoxyCodeLine{2870             \textcolor{keywordflow}{return} lhs.m\_value > double(rhs) || lhs == rhs;}
\DoxyCodeLine{2871         \}}
\DoxyCodeLine{2872 }
\DoxyCodeLine{2873         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2874         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& epsilon( T newEpsilon ) \{}
\DoxyCodeLine{2875             m\_epsilon = double(newEpsilon);}
\DoxyCodeLine{2876             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2877         \}}
\DoxyCodeLine{2878 }
\DoxyCodeLine{2879         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2880         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& margin( T newMargin ) \{}
\DoxyCodeLine{2881             m\_margin = double(newMargin);}
\DoxyCodeLine{2882             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2883         \}}
\DoxyCodeLine{2884 }
\DoxyCodeLine{2885         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{2886         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& scale( T newScale ) \{}
\DoxyCodeLine{2887             m\_scale = double(newScale);}
\DoxyCodeLine{2888             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2889         \}}
\DoxyCodeLine{2890 }
\DoxyCodeLine{2891 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2892 }
\DoxyCodeLine{2893         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} operator()( \textcolor{keywordtype}{double} value ) \{}
\DoxyCodeLine{2894             \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} approx( value );}
\DoxyCodeLine{2895             approx.epsilon( m\_epsilon );}
\DoxyCodeLine{2896             approx.margin( m\_margin );}
\DoxyCodeLine{2897             approx.scale( m\_scale );}
\DoxyCodeLine{2898             \textcolor{keywordflow}{return} approx;}
\DoxyCodeLine{2899         \}}
\DoxyCodeLine{2900 }
\DoxyCodeLine{2901         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \textcolor{keywordtype}{double} lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{2902             \textcolor{comment}{// Thanks to Richard Harris for his help refining this formula}}
\DoxyCodeLine{2903             \textcolor{keywordtype}{bool} relativeOK = std::fabs( lhs -\/ rhs.m\_value ) < rhs.m\_epsilon * (rhs.m\_scale + (std::max)( std::fabs(lhs), std::fabs(rhs.m\_value) ) );}
\DoxyCodeLine{2904             \textcolor{keywordflow}{if} (relativeOK) \{}
\DoxyCodeLine{2905                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2906             \}}
\DoxyCodeLine{2907             \textcolor{keywordflow}{return} std::fabs(lhs -\/ rhs.m\_value) <= rhs.m\_margin;}
\DoxyCodeLine{2908         \}}
\DoxyCodeLine{2909 }
\DoxyCodeLine{2910         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{double} rhs ) \{}
\DoxyCodeLine{2911             \textcolor{keywordflow}{return} operator==( rhs, lhs );}
\DoxyCodeLine{2912         \}}
\DoxyCodeLine{2913 }
\DoxyCodeLine{2914         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( \textcolor{keywordtype}{double} lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{2915             \textcolor{keywordflow}{return} !operator==( lhs, rhs );}
\DoxyCodeLine{2916         \}}
\DoxyCodeLine{2917 }
\DoxyCodeLine{2918         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{double} rhs ) \{}
\DoxyCodeLine{2919             \textcolor{keywordflow}{return} !operator==( rhs, lhs );}
\DoxyCodeLine{2920         \}}
\DoxyCodeLine{2921 }
\DoxyCodeLine{2922         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( \textcolor{keywordtype}{double} lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{2923             \textcolor{keywordflow}{return} lhs < rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{2924         \}}
\DoxyCodeLine{2925 }
\DoxyCodeLine{2926         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{double} rhs ) \{}
\DoxyCodeLine{2927             \textcolor{keywordflow}{return} lhs.m\_value < rhs || lhs == rhs;}
\DoxyCodeLine{2928         \}}
\DoxyCodeLine{2929 }
\DoxyCodeLine{2930         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( \textcolor{keywordtype}{double} lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{2931             \textcolor{keywordflow}{return} lhs > rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{2932         \}}
\DoxyCodeLine{2933 }
\DoxyCodeLine{2934         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{double} rhs ) \{}
\DoxyCodeLine{2935             \textcolor{keywordflow}{return} lhs.m\_value > rhs || lhs == rhs;}
\DoxyCodeLine{2936         \}}
\DoxyCodeLine{2937 }
\DoxyCodeLine{2938         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& epsilon( \textcolor{keywordtype}{double} newEpsilon ) \{}
\DoxyCodeLine{2939             m\_epsilon = newEpsilon;}
\DoxyCodeLine{2940             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2941         \}}
\DoxyCodeLine{2942 }
\DoxyCodeLine{2943         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& margin( \textcolor{keywordtype}{double} newMargin ) \{}
\DoxyCodeLine{2944             m\_margin = newMargin;}
\DoxyCodeLine{2945             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2946         \}}
\DoxyCodeLine{2947 }
\DoxyCodeLine{2948         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& scale( \textcolor{keywordtype}{double} newScale ) \{}
\DoxyCodeLine{2949             m\_scale = newScale;}
\DoxyCodeLine{2950             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2951         \}}
\DoxyCodeLine{2952 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2953 }
\DoxyCodeLine{2954         std::string toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2955             std::ostringstream oss;}
\DoxyCodeLine{2956             oss << \textcolor{stringliteral}{"{}Approx( "{}} << Catch::toString( m\_value ) << \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{2957             \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{2958         \}}
\DoxyCodeLine{2959 }
\DoxyCodeLine{2960     \textcolor{keyword}{private}:}
\DoxyCodeLine{2961         \textcolor{keywordtype}{double} m\_epsilon;}
\DoxyCodeLine{2962         \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{2963         \textcolor{keywordtype}{double} m\_scale;}
\DoxyCodeLine{2964         \textcolor{keywordtype}{double} m\_value;}
\DoxyCodeLine{2965     \};}
\DoxyCodeLine{2966 \}}
\DoxyCodeLine{2967 }
\DoxyCodeLine{2968 \textcolor{keyword}{template}<>}
\DoxyCodeLine{2969 \textcolor{keyword}{inline} std::string toString<Detail::Approx>( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Detail::Approx}} \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2970     \textcolor{keywordflow}{return} value.toString();}
\DoxyCodeLine{2971 \}}
\DoxyCodeLine{2972 }
\DoxyCodeLine{2973 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2974 }
\DoxyCodeLine{2975 \textcolor{comment}{// \#included from: internal/catch\_matchers\_string.h}}
\DoxyCodeLine{2976 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_MATCHERS\_STRING\_H\_INCLUDED}}
\DoxyCodeLine{2977 }
\DoxyCodeLine{2978 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2979 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{2980 }
\DoxyCodeLine{2981     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{2982 }
\DoxyCodeLine{2983         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}}}
\DoxyCodeLine{2984         \{}
\DoxyCodeLine{2985             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}}( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{2986             std::string adjustString( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{2987             std::string caseSensitivitySuffix() \textcolor{keyword}{const};}
\DoxyCodeLine{2988 }
\DoxyCodeLine{2989             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{2990             std::string m\_str;}
\DoxyCodeLine{2991         \};}
\DoxyCodeLine{2992 }
\DoxyCodeLine{2993         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{2994             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}}( std::string \textcolor{keyword}{const}\& operation, \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{2995             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} CATCH\_OVERRIDE;}
\DoxyCodeLine{2996 }
\DoxyCodeLine{2997             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} m\_comparator;}
\DoxyCodeLine{2998             std::string m\_operation;}
\DoxyCodeLine{2999         \};}
\DoxyCodeLine{3000 }
\DoxyCodeLine{3001         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{EqualsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{3002             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{EqualsMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3003             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const} CATCH\_OVERRIDE;}
\DoxyCodeLine{3004         \};}
\DoxyCodeLine{3005         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{ContainsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{3006             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{ContainsMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3007             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const} CATCH\_OVERRIDE;}
\DoxyCodeLine{3008         \};}
\DoxyCodeLine{3009         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StartsWithMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{3010             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StartsWithMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3011             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const} CATCH\_OVERRIDE;}
\DoxyCodeLine{3012         \};}
\DoxyCodeLine{3013         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{EndsWithMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{3014             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{EndsWithMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3015             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const} CATCH\_OVERRIDE;}
\DoxyCodeLine{3016         \};}
\DoxyCodeLine{3017 }
\DoxyCodeLine{3018     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{3019 }
\DoxyCodeLine{3020     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3021     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3022 }
\DoxyCodeLine{3023     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{StdString::EqualsMatcher}} Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3024     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{StdString::ContainsMatcher}} Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3025     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{StdString::EndsWithMatcher}} EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3026     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StdString::StartsWithMatcher}} StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3027 }
\DoxyCodeLine{3028 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3029 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3030 }
\DoxyCodeLine{3031 \textcolor{comment}{// \#included from: internal/catch\_matchers\_vector.h}}
\DoxyCodeLine{3032 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_MATCHERS\_VECTOR\_H\_INCLUDED}}
\DoxyCodeLine{3033 }
\DoxyCodeLine{3034 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3035 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3036 }
\DoxyCodeLine{3037     \textcolor{keyword}{namespace }Vector \{}
\DoxyCodeLine{3038 }
\DoxyCodeLine{3039         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3040         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{ContainsElementMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T>, T> \{}
\DoxyCodeLine{3041 }
\DoxyCodeLine{3042             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{ContainsElementMatcher}}(T \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator) \{\}}
\DoxyCodeLine{3043 }
\DoxyCodeLine{3044             \textcolor{keywordtype}{bool} match(std::vector<T> \textcolor{keyword}{const} \&v) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{3045                 \textcolor{keywordflow}{return} std::find(v.begin(), v.end(), m\_comparator) != v.end();}
\DoxyCodeLine{3046             \}}
\DoxyCodeLine{3047 }
\DoxyCodeLine{3048             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{3049                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Contains: "{}} + Catch::toString( m\_comparator );}
\DoxyCodeLine{3050             \}}
\DoxyCodeLine{3051 }
\DoxyCodeLine{3052             T \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3053         \};}
\DoxyCodeLine{3054 }
\DoxyCodeLine{3055         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3056         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{ContainsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T>, std::vector<T> > \{}
\DoxyCodeLine{3057 }
\DoxyCodeLine{3058             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{ContainsMatcher}}(std::vector<T> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3059 }
\DoxyCodeLine{3060             \textcolor{keywordtype}{bool} match(std::vector<T> \textcolor{keyword}{const} \&v) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{3061                 \textcolor{comment}{// !TBD: see note in EqualsMatcher}}
\DoxyCodeLine{3062                 \textcolor{keywordflow}{if} (m\_comparator.size() > v.size())}
\DoxyCodeLine{3063                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3064                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_comparator.size(); ++i)}
\DoxyCodeLine{3065                     \textcolor{keywordflow}{if} (std::find(v.begin(), v.end(), m\_comparator[i]) == v.end())}
\DoxyCodeLine{3066                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3067                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3068             \}}
\DoxyCodeLine{3069             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{3070                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Contains: "{}} + Catch::toString( m\_comparator );}
\DoxyCodeLine{3071             \}}
\DoxyCodeLine{3072 }
\DoxyCodeLine{3073             std::vector<T> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3074         \};}
\DoxyCodeLine{3075 }
\DoxyCodeLine{3076         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3077         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1EqualsMatcher}{EqualsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T>, std::vector<T> > \{}
\DoxyCodeLine{3078 }
\DoxyCodeLine{3079             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1EqualsMatcher}{EqualsMatcher}}(std::vector<T> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3080 }
\DoxyCodeLine{3081             \textcolor{keywordtype}{bool} match(std::vector<T> \textcolor{keyword}{const} \&v) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{3082                 \textcolor{comment}{// !TBD: This currently works if all elements can be compared using !=}}
\DoxyCodeLine{3083                 \textcolor{comment}{// -\/ a more general approach would be via a compare template that defaults}}
\DoxyCodeLine{3084                 \textcolor{comment}{// to using !=. but could be specialised for, e.g. std::vector<T> etc}}
\DoxyCodeLine{3085                 \textcolor{comment}{// -\/ then just call that directly}}
\DoxyCodeLine{3086                 \textcolor{keywordflow}{if} (m\_comparator.size() != v.size())}
\DoxyCodeLine{3087                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3088                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < v.size(); ++i)}
\DoxyCodeLine{3089                     \textcolor{keywordflow}{if} (m\_comparator[i] != v[i])}
\DoxyCodeLine{3090                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3091                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3092             \}}
\DoxyCodeLine{3093             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{3094                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Equals: "{}} + Catch::toString( m\_comparator );}
\DoxyCodeLine{3095             \}}
\DoxyCodeLine{3096             std::vector<T> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3097         \};}
\DoxyCodeLine{3098 }
\DoxyCodeLine{3099     \} \textcolor{comment}{// namespace Vector}}
\DoxyCodeLine{3100 }
\DoxyCodeLine{3101     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3102     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3103 }
\DoxyCodeLine{3104     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3105     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{Vector::ContainsMatcher<T>}} Contains( std::vector<T> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3106         \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{Vector::ContainsMatcher<T>}}( comparator );}
\DoxyCodeLine{3107     \}}
\DoxyCodeLine{3108 }
\DoxyCodeLine{3109     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3110     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{Vector::ContainsElementMatcher<T>}} VectorContains( T \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3111         \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{Vector::ContainsElementMatcher<T>}}( comparator );}
\DoxyCodeLine{3112     \}}
\DoxyCodeLine{3113 }
\DoxyCodeLine{3114     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3115     Vector::EqualsMatcher<T> Equals( std::vector<T> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3116         \textcolor{keywordflow}{return} Vector::EqualsMatcher<T>( comparator );}
\DoxyCodeLine{3117     \}}
\DoxyCodeLine{3118 }
\DoxyCodeLine{3119 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3120 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3121 }
\DoxyCodeLine{3122 \textcolor{comment}{// \#included from: internal/catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{3123 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_TAG\_ALIAS\_REGISTRY\_H\_INCLUDED}}
\DoxyCodeLine{3124 }
\DoxyCodeLine{3125 \textcolor{comment}{// \#included from: catch\_tag\_alias.h}}
\DoxyCodeLine{3126 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TAG\_ALIAS\_H\_INCLUDED}}
\DoxyCodeLine{3127 }
\DoxyCodeLine{3128 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3129 }
\DoxyCodeLine{3130 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3131 }
\DoxyCodeLine{3132     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1TagAlias}{TagAlias}} \{}
\DoxyCodeLine{3133         \mbox{\hyperlink{structCatch_1_1TagAlias}{TagAlias}}( std::string \textcolor{keyword}{const}\& \_tag, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \_lineInfo ) : tag( \_tag ), lineInfo( \_lineInfo ) \{\}}
\DoxyCodeLine{3134 }
\DoxyCodeLine{3135         std::string tag;}
\DoxyCodeLine{3136         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{3137     \};}
\DoxyCodeLine{3138 }
\DoxyCodeLine{3139     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1RegistrarForTagAliases}{RegistrarForTagAliases}} \{}
\DoxyCodeLine{3140         \mbox{\hyperlink{structCatch_1_1RegistrarForTagAliases}{RegistrarForTagAliases}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{3141     \};}
\DoxyCodeLine{3142 }
\DoxyCodeLine{3143 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{3144 }
\DoxyCodeLine{3145 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TAG\_ALIAS( alias, spec ) namespace\{ Catch::RegistrarForTagAliases INTERNAL\_CATCH\_UNIQUE\_NAME( AutoRegisterTagAlias )( alias, spec, CATCH\_INTERNAL\_LINEINFO ); \}}}
\DoxyCodeLine{3146 \textcolor{comment}{// \#included from: catch\_option.hpp}}
\DoxyCodeLine{3147 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_OPTION\_HPP\_INCLUDED}}
\DoxyCodeLine{3148 }
\DoxyCodeLine{3149 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3150 }
\DoxyCodeLine{3151     \textcolor{comment}{// An optional type}}
\DoxyCodeLine{3152     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3153     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Option}{Option}} \{}
\DoxyCodeLine{3154     \textcolor{keyword}{public}:}
\DoxyCodeLine{3155         \mbox{\hyperlink{classCatch_1_1Option}{Option}}() : nullableValue( CATCH\_NULL ) \{\}}
\DoxyCodeLine{3156         \mbox{\hyperlink{classCatch_1_1Option}{Option}}( T \textcolor{keyword}{const}\& \_value )}
\DoxyCodeLine{3157         : nullableValue( \textcolor{keyword}{new}( storage ) T( \_value ) )}
\DoxyCodeLine{3158         \{\}}
\DoxyCodeLine{3159         \mbox{\hyperlink{classCatch_1_1Option}{Option}}( \mbox{\hyperlink{classCatch_1_1Option}{Option}} \textcolor{keyword}{const}\& \_other )}
\DoxyCodeLine{3160         : nullableValue( \_other ? \textcolor{keyword}{new}( storage ) T( *\_other ) : CATCH\_NULL )}
\DoxyCodeLine{3161         \{\}}
\DoxyCodeLine{3162 }
\DoxyCodeLine{3163         \mbox{\hyperlink{classCatch_1_1Option}{\string~Option}}() \{}
\DoxyCodeLine{3164             reset();}
\DoxyCodeLine{3165         \}}
\DoxyCodeLine{3166 }
\DoxyCodeLine{3167         \mbox{\hyperlink{classCatch_1_1Option}{Option}}\& operator= ( \mbox{\hyperlink{classCatch_1_1Option}{Option}} \textcolor{keyword}{const}\& \_other ) \{}
\DoxyCodeLine{3168             \textcolor{keywordflow}{if}( \&\_other != \textcolor{keyword}{this} ) \{}
\DoxyCodeLine{3169                 reset();}
\DoxyCodeLine{3170                 \textcolor{keywordflow}{if}( \_other )}
\DoxyCodeLine{3171                     nullableValue = \textcolor{keyword}{new}( storage ) T( *\_other );}
\DoxyCodeLine{3172             \}}
\DoxyCodeLine{3173             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3174         \}}
\DoxyCodeLine{3175         \mbox{\hyperlink{classCatch_1_1Option}{Option}}\& operator = ( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{3176             reset();}
\DoxyCodeLine{3177             nullableValue = \textcolor{keyword}{new}( storage ) T( \_value );}
\DoxyCodeLine{3178             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3179         \}}
\DoxyCodeLine{3180 }
\DoxyCodeLine{3181         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{3182             \textcolor{keywordflow}{if}( nullableValue )}
\DoxyCodeLine{3183                 nullableValue-\/>\string~T();}
\DoxyCodeLine{3184             nullableValue = CATCH\_NULL;}
\DoxyCodeLine{3185         \}}
\DoxyCodeLine{3186 }
\DoxyCodeLine{3187         T\& operator*() \{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{3188         T \textcolor{keyword}{const}\& operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{3189         T* operator-\/>() \{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{3190         \textcolor{keyword}{const} T* operator-\/>()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{3191 }
\DoxyCodeLine{3192         T valueOr( T \textcolor{keyword}{const}\& defaultValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3193             \textcolor{keywordflow}{return} nullableValue ? *nullableValue : defaultValue;}
\DoxyCodeLine{3194         \}}
\DoxyCodeLine{3195 }
\DoxyCodeLine{3196         \textcolor{keywordtype}{bool} some()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue != CATCH\_NULL; \}}
\DoxyCodeLine{3197         \textcolor{keywordtype}{bool} none()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == CATCH\_NULL; \}}
\DoxyCodeLine{3198 }
\DoxyCodeLine{3199         \textcolor{keywordtype}{bool} operator !()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == CATCH\_NULL; \}}
\DoxyCodeLine{3200         \textcolor{keyword}{operator} SafeBool::type()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3201             \textcolor{keywordflow}{return} SafeBool::makeSafe( some() );}
\DoxyCodeLine{3202         \}}
\DoxyCodeLine{3203 }
\DoxyCodeLine{3204     \textcolor{keyword}{private}:}
\DoxyCodeLine{3205         T *nullableValue;}
\DoxyCodeLine{3206         \textcolor{keyword}{union }\{}
\DoxyCodeLine{3207             \textcolor{keywordtype}{char} storage[\textcolor{keyword}{sizeof}(T)];}
\DoxyCodeLine{3208 }
\DoxyCodeLine{3209             \textcolor{comment}{// These are here to force alignment for the storage}}
\DoxyCodeLine{3210             \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} dummy1;}
\DoxyCodeLine{3211             void (*dummy2)();}
\DoxyCodeLine{3212             \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} dummy3;}
\DoxyCodeLine{3213 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_LONG\_LONG}}
\DoxyCodeLine{3214             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} dummy4;}
\DoxyCodeLine{3215 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3216         \};}
\DoxyCodeLine{3217     \};}
\DoxyCodeLine{3218 }
\DoxyCodeLine{3219 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{3220 }
\DoxyCodeLine{3221 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3222 }
\DoxyCodeLine{3223     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITagAliasRegistry}{ITagAliasRegistry}} \{}
\DoxyCodeLine{3224         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITagAliasRegistry}{\string~ITagAliasRegistry}}();}
\DoxyCodeLine{3225         \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1Option}{Option<TagAlias>}} find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3226         \textcolor{keyword}{virtual} std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3227 }
\DoxyCodeLine{3228         \textcolor{keyword}{static} \mbox{\hyperlink{structCatch_1_1ITagAliasRegistry}{ITagAliasRegistry}} \textcolor{keyword}{const}\& get();}
\DoxyCodeLine{3229     \};}
\DoxyCodeLine{3230 }
\DoxyCodeLine{3231 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{3232 }
\DoxyCodeLine{3233 \textcolor{comment}{// These files are included here so the single\_include script doesn't put them}}
\DoxyCodeLine{3234 \textcolor{comment}{// in the conditionally compiled sections}}
\DoxyCodeLine{3235 \textcolor{comment}{// \#included from: internal/catch\_test\_case\_info.h}}
\DoxyCodeLine{3236 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TEST\_CASE\_INFO\_H\_INCLUDED}}
\DoxyCodeLine{3237 }
\DoxyCodeLine{3238 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3239 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{3240 }
\DoxyCodeLine{3241 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3242 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{3243 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{3244 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3245 }
\DoxyCodeLine{3246 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3247 }
\DoxyCodeLine{3248     \textcolor{keyword}{struct }ITestCase;}
\DoxyCodeLine{3249 }
\DoxyCodeLine{3250     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \{}
\DoxyCodeLine{3251         \textcolor{keyword}{enum} SpecialProperties\{}
\DoxyCodeLine{3252             None = 0,}
\DoxyCodeLine{3253             IsHidden = 1 << 1,}
\DoxyCodeLine{3254             ShouldFail = 1 << 2,}
\DoxyCodeLine{3255             MayFail = 1 << 3,}
\DoxyCodeLine{3256             Throws = 1 << 4,}
\DoxyCodeLine{3257             NonPortable = 1 << 5}
\DoxyCodeLine{3258         \};}
\DoxyCodeLine{3259 }
\DoxyCodeLine{3260         \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}(   std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{3261                         std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{3262                         std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{3263                         std::set<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{3264                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo );}
\DoxyCodeLine{3265 }
\DoxyCodeLine{3266         \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}( \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{3267 }
\DoxyCodeLine{3268         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} setTags( \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}\& testCaseInfo, std::set<std::string> \textcolor{keyword}{const}\& tags );}
\DoxyCodeLine{3269 }
\DoxyCodeLine{3270         \textcolor{keywordtype}{bool} isHidden() \textcolor{keyword}{const};}
\DoxyCodeLine{3271         \textcolor{keywordtype}{bool} \textcolor{keywordflow}{throws}() \textcolor{keyword}{const};}
\DoxyCodeLine{3272         \textcolor{keywordtype}{bool} okToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{3273         \textcolor{keywordtype}{bool} expectedToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{3274 }
\DoxyCodeLine{3275         std::string name;}
\DoxyCodeLine{3276         std::string className;}
\DoxyCodeLine{3277         std::string description;}
\DoxyCodeLine{3278         std::set<std::string> tags;}
\DoxyCodeLine{3279         std::set<std::string> lcaseTags;}
\DoxyCodeLine{3280         std::string tagsAsString;}
\DoxyCodeLine{3281         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{3282         SpecialProperties properties;}
\DoxyCodeLine{3283     \};}
\DoxyCodeLine{3284 }
\DoxyCodeLine{3285     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \{}
\DoxyCodeLine{3286     \textcolor{keyword}{public}:}
\DoxyCodeLine{3287 }
\DoxyCodeLine{3288         \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}}( \mbox{\hyperlink{structCatch_1_1ITestCase}{ITestCase}}* testCase, \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{3289         \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}}( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{3290 }
\DoxyCodeLine{3291         \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} withName( std::string \textcolor{keyword}{const}\& \_newName ) \textcolor{keyword}{const};}
\DoxyCodeLine{3292 }
\DoxyCodeLine{3293         \textcolor{keywordtype}{void} invoke() \textcolor{keyword}{const};}
\DoxyCodeLine{3294 }
\DoxyCodeLine{3295         \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \textcolor{keyword}{const}\& getTestCaseInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{3296 }
\DoxyCodeLine{3297         \textcolor{keywordtype}{void} swap( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}}\& other );}
\DoxyCodeLine{3298         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{3299         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{3300         \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}}\& operator = ( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{3301 }
\DoxyCodeLine{3302     \textcolor{keyword}{private}:}
\DoxyCodeLine{3303         \mbox{\hyperlink{classCatch_1_1Ptr}{Ptr<ITestCase>}} test;}
\DoxyCodeLine{3304     \};}
\DoxyCodeLine{3305 }
\DoxyCodeLine{3306     \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} makeTestCase(  \mbox{\hyperlink{structCatch_1_1ITestCase}{ITestCase}}* testCase,}
\DoxyCodeLine{3307                             std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{3308                             std::string \textcolor{keyword}{const}\& name,}
\DoxyCodeLine{3309                             std::string \textcolor{keyword}{const}\& description,}
\DoxyCodeLine{3310                             \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{3311 \}}
\DoxyCodeLine{3312 }
\DoxyCodeLine{3313 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3314 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{3315 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3316 }
\DoxyCodeLine{3317 }
\DoxyCodeLine{3318 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{3319 \textcolor{comment}{// \#included from: internal/catch\_objc.hpp}}
\DoxyCodeLine{3320 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_OBJC\_HPP\_INCLUDED}}
\DoxyCodeLine{3321 }
\DoxyCodeLine{3322 \textcolor{preprocessor}{\#import <objc/runtime.h>}}
\DoxyCodeLine{3323 }
\DoxyCodeLine{3324 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3325 }
\DoxyCodeLine{3326 \textcolor{comment}{// NB. Any general catch headers included here must be included}}
\DoxyCodeLine{3327 \textcolor{comment}{// in catch.hpp first to make sure they are included by the single}}
\DoxyCodeLine{3328 \textcolor{comment}{// header for non obj-\/usage}}
\DoxyCodeLine{3329 }
\DoxyCodeLine{3331 \textcolor{comment}{// This protocol is really only here for (self) documenting purposes, since}}
\DoxyCodeLine{3332 \textcolor{comment}{// all its methods are optional.}}
\DoxyCodeLine{3333 \textcolor{keyword}{@protocol }OcFixture}
\DoxyCodeLine{3334 }
\DoxyCodeLine{3335 \textcolor{keyword}{@optional}}
\DoxyCodeLine{3336 }
\DoxyCodeLine{3337 -\/(void) setUp;}
\DoxyCodeLine{3338 -\/(void) tearDown;}
\DoxyCodeLine{3339 }
\DoxyCodeLine{3340 \textcolor{keyword}{@end}}
\DoxyCodeLine{3341 }
\DoxyCodeLine{3342 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3343 }
\DoxyCodeLine{3344     \textcolor{keyword}{class }OcMethod : \textcolor{keyword}{public} SharedImpl<ITestCase> \{}
\DoxyCodeLine{3345 }
\DoxyCodeLine{3346     \textcolor{keyword}{public}:}
\DoxyCodeLine{3347         OcMethod( Class cls, \textcolor{keywordtype}{SEL} sel ) : m\_cls( cls ), m\_sel( sel ) \{\}}
\DoxyCodeLine{3348 }
\DoxyCodeLine{3349         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3350             \textcolor{keywordtype}{id} obj = [[m\_cls alloc] init];}
\DoxyCodeLine{3351 }
\DoxyCodeLine{3352             performOptionalSelector( obj, \textcolor{keyword}{@selector}(setUp)  );}
\DoxyCodeLine{3353             performOptionalSelector( obj, m\_sel );}
\DoxyCodeLine{3354             performOptionalSelector( obj, \textcolor{keyword}{@selector}(tearDown)  );}
\DoxyCodeLine{3355 }
\DoxyCodeLine{3356             arcSafeRelease( obj );}
\DoxyCodeLine{3357         \}}
\DoxyCodeLine{3358     \textcolor{keyword}{private}:}
\DoxyCodeLine{3359         \textcolor{keyword}{virtual} \string~OcMethod() \{\}}
\DoxyCodeLine{3360 }
\DoxyCodeLine{3361         Class m\_cls;}
\DoxyCodeLine{3362         \textcolor{keywordtype}{SEL} m\_sel;}
\DoxyCodeLine{3363     \};}
\DoxyCodeLine{3364 }
\DoxyCodeLine{3365     \textcolor{keyword}{namespace }Detail\{}
\DoxyCodeLine{3366 }
\DoxyCodeLine{3367         \textcolor{keyword}{inline} std::string getAnnotation(   Class cls,}
\DoxyCodeLine{3368                                             std::string \textcolor{keyword}{const}\& annotationName,}
\DoxyCodeLine{3369                                             std::string \textcolor{keyword}{const}\& testCaseName ) \{}
\DoxyCodeLine{3370             NSString* selStr = [[NSString alloc] initWithFormat:@"{}Catch\_\%s\_\%s"{}, annotationName.c\_str(), testCaseName.c\_str()];}
\DoxyCodeLine{3371             \textcolor{keywordtype}{SEL} sel = NSSelectorFromString( selStr );}
\DoxyCodeLine{3372             arcSafeRelease( selStr );}
\DoxyCodeLine{3373             \textcolor{keywordtype}{id} value = performOptionalSelector( cls, sel );}
\DoxyCodeLine{3374             \textcolor{keywordflow}{if}( value )}
\DoxyCodeLine{3375                 \textcolor{keywordflow}{return} [(NSString*)value UTF8String];}
\DoxyCodeLine{3376             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3377         \}}
\DoxyCodeLine{3378     \}}
\DoxyCodeLine{3379 }
\DoxyCodeLine{3380     \textcolor{keyword}{inline} \textcolor{keywordtype}{size\_t} registerTestMethods() \{}
\DoxyCodeLine{3381         \textcolor{keywordtype}{size\_t} noTestMethods = 0;}
\DoxyCodeLine{3382         \textcolor{keywordtype}{int} noClasses = objc\_getClassList( CATCH\_NULL, 0 );}
\DoxyCodeLine{3383 }
\DoxyCodeLine{3384         Class* classes = (CATCH\_UNSAFE\_UNRETAINED Class *)malloc( \textcolor{keyword}{sizeof}(Class) * noClasses);}
\DoxyCodeLine{3385         objc\_getClassList( classes, noClasses );}
\DoxyCodeLine{3386 }
\DoxyCodeLine{3387         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} c = 0; c < noClasses; c++ ) \{}
\DoxyCodeLine{3388             Class cls = classes[c];}
\DoxyCodeLine{3389             \{}
\DoxyCodeLine{3390                 u\_int count;}
\DoxyCodeLine{3391                 Method* methods = class\_copyMethodList( cls, \&count );}
\DoxyCodeLine{3392                 \textcolor{keywordflow}{for}( u\_int m = 0; m < count ; m++ ) \{}
\DoxyCodeLine{3393                     \textcolor{keywordtype}{SEL} selector = method\_getName(methods[m]);}
\DoxyCodeLine{3394                     std::string methodName = sel\_getName(selector);}
\DoxyCodeLine{3395                     \textcolor{keywordflow}{if}( startsWith( methodName, \textcolor{stringliteral}{"{}Catch\_TestCase\_"{}} ) ) \{}
\DoxyCodeLine{3396                         std::string testCaseName = methodName.substr( 15 );}
\DoxyCodeLine{3397                         std::string name = Detail::getAnnotation( cls, \textcolor{stringliteral}{"{}Name"{}}, testCaseName );}
\DoxyCodeLine{3398                         std::string desc = Detail::getAnnotation( cls, \textcolor{stringliteral}{"{}Description"{}}, testCaseName );}
\DoxyCodeLine{3399                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* className = class\_getName( cls );}
\DoxyCodeLine{3400 }
\DoxyCodeLine{3401                         getMutableRegistryHub().registerTest( makeTestCase( \textcolor{keyword}{new} OcMethod( cls, selector ), className, name.c\_str(), desc.c\_str(), SourceLineInfo() ) );}
\DoxyCodeLine{3402                         noTestMethods++;}
\DoxyCodeLine{3403                     \}}
\DoxyCodeLine{3404                 \}}
\DoxyCodeLine{3405                 free(methods);}
\DoxyCodeLine{3406             \}}
\DoxyCodeLine{3407         \}}
\DoxyCodeLine{3408         \textcolor{keywordflow}{return} noTestMethods;}
\DoxyCodeLine{3409     \}}
\DoxyCodeLine{3410 }
\DoxyCodeLine{3411     \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3412         \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{3413         \textcolor{keyword}{namespace }NSStringMatchers \{}
\DoxyCodeLine{3414 }
\DoxyCodeLine{3415             \textcolor{keyword}{struct }StringHolder : MatcherBase<NSString*>\{}
\DoxyCodeLine{3416                 StringHolder( NSString* substr ) : m\_substr( [substr copy] )\{\}}
\DoxyCodeLine{3417                 StringHolder( StringHolder \textcolor{keyword}{const}\& other ) : m\_substr( [other.m\_substr copy] )\{\}}
\DoxyCodeLine{3418                 StringHolder() \{}
\DoxyCodeLine{3419                     arcSafeRelease( m\_substr );}
\DoxyCodeLine{3420                 \}}
\DoxyCodeLine{3421 }
\DoxyCodeLine{3422                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( NSString* arg ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{3423                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3424                 \}}
\DoxyCodeLine{3425 }
\DoxyCodeLine{3426                 NSString* m\_substr;}
\DoxyCodeLine{3427             \};}
\DoxyCodeLine{3428 }
\DoxyCodeLine{3429             \textcolor{keyword}{struct }Equals : StringHolder \{}
\DoxyCodeLine{3430                 Equals( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{3431 }
\DoxyCodeLine{3432                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( NSString* str ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{3433                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{3434                             [str isEqualToString:m\_substr];}
\DoxyCodeLine{3435                 \}}
\DoxyCodeLine{3436 }
\DoxyCodeLine{3437                 \textcolor{keyword}{virtual} std::string describe() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{3438                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}equals string: "{}} + Catch::toString( m\_substr );}
\DoxyCodeLine{3439                 \}}
\DoxyCodeLine{3440             \};}
\DoxyCodeLine{3441 }
\DoxyCodeLine{3442             \textcolor{keyword}{struct }Contains : StringHolder \{}
\DoxyCodeLine{3443                 Contains( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{3444 }
\DoxyCodeLine{3445                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3446                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{3447                             [str rangeOfString:m\_substr].location != NSNotFound;}
\DoxyCodeLine{3448                 \}}
\DoxyCodeLine{3449 }
\DoxyCodeLine{3450                 \textcolor{keyword}{virtual} std::string describe() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{3451                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}contains string: "{}} + Catch::toString( m\_substr );}
\DoxyCodeLine{3452                 \}}
\DoxyCodeLine{3453             \};}
\DoxyCodeLine{3454 }
\DoxyCodeLine{3455             \textcolor{keyword}{struct }StartsWith : StringHolder \{}
\DoxyCodeLine{3456                 StartsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{3457 }
\DoxyCodeLine{3458                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3459                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{3460                             [str rangeOfString:m\_substr].location == 0;}
\DoxyCodeLine{3461                 \}}
\DoxyCodeLine{3462 }
\DoxyCodeLine{3463                 \textcolor{keyword}{virtual} std::string describe() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{3464                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}starts with: "{}} + Catch::toString( m\_substr );}
\DoxyCodeLine{3465                 \}}
\DoxyCodeLine{3466             \};}
\DoxyCodeLine{3467             \textcolor{keyword}{struct }EndsWith : StringHolder \{}
\DoxyCodeLine{3468                 EndsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{3469 }
\DoxyCodeLine{3470                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3471                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{3472                             [str rangeOfString:m\_substr].location == [str length] -\/ [m\_substr length];}
\DoxyCodeLine{3473                 \}}
\DoxyCodeLine{3474 }
\DoxyCodeLine{3475                 \textcolor{keyword}{virtual} std::string describe() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{3476                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ends with: "{}} + Catch::toString( m\_substr );}
\DoxyCodeLine{3477                 \}}
\DoxyCodeLine{3478             \};}
\DoxyCodeLine{3479 }
\DoxyCodeLine{3480         \} \textcolor{comment}{// namespace NSStringMatchers}}
\DoxyCodeLine{3481         \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{3482 }
\DoxyCodeLine{3483         \textcolor{keyword}{inline} Impl::NSStringMatchers::Equals}
\DoxyCodeLine{3484             Equals( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Equals( substr ); \}}
\DoxyCodeLine{3485 }
\DoxyCodeLine{3486         \textcolor{keyword}{inline} Impl::NSStringMatchers::Contains}
\DoxyCodeLine{3487             Contains( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Contains( substr ); \}}
\DoxyCodeLine{3488 }
\DoxyCodeLine{3489         \textcolor{keyword}{inline} Impl::NSStringMatchers::StartsWith}
\DoxyCodeLine{3490             StartsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::StartsWith( substr ); \}}
\DoxyCodeLine{3491 }
\DoxyCodeLine{3492         \textcolor{keyword}{inline} Impl::NSStringMatchers::EndsWith}
\DoxyCodeLine{3493             EndsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::EndsWith( substr ); \}}
\DoxyCodeLine{3494 }
\DoxyCodeLine{3495     \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3496 }
\DoxyCodeLine{3497     \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{3498 }
\DoxyCodeLine{3499 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3500 }
\DoxyCodeLine{3502 \textcolor{preprocessor}{\#define OC\_TEST\_CASE( name, desc )\(\backslash\)}}
\DoxyCodeLine{3503 \textcolor{preprocessor}{+(NSString*) INTERNAL\_CATCH\_UNIQUE\_NAME( Catch\_Name\_test ) \(\backslash\)}}
\DoxyCodeLine{3504 \textcolor{preprocessor}{\{\(\backslash\)}}
\DoxyCodeLine{3505 \textcolor{preprocessor}{return @ name; \(\backslash\)}}
\DoxyCodeLine{3506 \textcolor{preprocessor}{\}\(\backslash\)}}
\DoxyCodeLine{3507 \textcolor{preprocessor}{+(NSString*) INTERNAL\_CATCH\_UNIQUE\_NAME( Catch\_Description\_test ) \(\backslash\)}}
\DoxyCodeLine{3508 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{3509 \textcolor{preprocessor}{return @ desc; \(\backslash\)}}
\DoxyCodeLine{3510 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{3511 \textcolor{preprocessor}{-\/(void) INTERNAL\_CATCH\_UNIQUE\_NAME( Catch\_TestCase\_test )}}
\DoxyCodeLine{3512 }
\DoxyCodeLine{3513 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3514 }
\DoxyCodeLine{3515 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{3516 }
\DoxyCodeLine{3517 \textcolor{comment}{// !TBD: Move the leak detector code into a separate header}}
\DoxyCodeLine{3518 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WINDOWS\_CRTDBG}}
\DoxyCodeLine{3519 \textcolor{preprocessor}{\#include <crtdbg.h>}}
\DoxyCodeLine{3520 \textcolor{keyword}{class }LeakDetector \{}
\DoxyCodeLine{3521 \textcolor{keyword}{public}:}
\DoxyCodeLine{3522     LeakDetector() \{}
\DoxyCodeLine{3523         \textcolor{keywordtype}{int} flag = \_CrtSetDbgFlag(\_CRTDBG\_REPORT\_FLAG);}
\DoxyCodeLine{3524         flag |= \_CRTDBG\_LEAK\_CHECK\_DF;}
\DoxyCodeLine{3525         flag |= \_CRTDBG\_ALLOC\_MEM\_DF;}
\DoxyCodeLine{3526         \_CrtSetDbgFlag(flag);}
\DoxyCodeLine{3527         \_CrtSetReportMode(\_CRT\_WARN, \_CRTDBG\_MODE\_FILE | \_CRTDBG\_MODE\_DEBUG);}
\DoxyCodeLine{3528         \_CrtSetReportFile(\_CRT\_WARN, \_CRTDBG\_FILE\_STDERR);}
\DoxyCodeLine{3529         \textcolor{comment}{// Change this to leaking allocation's number to break there}}
\DoxyCodeLine{3530         \_CrtSetBreakAlloc(-\/1);}
\DoxyCodeLine{3531     \}}
\DoxyCodeLine{3532 \};}
\DoxyCodeLine{3533 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3534 \textcolor{keyword}{class }LeakDetector \{\};}
\DoxyCodeLine{3535 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3536 }
\DoxyCodeLine{3537 LeakDetector leakDetector;}
\DoxyCodeLine{3538 }
\DoxyCodeLine{3539 \textcolor{comment}{// \#included from: internal/catch\_impl.hpp}}
\DoxyCodeLine{3540 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_IMPL\_HPP\_INCLUDED}}
\DoxyCodeLine{3541 }
\DoxyCodeLine{3542 \textcolor{comment}{// Collect all the implementation files together here}}
\DoxyCodeLine{3543 \textcolor{comment}{// These are the equivalent of what would usually be cpp files}}
\DoxyCodeLine{3544 }
\DoxyCodeLine{3545 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3546 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{3547 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wweak-\/vtables"{}}}
\DoxyCodeLine{3548 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3549 }
\DoxyCodeLine{3550 \textcolor{comment}{// \#included from: ../catch\_session.hpp}}
\DoxyCodeLine{3551 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_RUNNER\_HPP\_INCLUDED}}
\DoxyCodeLine{3552 }
\DoxyCodeLine{3553 \textcolor{comment}{// \#included from: internal/catch\_commandline.hpp}}
\DoxyCodeLine{3554 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_COMMANDLINE\_HPP\_INCLUDED}}
\DoxyCodeLine{3555 }
\DoxyCodeLine{3556 \textcolor{comment}{// \#included from: catch\_config.hpp}}
\DoxyCodeLine{3557 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_CONFIG\_HPP\_INCLUDED}}
\DoxyCodeLine{3558 }
\DoxyCodeLine{3559 \textcolor{comment}{// \#included from: catch\_test\_spec\_parser.hpp}}
\DoxyCodeLine{3560 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TEST\_SPEC\_PARSER\_HPP\_INCLUDED}}
\DoxyCodeLine{3561 }
\DoxyCodeLine{3562 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3563 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{3564 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{3565 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3566 }
\DoxyCodeLine{3567 \textcolor{comment}{// \#included from: catch\_test\_spec.hpp}}
\DoxyCodeLine{3568 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TEST\_SPEC\_HPP\_INCLUDED}}
\DoxyCodeLine{3569 }
\DoxyCodeLine{3570 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3571 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{3572 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{3573 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3574 }
\DoxyCodeLine{3575 \textcolor{comment}{// \#included from: catch\_wildcard\_pattern.hpp}}
\DoxyCodeLine{3576 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_WILDCARD\_PATTERN\_HPP\_INCLUDED}}
\DoxyCodeLine{3577 }
\DoxyCodeLine{3578 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{3579 }
\DoxyCodeLine{3580 \textcolor{keyword}{namespace }Catch}
\DoxyCodeLine{3581 \{}
\DoxyCodeLine{3582     \textcolor{keyword}{class }WildcardPattern \{}
\DoxyCodeLine{3583         \textcolor{keyword}{enum} WildcardPosition \{}
\DoxyCodeLine{3584             NoWildcard = 0,}
\DoxyCodeLine{3585             WildcardAtStart = 1,}
\DoxyCodeLine{3586             WildcardAtEnd = 2,}
\DoxyCodeLine{3587             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd}
\DoxyCodeLine{3588         \};}
\DoxyCodeLine{3589 }
\DoxyCodeLine{3590     \textcolor{keyword}{public}:}
\DoxyCodeLine{3591 }
\DoxyCodeLine{3592         WildcardPattern( std::string \textcolor{keyword}{const}\& pattern, CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{3593         :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{3594             m\_wildcard( NoWildcard ),}
\DoxyCodeLine{3595             m\_pattern( adjustCase( pattern ) )}
\DoxyCodeLine{3596         \{}
\DoxyCodeLine{3597             \textcolor{keywordflow}{if}( startsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{3598                 m\_pattern = m\_pattern.substr( 1 );}
\DoxyCodeLine{3599                 m\_wildcard = WildcardAtStart;}
\DoxyCodeLine{3600             \}}
\DoxyCodeLine{3601             \textcolor{keywordflow}{if}( endsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{3602                 m\_pattern = m\_pattern.substr( 0, m\_pattern.size()-\/1 );}
\DoxyCodeLine{3603                 m\_wildcard = \textcolor{keyword}{static\_cast<}WildcardPosition\textcolor{keyword}{>}( m\_wildcard | WildcardAtEnd );}
\DoxyCodeLine{3604             \}}
\DoxyCodeLine{3605         \}}
\DoxyCodeLine{3606         \textcolor{keyword}{virtual} \string~WildcardPattern();}
\DoxyCodeLine{3607         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3608             \textcolor{keywordflow}{switch}( m\_wildcard ) \{}
\DoxyCodeLine{3609                 \textcolor{keywordflow}{case} NoWildcard:}
\DoxyCodeLine{3610                     \textcolor{keywordflow}{return} m\_pattern == adjustCase( str );}
\DoxyCodeLine{3611                 \textcolor{keywordflow}{case} WildcardAtStart:}
\DoxyCodeLine{3612                     \textcolor{keywordflow}{return} endsWith( adjustCase( str ), m\_pattern );}
\DoxyCodeLine{3613                 \textcolor{keywordflow}{case} WildcardAtEnd:}
\DoxyCodeLine{3614                     \textcolor{keywordflow}{return} startsWith( adjustCase( str ), m\_pattern );}
\DoxyCodeLine{3615                 \textcolor{keywordflow}{case} WildcardAtBothEnds:}
\DoxyCodeLine{3616                     \textcolor{keywordflow}{return} contains( adjustCase( str ), m\_pattern );}
\DoxyCodeLine{3617             \}}
\DoxyCodeLine{3618 }
\DoxyCodeLine{3619 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3620 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{3621 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wunreachable-\/code"{}}}
\DoxyCodeLine{3622 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3623             \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}Unknown enum"{}} );}
\DoxyCodeLine{3624 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3625 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{3626 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3627         \}}
\DoxyCodeLine{3628     \textcolor{keyword}{private}:}
\DoxyCodeLine{3629         std::string adjustCase( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3630             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;}
\DoxyCodeLine{3631         \}}
\DoxyCodeLine{3632         CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{3633         WildcardPosition m\_wildcard;}
\DoxyCodeLine{3634         std::string m\_pattern;}
\DoxyCodeLine{3635     \};}
\DoxyCodeLine{3636 \}}
\DoxyCodeLine{3637 }
\DoxyCodeLine{3638 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3639 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3640 }
\DoxyCodeLine{3641 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3642 }
\DoxyCodeLine{3643     \textcolor{keyword}{class }TestSpec \{}
\DoxyCodeLine{3644         \textcolor{keyword}{struct }Pattern : SharedImpl<> \{}
\DoxyCodeLine{3645             \textcolor{keyword}{virtual} \string~Pattern();}
\DoxyCodeLine{3646             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3647         \};}
\DoxyCodeLine{3648         \textcolor{keyword}{class }NamePattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{3649         \textcolor{keyword}{public}:}
\DoxyCodeLine{3650             NamePattern( std::string \textcolor{keyword}{const}\& name )}
\DoxyCodeLine{3651             : m\_wildcardPattern( toLower( name ), CaseSensitive::No )}
\DoxyCodeLine{3652             \{\}}
\DoxyCodeLine{3653             \textcolor{keyword}{virtual} \string~NamePattern();}
\DoxyCodeLine{3654             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3655                 \textcolor{keywordflow}{return} m\_wildcardPattern.matches( toLower( testCase.name ) );}
\DoxyCodeLine{3656             \}}
\DoxyCodeLine{3657         \textcolor{keyword}{private}:}
\DoxyCodeLine{3658             WildcardPattern m\_wildcardPattern;}
\DoxyCodeLine{3659         \};}
\DoxyCodeLine{3660 }
\DoxyCodeLine{3661         \textcolor{keyword}{class }TagPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{3662         \textcolor{keyword}{public}:}
\DoxyCodeLine{3663             TagPattern( std::string \textcolor{keyword}{const}\& tag ) : m\_tag( toLower( tag ) ) \{\}}
\DoxyCodeLine{3664             \textcolor{keyword}{virtual} \string~TagPattern();}
\DoxyCodeLine{3665             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3666                 \textcolor{keywordflow}{return} testCase.lcaseTags.find( m\_tag ) != testCase.lcaseTags.end();}
\DoxyCodeLine{3667             \}}
\DoxyCodeLine{3668         \textcolor{keyword}{private}:}
\DoxyCodeLine{3669             std::string m\_tag;}
\DoxyCodeLine{3670         \};}
\DoxyCodeLine{3671 }
\DoxyCodeLine{3672         \textcolor{keyword}{class }ExcludedPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{3673         \textcolor{keyword}{public}:}
\DoxyCodeLine{3674             ExcludedPattern( Ptr<Pattern> \textcolor{keyword}{const}\& underlyingPattern ) : m\_underlyingPattern( underlyingPattern ) \{\}}
\DoxyCodeLine{3675             \textcolor{keyword}{virtual} \string~ExcludedPattern();}
\DoxyCodeLine{3676             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !m\_underlyingPattern-\/>matches( testCase ); \}}
\DoxyCodeLine{3677         \textcolor{keyword}{private}:}
\DoxyCodeLine{3678             Ptr<Pattern> m\_underlyingPattern;}
\DoxyCodeLine{3679         \};}
\DoxyCodeLine{3680 }
\DoxyCodeLine{3681         \textcolor{keyword}{struct }Filter \{}
\DoxyCodeLine{3682             std::vector<Ptr<Pattern> > m\_patterns;}
\DoxyCodeLine{3683 }
\DoxyCodeLine{3684             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3685                 \textcolor{comment}{// All patterns in a filter must match for the filter to be a match}}
\DoxyCodeLine{3686                 \textcolor{keywordflow}{for}( std::vector<Ptr<Pattern> >::const\_iterator it = m\_patterns.begin(), itEnd = m\_patterns.end(); it != itEnd; ++it ) \{}
\DoxyCodeLine{3687                     \textcolor{keywordflow}{if}( !(*it)-\/>matches( testCase ) )}
\DoxyCodeLine{3688                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3689                 \}}
\DoxyCodeLine{3690                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3691             \}}
\DoxyCodeLine{3692         \};}
\DoxyCodeLine{3693 }
\DoxyCodeLine{3694     \textcolor{keyword}{public}:}
\DoxyCodeLine{3695         \textcolor{keywordtype}{bool} hasFilters()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3696             \textcolor{keywordflow}{return} !m\_filters.empty();}
\DoxyCodeLine{3697         \}}
\DoxyCodeLine{3698         \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3699             \textcolor{comment}{// A TestSpec matches if any filter matches}}
\DoxyCodeLine{3700             \textcolor{keywordflow}{for}( std::vector<Filter>::const\_iterator it = m\_filters.begin(), itEnd = m\_filters.end(); it != itEnd; ++it )}
\DoxyCodeLine{3701                 \textcolor{keywordflow}{if}( it-\/>matches( testCase ) )}
\DoxyCodeLine{3702                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3703             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3704         \}}
\DoxyCodeLine{3705 }
\DoxyCodeLine{3706     \textcolor{keyword}{private}:}
\DoxyCodeLine{3707         std::vector<Filter> m\_filters;}
\DoxyCodeLine{3708 }
\DoxyCodeLine{3709         \textcolor{keyword}{friend} \textcolor{keyword}{class }TestSpecParser;}
\DoxyCodeLine{3710     \};}
\DoxyCodeLine{3711 \}}
\DoxyCodeLine{3712 }
\DoxyCodeLine{3713 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3714 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{3715 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3716 }
\DoxyCodeLine{3717 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3718 }
\DoxyCodeLine{3719     \textcolor{keyword}{class }TestSpecParser \{}
\DoxyCodeLine{3720         \textcolor{keyword}{enum} Mode\{ \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}}, Name, QuotedName, Tag, EscapedName \};}
\DoxyCodeLine{3721         Mode m\_mode;}
\DoxyCodeLine{3722         \textcolor{keywordtype}{bool} m\_exclusion;}
\DoxyCodeLine{3723         std::size\_t m\_start, m\_pos;}
\DoxyCodeLine{3724         std::string m\_arg;}
\DoxyCodeLine{3725         std::vector<std::size\_t> m\_escapeChars;}
\DoxyCodeLine{3726         TestSpec::Filter m\_currentFilter;}
\DoxyCodeLine{3727         TestSpec m\_testSpec;}
\DoxyCodeLine{3728         ITagAliasRegistry \textcolor{keyword}{const}* m\_tagAliases;}
\DoxyCodeLine{3729 }
\DoxyCodeLine{3730     \textcolor{keyword}{public}:}
\DoxyCodeLine{3731         TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases ) :m\_mode(\mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}}), m\_exclusion(false), m\_start(0), m\_pos(0), m\_tagAliases( \&tagAliases ) \{\}}
\DoxyCodeLine{3732 }
\DoxyCodeLine{3733         TestSpecParser\& parse( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{3734             m\_mode = \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}};}
\DoxyCodeLine{3735             m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{3736             m\_start = std::string::npos;}
\DoxyCodeLine{3737             m\_arg = m\_tagAliases-\/>expandAliases( arg );}
\DoxyCodeLine{3738             m\_escapeChars.clear();}
\DoxyCodeLine{3739             \textcolor{keywordflow}{for}( m\_pos = 0; m\_pos < m\_arg.size(); ++m\_pos )}
\DoxyCodeLine{3740                 visitChar( m\_arg[m\_pos] );}
\DoxyCodeLine{3741             \textcolor{keywordflow}{if}( m\_mode == Name )}
\DoxyCodeLine{3742                 addPattern<TestSpec::NamePattern>();}
\DoxyCodeLine{3743             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3744         \}}
\DoxyCodeLine{3745         TestSpec testSpec() \{}
\DoxyCodeLine{3746             addFilter();}
\DoxyCodeLine{3747             \textcolor{keywordflow}{return} m\_testSpec;}
\DoxyCodeLine{3748         \}}
\DoxyCodeLine{3749     \textcolor{keyword}{private}:}
\DoxyCodeLine{3750         \textcolor{keywordtype}{void} visitChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{3751             \textcolor{keywordflow}{if}( m\_mode == None ) \{}
\DoxyCodeLine{3752                 \textcolor{keywordflow}{switch}( c ) \{}
\DoxyCodeLine{3753                 \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}: \textcolor{keywordflow}{return};}
\DoxyCodeLine{3754                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string~'}: m\_exclusion = \textcolor{keyword}{true}; \textcolor{keywordflow}{return};}
\DoxyCodeLine{3755                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}: \textcolor{keywordflow}{return} startNewMode( Tag, ++m\_pos );}
\DoxyCodeLine{3756                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}: \textcolor{keywordflow}{return} startNewMode( QuotedName, ++m\_pos );}
\DoxyCodeLine{3757                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}: \textcolor{keywordflow}{return} escape();}
\DoxyCodeLine{3758                 \textcolor{keywordflow}{default}: startNewMode( Name, m\_pos ); \textcolor{keywordflow}{break};}
\DoxyCodeLine{3759                 \}}
\DoxyCodeLine{3760             \}}
\DoxyCodeLine{3761             \textcolor{keywordflow}{if}( m\_mode == Name ) \{}
\DoxyCodeLine{3762                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{','} ) \{}
\DoxyCodeLine{3763                     addPattern<TestSpec::NamePattern>();}
\DoxyCodeLine{3764                     addFilter();}
\DoxyCodeLine{3765                 \}}
\DoxyCodeLine{3766                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} ) \{}
\DoxyCodeLine{3767                     \textcolor{keywordflow}{if}( subString() == \textcolor{stringliteral}{"{}exclude:"{}} )}
\DoxyCodeLine{3768                         m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{3769                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3770                         addPattern<TestSpec::NamePattern>();}
\DoxyCodeLine{3771                     startNewMode( Tag, ++m\_pos );}
\DoxyCodeLine{3772                 \}}
\DoxyCodeLine{3773                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} )}
\DoxyCodeLine{3774                     escape();}
\DoxyCodeLine{3775             \}}
\DoxyCodeLine{3776             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( m\_mode == EscapedName )}
\DoxyCodeLine{3777                 m\_mode = Name;}
\DoxyCodeLine{3778             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( m\_mode == QuotedName \&\& c == \textcolor{charliteral}{'"{}'} )}
\DoxyCodeLine{3779                 addPattern<TestSpec::NamePattern>();}
\DoxyCodeLine{3780             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( m\_mode == Tag \&\& c == \textcolor{charliteral}{']'} )}
\DoxyCodeLine{3781                 addPattern<TestSpec::TagPattern>();}
\DoxyCodeLine{3782         \}}
\DoxyCodeLine{3783         \textcolor{keywordtype}{void} startNewMode( Mode mode, std::size\_t start ) \{}
\DoxyCodeLine{3784             m\_mode = mode;}
\DoxyCodeLine{3785             m\_start = start;}
\DoxyCodeLine{3786         \}}
\DoxyCodeLine{3787         \textcolor{keywordtype}{void} escape() \{}
\DoxyCodeLine{3788             \textcolor{keywordflow}{if}( m\_mode == None )}
\DoxyCodeLine{3789                 m\_start = m\_pos;}
\DoxyCodeLine{3790             m\_mode = EscapedName;}
\DoxyCodeLine{3791             m\_escapeChars.push\_back( m\_pos );}
\DoxyCodeLine{3792         \}}
\DoxyCodeLine{3793         std::string subString()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_arg.substr( m\_start, m\_pos -\/ m\_start ); \}}
\DoxyCodeLine{3794         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3795         \textcolor{keywordtype}{void} addPattern() \{}
\DoxyCodeLine{3796             std::string token = subString();}
\DoxyCodeLine{3797             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < m\_escapeChars.size(); ++i )}
\DoxyCodeLine{3798                 token = token.substr( 0, m\_escapeChars[i]-\/m\_start-\/i ) + token.substr( m\_escapeChars[i]-\/m\_start-\/i+1 );}
\DoxyCodeLine{3799             m\_escapeChars.clear();}
\DoxyCodeLine{3800             \textcolor{keywordflow}{if}( startsWith( token, \textcolor{stringliteral}{"{}exclude:"{}} ) ) \{}
\DoxyCodeLine{3801                 m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{3802                 token = token.substr( 8 );}
\DoxyCodeLine{3803             \}}
\DoxyCodeLine{3804             \textcolor{keywordflow}{if}( !token.empty() ) \{}
\DoxyCodeLine{3805                 Ptr<TestSpec::Pattern> pattern = new T( token );}
\DoxyCodeLine{3806                 if( m\_exclusion )}
\DoxyCodeLine{3807                     pattern = new TestSpec::ExcludedPattern( pattern );}
\DoxyCodeLine{3808                 m\_currentFilter.m\_patterns.push\_back( pattern );}
\DoxyCodeLine{3809             \}}
\DoxyCodeLine{3810             m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{3811             m\_mode = None;}
\DoxyCodeLine{3812         \}}
\DoxyCodeLine{3813         \textcolor{keywordtype}{void} addFilter() \{}
\DoxyCodeLine{3814             \textcolor{keywordflow}{if}( !m\_currentFilter.m\_patterns.empty() ) \{}
\DoxyCodeLine{3815                 m\_testSpec.m\_filters.push\_back( m\_currentFilter );}
\DoxyCodeLine{3816                 m\_currentFilter = TestSpec::Filter();}
\DoxyCodeLine{3817             \}}
\DoxyCodeLine{3818         \}}
\DoxyCodeLine{3819     \};}
\DoxyCodeLine{3820     \textcolor{keyword}{inline} TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{3821         \textcolor{keywordflow}{return} TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();}
\DoxyCodeLine{3822     \}}
\DoxyCodeLine{3823 }
\DoxyCodeLine{3824 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3825 }
\DoxyCodeLine{3826 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3827 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{3828 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3829 }
\DoxyCodeLine{3830 \textcolor{comment}{// \#included from: catch\_interfaces\_config.h}}
\DoxyCodeLine{3831 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_CONFIG\_H\_INCLUDED}}
\DoxyCodeLine{3832 }
\DoxyCodeLine{3833 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{3834 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3835 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3836 }
\DoxyCodeLine{3837 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3838 }
\DoxyCodeLine{3839     \textcolor{keyword}{struct }Verbosity \{ \textcolor{keyword}{enum} Level \{}
\DoxyCodeLine{3840         NoOutput = 0,}
\DoxyCodeLine{3841         Quiet,}
\DoxyCodeLine{3842         Normal}
\DoxyCodeLine{3843     \}; \};}
\DoxyCodeLine{3844 }
\DoxyCodeLine{3845     \textcolor{keyword}{struct }WarnAbout \{ \textcolor{keyword}{enum} What \{}
\DoxyCodeLine{3846         Nothing = 0x00,}
\DoxyCodeLine{3847         NoAssertions = 0x01}
\DoxyCodeLine{3848     \}; \};}
\DoxyCodeLine{3849 }
\DoxyCodeLine{3850     \textcolor{keyword}{struct }ShowDurations \{ \textcolor{keyword}{enum} OrNot \{}
\DoxyCodeLine{3851         DefaultForReporter,}
\DoxyCodeLine{3852         Always,}
\DoxyCodeLine{3853         Never}
\DoxyCodeLine{3854     \}; \};}
\DoxyCodeLine{3855     \textcolor{keyword}{struct }RunTests \{ \textcolor{keyword}{enum} InWhatOrder \{}
\DoxyCodeLine{3856         InDeclarationOrder,}
\DoxyCodeLine{3857         InLexicographicalOrder,}
\DoxyCodeLine{3858         InRandomOrder}
\DoxyCodeLine{3859     \}; \};}
\DoxyCodeLine{3860     \textcolor{keyword}{struct }UseColour \{ \textcolor{keyword}{enum} YesOrNo \{}
\DoxyCodeLine{3861         Auto,}
\DoxyCodeLine{3862         Yes,}
\DoxyCodeLine{3863         No}
\DoxyCodeLine{3864     \}; \};}
\DoxyCodeLine{3865     \textcolor{keyword}{struct }WaitForKeypress \{ \textcolor{keyword}{enum} When \{}
\DoxyCodeLine{3866         Never,}
\DoxyCodeLine{3867         BeforeStart = 1,}
\DoxyCodeLine{3868         BeforeExit = 2,}
\DoxyCodeLine{3869         BeforeStartAndExit = BeforeStart | BeforeExit}
\DoxyCodeLine{3870     \}; \};}
\DoxyCodeLine{3871 }
\DoxyCodeLine{3872     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{3873 }
\DoxyCodeLine{3874     \textcolor{keyword}{struct }IConfig : IShared \{}
\DoxyCodeLine{3875 }
\DoxyCodeLine{3876         \textcolor{keyword}{virtual} \string~IConfig();}
\DoxyCodeLine{3877 }
\DoxyCodeLine{3878         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3879         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3880         \textcolor{keyword}{virtual} std::string name() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3881         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3882         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3883         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3884         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3885         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3886         \textcolor{keyword}{virtual} ShowDurations::OrNot showDurations() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3887         \textcolor{keyword}{virtual} TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3888         \textcolor{keyword}{virtual} RunTests::InWhatOrder runOrder() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3889         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3890         \textcolor{keyword}{virtual} UseColour::YesOrNo useColour() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3891         \textcolor{keyword}{virtual} std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3892 }
\DoxyCodeLine{3893     \};}
\DoxyCodeLine{3894 \}}
\DoxyCodeLine{3895 }
\DoxyCodeLine{3896 \textcolor{comment}{// \#included from: catch\_stream.h}}
\DoxyCodeLine{3897 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_STREAM\_H\_INCLUDED}}
\DoxyCodeLine{3898 }
\DoxyCodeLine{3899 \textcolor{comment}{// \#included from: catch\_streambuf.h}}
\DoxyCodeLine{3900 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_STREAMBUF\_H\_INCLUDED}}
\DoxyCodeLine{3901 }
\DoxyCodeLine{3902 \textcolor{preprocessor}{\#include <streambuf>}}
\DoxyCodeLine{3903 }
\DoxyCodeLine{3904 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3905 }
\DoxyCodeLine{3906     \textcolor{keyword}{class }StreamBufBase : \textcolor{keyword}{public} std::streambuf \{}
\DoxyCodeLine{3907     \textcolor{keyword}{public}:}
\DoxyCodeLine{3908         \textcolor{keyword}{virtual} \string~StreamBufBase() CATCH\_NOEXCEPT;}
\DoxyCodeLine{3909     \};}
\DoxyCodeLine{3910 \}}
\DoxyCodeLine{3911 }
\DoxyCodeLine{3912 \textcolor{preprocessor}{\#include <streambuf>}}
\DoxyCodeLine{3913 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{3914 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{3915 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{3916 }
\DoxyCodeLine{3917 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3918 }
\DoxyCodeLine{3919     std::ostream\& cout();}
\DoxyCodeLine{3920     std::ostream\& cerr();}
\DoxyCodeLine{3921     std::ostream\& clog();}
\DoxyCodeLine{3922 }
\DoxyCodeLine{3923     \textcolor{keyword}{struct }IStream \{}
\DoxyCodeLine{3924         \textcolor{keyword}{virtual} \string~IStream() CATCH\_NOEXCEPT;}
\DoxyCodeLine{3925         virtual std::ostream\& stream() const = 0;}
\DoxyCodeLine{3926     \};}
\DoxyCodeLine{3927 }
\DoxyCodeLine{3928     class FileStream : public IStream \{}
\DoxyCodeLine{3929         \textcolor{keyword}{mutable} std::ofstream m\_ofs;}
\DoxyCodeLine{3930     \textcolor{keyword}{public}:}
\DoxyCodeLine{3931         FileStream( std::string \textcolor{keyword}{const}\& filename );}
\DoxyCodeLine{3932         \textcolor{keyword}{virtual} \string~FileStream() CATCH\_NOEXCEPT;}
\DoxyCodeLine{3933     public: \textcolor{comment}{// IStream}}
\DoxyCodeLine{3934         virtual std::ostream\& stream() const CATCH\_OVERRIDE;}
\DoxyCodeLine{3935     \};}
\DoxyCodeLine{3936 }
\DoxyCodeLine{3937     class CoutStream : public IStream \{}
\DoxyCodeLine{3938         \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{3939     \textcolor{keyword}{public}:}
\DoxyCodeLine{3940         CoutStream();}
\DoxyCodeLine{3941         \textcolor{keyword}{virtual} \string~CoutStream() CATCH\_NOEXCEPT;}
\DoxyCodeLine{3942 }
\DoxyCodeLine{3943     public: \textcolor{comment}{// IStream}}
\DoxyCodeLine{3944         virtual std::ostream\& stream() const CATCH\_OVERRIDE;}
\DoxyCodeLine{3945     \};}
\DoxyCodeLine{3946 }
\DoxyCodeLine{3947     class DebugOutStream : public IStream \{}
\DoxyCodeLine{3948         CATCH\_AUTO\_PTR( StreamBufBase ) m\_streamBuf;}
\DoxyCodeLine{3949         \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{3950     \textcolor{keyword}{public}:}
\DoxyCodeLine{3951         DebugOutStream();}
\DoxyCodeLine{3952         \textcolor{keyword}{virtual} \string~DebugOutStream() CATCH\_NOEXCEPT;}
\DoxyCodeLine{3953 }
\DoxyCodeLine{3954     public: \textcolor{comment}{// IStream}}
\DoxyCodeLine{3955         virtual std::ostream\& stream() const CATCH\_OVERRIDE;}
\DoxyCodeLine{3956     \};}
\DoxyCodeLine{3957 \}}
\DoxyCodeLine{3958 }
\DoxyCodeLine{3959 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{3960 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3961 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3962 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{3963 }
\DoxyCodeLine{3964 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{3965 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{3966 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3967 }
\DoxyCodeLine{3968 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3969 }
\DoxyCodeLine{3970     \textcolor{keyword}{struct }ConfigData \{}
\DoxyCodeLine{3971 }
\DoxyCodeLine{3972         ConfigData()}
\DoxyCodeLine{3973         :   listTests( false ),}
\DoxyCodeLine{3974             listTags( false ),}
\DoxyCodeLine{3975             listReporters( false ),}
\DoxyCodeLine{3976             listTestNamesOnly( false ),}
\DoxyCodeLine{3977             listExtraInfo( false ),}
\DoxyCodeLine{3978             showSuccessfulTests( false ),}
\DoxyCodeLine{3979             shouldDebugBreak( false ),}
\DoxyCodeLine{3980             noThrow( false ),}
\DoxyCodeLine{3981             showHelp( false ),}
\DoxyCodeLine{3982             showInvisibles( false ),}
\DoxyCodeLine{3983             filenamesAsTags( false ),}
\DoxyCodeLine{3984             libIdentify( false ),}
\DoxyCodeLine{3985             abortAfter( -\/1 ),}
\DoxyCodeLine{3986             rngSeed( 0 ),}
\DoxyCodeLine{3987             verbosity( Verbosity::Normal ),}
\DoxyCodeLine{3988             warnings( WarnAbout::Nothing ),}
\DoxyCodeLine{3989             showDurations( ShowDurations::DefaultForReporter ),}
\DoxyCodeLine{3990             runOrder( RunTests::InDeclarationOrder ),}
\DoxyCodeLine{3991             useColour( UseColour::Auto ),}
\DoxyCodeLine{3992             waitForKeypress( WaitForKeypress::Never )}
\DoxyCodeLine{3993         \{\}}
\DoxyCodeLine{3994 }
\DoxyCodeLine{3995         \textcolor{keywordtype}{bool} listTests;}
\DoxyCodeLine{3996         \textcolor{keywordtype}{bool} listTags;}
\DoxyCodeLine{3997         \textcolor{keywordtype}{bool} listReporters;}
\DoxyCodeLine{3998         \textcolor{keywordtype}{bool} listTestNamesOnly;}
\DoxyCodeLine{3999         \textcolor{keywordtype}{bool} listExtraInfo;}
\DoxyCodeLine{4000 }
\DoxyCodeLine{4001         \textcolor{keywordtype}{bool} showSuccessfulTests;}
\DoxyCodeLine{4002         \textcolor{keywordtype}{bool} shouldDebugBreak;}
\DoxyCodeLine{4003         \textcolor{keywordtype}{bool} noThrow;}
\DoxyCodeLine{4004         \textcolor{keywordtype}{bool} showHelp;}
\DoxyCodeLine{4005         \textcolor{keywordtype}{bool} showInvisibles;}
\DoxyCodeLine{4006         \textcolor{keywordtype}{bool} filenamesAsTags;}
\DoxyCodeLine{4007         \textcolor{keywordtype}{bool} libIdentify;}
\DoxyCodeLine{4008 }
\DoxyCodeLine{4009         \textcolor{keywordtype}{int} abortAfter;}
\DoxyCodeLine{4010         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed;}
\DoxyCodeLine{4011 }
\DoxyCodeLine{4012         Verbosity::Level verbosity;}
\DoxyCodeLine{4013         WarnAbout::What warnings;}
\DoxyCodeLine{4014         ShowDurations::OrNot showDurations;}
\DoxyCodeLine{4015         RunTests::InWhatOrder runOrder;}
\DoxyCodeLine{4016         UseColour::YesOrNo useColour;}
\DoxyCodeLine{4017         WaitForKeypress::When waitForKeypress;}
\DoxyCodeLine{4018 }
\DoxyCodeLine{4019         std::string outputFilename;}
\DoxyCodeLine{4020         std::string name;}
\DoxyCodeLine{4021         std::string processName;}
\DoxyCodeLine{4022 }
\DoxyCodeLine{4023         std::vector<std::string> reporterNames;}
\DoxyCodeLine{4024         std::vector<std::string> testsOrTags;}
\DoxyCodeLine{4025         std::vector<std::string> sectionsToRun;}
\DoxyCodeLine{4026     \};}
\DoxyCodeLine{4027 }
\DoxyCodeLine{4028     \textcolor{keyword}{class }Config : \textcolor{keyword}{public} SharedImpl<IConfig> \{}
\DoxyCodeLine{4029     \textcolor{keyword}{private}:}
\DoxyCodeLine{4030         Config( Config \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{4031         Config\& operator = ( Config \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{4032         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} dummy();}
\DoxyCodeLine{4033     \textcolor{keyword}{public}:}
\DoxyCodeLine{4034 }
\DoxyCodeLine{4035         Config()}
\DoxyCodeLine{4036         \{\}}
\DoxyCodeLine{4037 }
\DoxyCodeLine{4038         Config( ConfigData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{4039         :   m\_data( data ),}
\DoxyCodeLine{4040             m\_stream( openStream() )}
\DoxyCodeLine{4041         \{}
\DoxyCodeLine{4042             \textcolor{keywordflow}{if}( !data.testsOrTags.empty() ) \{}
\DoxyCodeLine{4043                 TestSpecParser parser( ITagAliasRegistry::get() );}
\DoxyCodeLine{4044                 \textcolor{keywordflow}{for}( std::size\_t i = 0; i < data.testsOrTags.size(); ++i )}
\DoxyCodeLine{4045                     parser.parse( data.testsOrTags[i] );}
\DoxyCodeLine{4046                 m\_testSpec = parser.testSpec();}
\DoxyCodeLine{4047             \}}
\DoxyCodeLine{4048         \}}
\DoxyCodeLine{4049 }
\DoxyCodeLine{4050         \textcolor{keyword}{virtual} \string~Config() \{\}}
\DoxyCodeLine{4051 }
\DoxyCodeLine{4052         std::string \textcolor{keyword}{const}\& getFilename()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4053             \textcolor{keywordflow}{return} m\_data.outputFilename ;}
\DoxyCodeLine{4054         \}}
\DoxyCodeLine{4055 }
\DoxyCodeLine{4056         \textcolor{keywordtype}{bool} listTests()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.listTests; \}}
\DoxyCodeLine{4057         \textcolor{keywordtype}{bool} listTestNamesOnly()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.listTestNamesOnly; \}}
\DoxyCodeLine{4058         \textcolor{keywordtype}{bool} listTags()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.listTags; \}}
\DoxyCodeLine{4059         \textcolor{keywordtype}{bool} listReporters()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.listReporters; \}}
\DoxyCodeLine{4060         \textcolor{keywordtype}{bool} listExtraInfo()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.listExtraInfo; \}}
\DoxyCodeLine{4061 }
\DoxyCodeLine{4062         std::string getProcessName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.processName; \}}
\DoxyCodeLine{4063 }
\DoxyCodeLine{4064         std::vector<std::string> \textcolor{keyword}{const}\& getReporterNames()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.reporterNames; \}}
\DoxyCodeLine{4065         std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} m\_data.sectionsToRun; \}}
\DoxyCodeLine{4066 }
\DoxyCodeLine{4067         \textcolor{keyword}{virtual} TestSpec \textcolor{keyword}{const}\& testSpec() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} m\_testSpec; \}}
\DoxyCodeLine{4068 }
\DoxyCodeLine{4069         \textcolor{keywordtype}{bool} showHelp()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showHelp; \}}
\DoxyCodeLine{4070 }
\DoxyCodeLine{4071         \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{4072         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} allowThrows() const CATCH\_OVERRIDE                 \{ \textcolor{keywordflow}{return} !m\_data.noThrow; \}}
\DoxyCodeLine{4073         \textcolor{keyword}{virtual} std::ostream\& stream() const CATCH\_OVERRIDE             \{ \textcolor{keywordflow}{return} m\_stream-\/>stream(); \}}
\DoxyCodeLine{4074         \textcolor{keyword}{virtual} std::string name() const CATCH\_OVERRIDE                 \{ \textcolor{keywordflow}{return} m\_data.name.empty() ? m\_data.processName : m\_data.name; \}}
\DoxyCodeLine{4075         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} includeSuccessfulResults() const CATCH\_OVERRIDE    \{ \textcolor{keywordflow}{return} m\_data.showSuccessfulTests; \}}
\DoxyCodeLine{4076         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutMissingAssertions() const CATCH\_OVERRIDE  \{ \textcolor{keywordflow}{return} m\_data.warnings \& WarnAbout::NoAssertions; \}}
\DoxyCodeLine{4077         \textcolor{keyword}{virtual} ShowDurations::OrNot showDurations() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} m\_data.showDurations; \}}
\DoxyCodeLine{4078         \textcolor{keyword}{virtual} RunTests::InWhatOrder runOrder() const CATCH\_OVERRIDE   \{ \textcolor{keywordflow}{return} m\_data.runOrder; \}}
\DoxyCodeLine{4079         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() const CATCH\_OVERRIDE             \{ \textcolor{keywordflow}{return} m\_data.rngSeed; \}}
\DoxyCodeLine{4080         \textcolor{keyword}{virtual} UseColour::YesOrNo useColour() const CATCH\_OVERRIDE     \{ \textcolor{keywordflow}{return} m\_data.useColour; \}}
\DoxyCodeLine{4081         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} shouldDebugBreak() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} m\_data.shouldDebugBreak; \}}
\DoxyCodeLine{4082         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} abortAfter() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} m\_data.abortAfter; \}}
\DoxyCodeLine{4083         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} showInvisibles() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} m\_data.showInvisibles; \}}
\DoxyCodeLine{4084 }
\DoxyCodeLine{4085     \textcolor{keyword}{private}:}
\DoxyCodeLine{4086 }
\DoxyCodeLine{4087         IStream \textcolor{keyword}{const}* openStream() \{}
\DoxyCodeLine{4088             \textcolor{keywordflow}{if}( m\_data.outputFilename.empty() )}
\DoxyCodeLine{4089                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} CoutStream();}
\DoxyCodeLine{4090             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( m\_data.outputFilename[0] == \textcolor{charliteral}{'\%'} ) \{}
\DoxyCodeLine{4091                 \textcolor{keywordflow}{if}( m\_data.outputFilename == \textcolor{stringliteral}{"{}\%debug"{}} )}
\DoxyCodeLine{4092                     \textcolor{keywordflow}{return} \textcolor{keyword}{new} DebugOutStream();}
\DoxyCodeLine{4093                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{4094                     \textcolor{keywordflow}{throw} std::domain\_error( \textcolor{stringliteral}{"{}Unrecognised stream: "{}} + m\_data.outputFilename );}
\DoxyCodeLine{4095             \}}
\DoxyCodeLine{4096             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4097                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} FileStream( m\_data.outputFilename );}
\DoxyCodeLine{4098         \}}
\DoxyCodeLine{4099         ConfigData m\_data;}
\DoxyCodeLine{4100 }
\DoxyCodeLine{4101         CATCH\_AUTO\_PTR( IStream \textcolor{keyword}{const} ) m\_stream;}
\DoxyCodeLine{4102         TestSpec m\_testSpec;}
\DoxyCodeLine{4103     \};}
\DoxyCodeLine{4104 }
\DoxyCodeLine{4105 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{4106 }
\DoxyCodeLine{4107 \textcolor{comment}{// \#included from: catch\_clara.h}}
\DoxyCodeLine{4108 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_CLARA\_H\_INCLUDED}}
\DoxyCodeLine{4109 }
\DoxyCodeLine{4110 \textcolor{comment}{// Use Catch's value for console width (store Clara's off to the side, if present)}}
\DoxyCodeLine{4111 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{4112 \textcolor{preprocessor}{\#define CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{4113 \textcolor{preprocessor}{\#undef CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{4114 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4115 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_CONSOLE\_WIDTH CATCH\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{4116 }
\DoxyCodeLine{4117 \textcolor{comment}{// Declare Clara inside the Catch namespace}}
\DoxyCodeLine{4118 \textcolor{preprocessor}{\#define STITCH\_CLARA\_OPEN\_NAMESPACE namespace Catch \{}}
\DoxyCodeLine{4119 \textcolor{comment}{// \#included from: ../external/clara.h}}
\DoxyCodeLine{4120 }
\DoxyCodeLine{4121 \textcolor{comment}{// Version 0.0.2.4}}
\DoxyCodeLine{4122 }
\DoxyCodeLine{4123 \textcolor{comment}{// Only use header guard if we are not using an outer namespace}}
\DoxyCodeLine{4124 \textcolor{preprocessor}{\#if !defined(TWOBLUECUBES\_CLARA\_H\_INCLUDED) || defined(STITCH\_CLARA\_OPEN\_NAMESPACE)}}
\DoxyCodeLine{4125 }
\DoxyCodeLine{4126 \textcolor{preprocessor}{\#ifndef STITCH\_CLARA\_OPEN\_NAMESPACE}}
\DoxyCodeLine{4127 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CLARA\_H\_INCLUDED}}
\DoxyCodeLine{4128 \textcolor{preprocessor}{\#define STITCH\_CLARA\_OPEN\_NAMESPACE}}
\DoxyCodeLine{4129 \textcolor{preprocessor}{\#define STITCH\_CLARA\_CLOSE\_NAMESPACE}}
\DoxyCodeLine{4130 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4131 \textcolor{preprocessor}{\#define STITCH\_CLARA\_CLOSE\_NAMESPACE \}}}
\DoxyCodeLine{4132 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4133 }
\DoxyCodeLine{4134 \textcolor{preprocessor}{\#define STITCH\_TBC\_TEXT\_FORMAT\_OPEN\_NAMESPACE STITCH\_CLARA\_OPEN\_NAMESPACE}}
\DoxyCodeLine{4135 }
\DoxyCodeLine{4136 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ \#included from tbc\_text\_format.h -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{4137 }
\DoxyCodeLine{4138 \textcolor{comment}{// Only use header guard if we are not using an outer namespace}}
\DoxyCodeLine{4139 \textcolor{preprocessor}{\#if !defined(TBC\_TEXT\_FORMAT\_H\_INCLUDED) || defined(STITCH\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE)}}
\DoxyCodeLine{4140 \textcolor{preprocessor}{\#ifndef STITCH\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE}}
\DoxyCodeLine{4141 \textcolor{preprocessor}{\#define TBC\_TEXT\_FORMAT\_H\_INCLUDED}}
\DoxyCodeLine{4142 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4143 }
\DoxyCodeLine{4144 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4145 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4146 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{4147 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{4148 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{4149 }
\DoxyCodeLine{4150 \textcolor{comment}{// Use optional outer namespace}}
\DoxyCodeLine{4151 \textcolor{preprocessor}{\#ifdef STITCH\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE}}
\DoxyCodeLine{4152 \textcolor{keyword}{namespace }STITCH\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE \{}
\DoxyCodeLine{4153 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4154 }
\DoxyCodeLine{4155 \textcolor{keyword}{namespace }Tbc \{}
\DoxyCodeLine{4156 }
\DoxyCodeLine{4157 \textcolor{preprocessor}{\#ifdef TBC\_TEXT\_FORMAT\_CONSOLE\_WIDTH}}
\DoxyCodeLine{4158     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} consoleWidth = TBC\_TEXT\_FORMAT\_CONSOLE\_WIDTH;}
\DoxyCodeLine{4159 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4160     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} consoleWidth = 80;}
\DoxyCodeLine{4161 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4162 }
\DoxyCodeLine{4163     \textcolor{keyword}{struct }TextAttributes \{}
\DoxyCodeLine{4164         TextAttributes()}
\DoxyCodeLine{4165         :   initialIndent( std::string::npos ),}
\DoxyCodeLine{4166             indent( 0 ),}
\DoxyCodeLine{4167             width( consoleWidth-\/1 ),}
\DoxyCodeLine{4168             tabChar( \textcolor{stringliteral}{'\(\backslash\)t'} )}
\DoxyCodeLine{4169         \{\}}
\DoxyCodeLine{4170 }
\DoxyCodeLine{4171         TextAttributes\& setInitialIndent( std::size\_t \_value )  \{ initialIndent = \_value; \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{4172         TextAttributes\& setIndent( std::size\_t \_value )         \{ indent = \_value; \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{4173         TextAttributes\& setWidth( std::size\_t \_value )          \{ width = \_value; \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{4174         TextAttributes\& setTabChar( \textcolor{keywordtype}{char} \_value )               \{ tabChar = \_value; \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{4175 }
\DoxyCodeLine{4176         std::size\_t initialIndent;  \textcolor{comment}{// indent of first line, or npos}}
\DoxyCodeLine{4177         std::size\_t indent;         \textcolor{comment}{// indent of subsequent lines, or all if initialIndent is npos}}
\DoxyCodeLine{4178         std::size\_t width;          \textcolor{comment}{// maximum width of text, including indent. Longer text will wrap}}
\DoxyCodeLine{4179         \textcolor{keywordtype}{char} tabChar;               \textcolor{comment}{// If this char is seen the indent is changed to current pos}}
\DoxyCodeLine{4180     \};}
\DoxyCodeLine{4181 }
\DoxyCodeLine{4182     \textcolor{keyword}{class }Text \{}
\DoxyCodeLine{4183     \textcolor{keyword}{public}:}
\DoxyCodeLine{4184         Text( std::string \textcolor{keyword}{const}\& \_str, TextAttributes \textcolor{keyword}{const}\& \_attr = TextAttributes() )}
\DoxyCodeLine{4185         : attr( \_attr )}
\DoxyCodeLine{4186         \{}
\DoxyCodeLine{4187             std::string wrappableChars = \textcolor{stringliteral}{"{} [(\{.,/|\(\backslash\)\(\backslash\)-\/"{}};}
\DoxyCodeLine{4188             std::size\_t indent = \_attr.initialIndent != std::string::npos}
\DoxyCodeLine{4189                 ? \_attr.initialIndent}
\DoxyCodeLine{4190                 : \_attr.indent;}
\DoxyCodeLine{4191             std::string remainder = \_str;}
\DoxyCodeLine{4192 }
\DoxyCodeLine{4193             \textcolor{keywordflow}{while}( !remainder.empty() ) \{}
\DoxyCodeLine{4194                 \textcolor{keywordflow}{if}( lines.size() >= 1000 ) \{}
\DoxyCodeLine{4195                     lines.push\_back( \textcolor{stringliteral}{"{}... message truncated due to excessive size"{}} );}
\DoxyCodeLine{4196                     \textcolor{keywordflow}{return};}
\DoxyCodeLine{4197                 \}}
\DoxyCodeLine{4198                 std::size\_t tabPos = std::string::npos;}
\DoxyCodeLine{4199                 std::size\_t width = (std::min)( remainder.size(), \_attr.width -\/ indent );}
\DoxyCodeLine{4200                 std::size\_t pos = remainder.find\_first\_of( \textcolor{charliteral}{'\(\backslash\)n'} );}
\DoxyCodeLine{4201                 \textcolor{keywordflow}{if}( pos <= width ) \{}
\DoxyCodeLine{4202                     width = pos;}
\DoxyCodeLine{4203                 \}}
\DoxyCodeLine{4204                 pos = remainder.find\_last\_of( \_attr.tabChar, width );}
\DoxyCodeLine{4205                 \textcolor{keywordflow}{if}( pos != std::string::npos ) \{}
\DoxyCodeLine{4206                     tabPos = pos;}
\DoxyCodeLine{4207                     \textcolor{keywordflow}{if}( remainder[width] == \textcolor{charliteral}{'\(\backslash\)n'} )}
\DoxyCodeLine{4208                         width-\/-\/;}
\DoxyCodeLine{4209                     remainder = remainder.substr( 0, tabPos ) + remainder.substr( tabPos+1 );}
\DoxyCodeLine{4210                 \}}
\DoxyCodeLine{4211 }
\DoxyCodeLine{4212                 \textcolor{keywordflow}{if}( width == remainder.size() ) \{}
\DoxyCodeLine{4213                     spliceLine( indent, remainder, width );}
\DoxyCodeLine{4214                 \}}
\DoxyCodeLine{4215                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( remainder[width] == \textcolor{charliteral}{'\(\backslash\)n'} ) \{}
\DoxyCodeLine{4216                     spliceLine( indent, remainder, width );}
\DoxyCodeLine{4217                     \textcolor{keywordflow}{if}( width <= 1 || remainder.size() != 1 )}
\DoxyCodeLine{4218                         remainder = remainder.substr( 1 );}
\DoxyCodeLine{4219                     indent = \_attr.indent;}
\DoxyCodeLine{4220                 \}}
\DoxyCodeLine{4221                 \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4222                     pos = remainder.find\_last\_of( wrappableChars, width );}
\DoxyCodeLine{4223                     \textcolor{keywordflow}{if}( pos != std::string::npos \&\& pos > 0 ) \{}
\DoxyCodeLine{4224                         spliceLine( indent, remainder, pos );}
\DoxyCodeLine{4225                         \textcolor{keywordflow}{if}( remainder[0] == \textcolor{charliteral}{' '} )}
\DoxyCodeLine{4226                             remainder = remainder.substr( 1 );}
\DoxyCodeLine{4227                     \}}
\DoxyCodeLine{4228                     \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4229                         spliceLine( indent, remainder, width-\/1 );}
\DoxyCodeLine{4230                         lines.back() += "{}-\/"{};}
\DoxyCodeLine{4231                     \}}
\DoxyCodeLine{4232                     \textcolor{keywordflow}{if}( lines.size() == 1 )}
\DoxyCodeLine{4233                         indent = \_attr.indent;}
\DoxyCodeLine{4234                     \textcolor{keywordflow}{if}( tabPos != std::string::npos )}
\DoxyCodeLine{4235                         indent += tabPos;}
\DoxyCodeLine{4236                 \}}
\DoxyCodeLine{4237             \}}
\DoxyCodeLine{4238         \}}
\DoxyCodeLine{4239 }
\DoxyCodeLine{4240         \textcolor{keywordtype}{void} spliceLine( std::size\_t \_indent, std::string\& \_remainder, std::size\_t \_pos ) \{}
\DoxyCodeLine{4241             lines.push\_back( std::string( \_indent, \textcolor{charliteral}{' '} ) + \_remainder.substr( 0, \_pos ) );}
\DoxyCodeLine{4242             \_remainder = \_remainder.substr( \_pos );}
\DoxyCodeLine{4243         \}}
\DoxyCodeLine{4244 }
\DoxyCodeLine{4245         \textcolor{keyword}{typedef} std::vector<std::string>::const\_iterator const\_iterator;}
\DoxyCodeLine{4246 }
\DoxyCodeLine{4247         const\_iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines.begin(); \}}
\DoxyCodeLine{4248         const\_iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines.end(); \}}
\DoxyCodeLine{4249         std::string \textcolor{keyword}{const}\& last()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines.back(); \}}
\DoxyCodeLine{4250         std::size\_t size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines.size(); \}}
\DoxyCodeLine{4251         std::string \textcolor{keyword}{const}\& operator[]( std::size\_t \_index )\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines[\_index]; \}}
\DoxyCodeLine{4252         std::string toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4253             std::ostringstream oss;}
\DoxyCodeLine{4254             oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{4255             \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{4256         \}}
\DoxyCodeLine{4257 }
\DoxyCodeLine{4258         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& \_stream, Text \textcolor{keyword}{const}\& \_text ) \{}
\DoxyCodeLine{4259             \textcolor{keywordflow}{for}( Text::const\_iterator it = \_text.begin(), itEnd = \_text.end();}
\DoxyCodeLine{4260                 it != itEnd; ++it ) \{}
\DoxyCodeLine{4261                 \textcolor{keywordflow}{if}( it != \_text.begin() )}
\DoxyCodeLine{4262                     \_stream << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{4263                 \_stream << *it;}
\DoxyCodeLine{4264             \}}
\DoxyCodeLine{4265             \textcolor{keywordflow}{return} \_stream;}
\DoxyCodeLine{4266         \}}
\DoxyCodeLine{4267 }
\DoxyCodeLine{4268     \textcolor{keyword}{private}:}
\DoxyCodeLine{4269         std::string str;}
\DoxyCodeLine{4270         TextAttributes attr;}
\DoxyCodeLine{4271         std::vector<std::string> lines;}
\DoxyCodeLine{4272     \};}
\DoxyCodeLine{4273 }
\DoxyCodeLine{4274 \} \textcolor{comment}{// end namespace Tbc}}
\DoxyCodeLine{4275 }
\DoxyCodeLine{4276 \textcolor{preprocessor}{\#ifdef STITCH\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE}}
\DoxyCodeLine{4277 \} \textcolor{comment}{// end outer namespace}}
\DoxyCodeLine{4278 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4279 }
\DoxyCodeLine{4280 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TBC\_TEXT\_FORMAT\_H\_INCLUDED}}
\DoxyCodeLine{4281 }
\DoxyCodeLine{4282 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ end of \#include from tbc\_text\_format.h -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{4283 \textcolor{comment}{// ........... back in clara.h}}
\DoxyCodeLine{4284 }
\DoxyCodeLine{4285 \textcolor{preprocessor}{\#undef STITCH\_TBC\_TEXT\_FORMAT\_OPEN\_NAMESPACE}}
\DoxyCodeLine{4286 }
\DoxyCodeLine{4287 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ \#included from clara\_compilers.h -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{4288 }
\DoxyCodeLine{4289 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_CLARA\_COMPILERS\_H\_INCLUDED}}
\DoxyCodeLine{4290 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CLARA\_COMPILERS\_H\_INCLUDED}}
\DoxyCodeLine{4291 }
\DoxyCodeLine{4292 \textcolor{comment}{// Detect a number of compiler features -\/ mostly C++11/14 conformance -\/ by compiler}}
\DoxyCodeLine{4293 \textcolor{comment}{// The following features are defined:}}
\DoxyCodeLine{4294 \textcolor{comment}{//}}
\DoxyCodeLine{4295 \textcolor{comment}{// CLARA\_CONFIG\_CPP11\_NULLPTR : is nullptr supported?}}
\DoxyCodeLine{4296 \textcolor{comment}{// CLARA\_CONFIG\_CPP11\_NOEXCEPT : is noexcept supported?}}
\DoxyCodeLine{4297 \textcolor{comment}{// CLARA\_CONFIG\_CPP11\_GENERATED\_METHODS : The delete and default keywords for compiler generated methods}}
\DoxyCodeLine{4298 \textcolor{comment}{// CLARA\_CONFIG\_CPP11\_OVERRIDE : is override supported?}}
\DoxyCodeLine{4299 \textcolor{comment}{// CLARA\_CONFIG\_CPP11\_UNIQUE\_PTR : is unique\_ptr supported (otherwise use auto\_ptr)}}
\DoxyCodeLine{4300 }
\DoxyCodeLine{4301 \textcolor{comment}{// CLARA\_CONFIG\_CPP11\_OR\_GREATER : Is C++11 supported?}}
\DoxyCodeLine{4302 }
\DoxyCodeLine{4303 \textcolor{comment}{// CLARA\_CONFIG\_VARIADIC\_MACROS : are variadic macros supported?}}
\DoxyCodeLine{4304 }
\DoxyCodeLine{4305 \textcolor{comment}{// In general each macro has a \_NO\_<feature name> form}}
\DoxyCodeLine{4306 \textcolor{comment}{// (e.g. CLARA\_CONFIG\_CPP11\_NO\_NULLPTR) which disables the feature.}}
\DoxyCodeLine{4307 \textcolor{comment}{// Many features, at point of detection, define an \_INTERNAL\_ macro, so they}}
\DoxyCodeLine{4308 \textcolor{comment}{// can be combined, en-\/mass, with the \_NO\_ forms later.}}
\DoxyCodeLine{4309 }
\DoxyCodeLine{4310 \textcolor{comment}{// All the C++11 features can be disabled with CLARA\_CONFIG\_NO\_CPP11}}
\DoxyCodeLine{4311 }
\DoxyCodeLine{4312 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{4313 }
\DoxyCodeLine{4314 \textcolor{preprocessor}{\#if \_\_has\_feature(cxx\_nullptr)}}
\DoxyCodeLine{4315 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{4316 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4317 }
\DoxyCodeLine{4318 \textcolor{preprocessor}{\#if \_\_has\_feature(cxx\_noexcept)}}
\DoxyCodeLine{4319 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{4320 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4321 }
\DoxyCodeLine{4322 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_clang\_\_}}
\DoxyCodeLine{4323 }
\DoxyCodeLine{4325 \textcolor{comment}{// GCC}}
\DoxyCodeLine{4326 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{4327 }
\DoxyCodeLine{4328 \textcolor{preprocessor}{\#if \_\_GNUC\_\_ == 4 \&\& \_\_GNUC\_MINOR\_\_ >= 6 \&\& defined(\_\_GXX\_EXPERIMENTAL\_CXX0X\_\_)}}
\DoxyCodeLine{4329 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{4330 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4331 }
\DoxyCodeLine{4332 \textcolor{comment}{// -\/ otherwise more recent versions define \_\_cplusplus >= 201103L}}
\DoxyCodeLine{4333 \textcolor{comment}{// and will get picked up below}}
\DoxyCodeLine{4334 }
\DoxyCodeLine{4335 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_GNUC\_\_}}
\DoxyCodeLine{4336 }
\DoxyCodeLine{4338 \textcolor{comment}{// Visual C++}}
\DoxyCodeLine{4339 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{4340 }
\DoxyCodeLine{4341 \textcolor{preprocessor}{\#if (\_MSC\_VER >= 1600)}}
\DoxyCodeLine{4342 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{4343 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_UNIQUE\_PTR}}
\DoxyCodeLine{4344 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4345 }
\DoxyCodeLine{4346 \textcolor{preprocessor}{\#if (\_MSC\_VER >= 1900 ) }\textcolor{comment}{// (VC++ 13 (VS2015))}}
\DoxyCodeLine{4347 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{4348 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{4349 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4350 }
\DoxyCodeLine{4351 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{4352 }
\DoxyCodeLine{4354 \textcolor{comment}{// C++ language feature support}}
\DoxyCodeLine{4355 }
\DoxyCodeLine{4356 \textcolor{comment}{// catch all support for C++11}}
\DoxyCodeLine{4357 \textcolor{preprocessor}{\#if defined(\_\_cplusplus) \&\& \_\_cplusplus >= 201103L}}
\DoxyCodeLine{4358 }
\DoxyCodeLine{4359 \textcolor{preprocessor}{\#define CLARA\_CPP11\_OR\_GREATER}}
\DoxyCodeLine{4360 }
\DoxyCodeLine{4361 \textcolor{preprocessor}{\#if !defined(CLARA\_INTERNAL\_CONFIG\_CPP11\_NULLPTR)}}
\DoxyCodeLine{4362 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{4363 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4364 }
\DoxyCodeLine{4365 \textcolor{preprocessor}{\#ifndef CLARA\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{4366 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{4367 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4368 }
\DoxyCodeLine{4369 \textcolor{preprocessor}{\#ifndef CLARA\_INTERNAL\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{4370 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{4371 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4372 }
\DoxyCodeLine{4373 \textcolor{preprocessor}{\#if !defined(CLARA\_INTERNAL\_CONFIG\_CPP11\_OVERRIDE)}}
\DoxyCodeLine{4374 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_OVERRIDE}}
\DoxyCodeLine{4375 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4376 \textcolor{preprocessor}{\#if !defined(CLARA\_INTERNAL\_CONFIG\_CPP11\_UNIQUE\_PTR)}}
\DoxyCodeLine{4377 \textcolor{preprocessor}{\#define CLARA\_INTERNAL\_CONFIG\_CPP11\_UNIQUE\_PTR}}
\DoxyCodeLine{4378 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4379 }
\DoxyCodeLine{4380 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_cplusplus >= 201103L}}
\DoxyCodeLine{4381 }
\DoxyCodeLine{4382 \textcolor{comment}{// Now set the actual defines based on the above + anything the user has configured}}
\DoxyCodeLine{4383 \textcolor{preprocessor}{\#if defined(CLARA\_INTERNAL\_CONFIG\_CPP11\_NULLPTR) \&\& !defined(CLARA\_CONFIG\_CPP11\_NO\_NULLPTR) \&\& !defined(CLARA\_CONFIG\_CPP11\_NULLPTR) \&\& !defined(CLARA\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{4384 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{4385 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4386 \textcolor{preprocessor}{\#if defined(CLARA\_INTERNAL\_CONFIG\_CPP11\_NOEXCEPT) \&\& !defined(CLARA\_CONFIG\_CPP11\_NO\_NOEXCEPT) \&\& !defined(CLARA\_CONFIG\_CPP11\_NOEXCEPT) \&\& !defined(CLARA\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{4387 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_CPP11\_NOEXCEPT}}
\DoxyCodeLine{4388 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4389 \textcolor{preprocessor}{\#if defined(CLARA\_INTERNAL\_CONFIG\_CPP11\_GENERATED\_METHODS) \&\& !defined(CLARA\_CONFIG\_CPP11\_NO\_GENERATED\_METHODS) \&\& !defined(CLARA\_CONFIG\_CPP11\_GENERATED\_METHODS) \&\& !defined(CLARA\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{4390 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{4391 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4392 \textcolor{preprocessor}{\#if defined(CLARA\_INTERNAL\_CONFIG\_CPP11\_OVERRIDE) \&\& !defined(CLARA\_CONFIG\_NO\_OVERRIDE) \&\& !defined(CLARA\_CONFIG\_CPP11\_OVERRIDE) \&\& !defined(CLARA\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{4393 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_CPP11\_OVERRIDE}}
\DoxyCodeLine{4394 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4395 \textcolor{preprocessor}{\#if defined(CLARA\_INTERNAL\_CONFIG\_CPP11\_UNIQUE\_PTR) \&\& !defined(CLARA\_CONFIG\_NO\_UNIQUE\_PTR) \&\& !defined(CLARA\_CONFIG\_CPP11\_UNIQUE\_PTR) \&\& !defined(CLARA\_CONFIG\_NO\_CPP11)}}
\DoxyCodeLine{4396 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_CPP11\_UNIQUE\_PTR}}
\DoxyCodeLine{4397 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4398 }
\DoxyCodeLine{4399 \textcolor{comment}{// noexcept support:}}
\DoxyCodeLine{4400 \textcolor{preprocessor}{\#if defined(CLARA\_CONFIG\_CPP11\_NOEXCEPT) \&\& !defined(CLARA\_NOEXCEPT)}}
\DoxyCodeLine{4401 \textcolor{preprocessor}{\#define CLARA\_NOEXCEPT noexcept}}
\DoxyCodeLine{4402 \textcolor{preprocessor}{\#  define CLARA\_NOEXCEPT\_IS(x) noexcept(x)}}
\DoxyCodeLine{4403 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4404 \textcolor{preprocessor}{\#define CLARA\_NOEXCEPT throw()}}
\DoxyCodeLine{4405 \textcolor{preprocessor}{\#  define CLARA\_NOEXCEPT\_IS(x)}}
\DoxyCodeLine{4406 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4407 }
\DoxyCodeLine{4408 \textcolor{comment}{// nullptr support}}
\DoxyCodeLine{4409 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{4410 \textcolor{preprocessor}{\#define CLARA\_NULL nullptr}}
\DoxyCodeLine{4411 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4412 \textcolor{preprocessor}{\#define CLARA\_NULL NULL}}
\DoxyCodeLine{4413 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4414 }
\DoxyCodeLine{4415 \textcolor{comment}{// override support}}
\DoxyCodeLine{4416 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CPP11\_OVERRIDE}}
\DoxyCodeLine{4417 \textcolor{preprocessor}{\#define CLARA\_OVERRIDE override}}
\DoxyCodeLine{4418 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4419 \textcolor{preprocessor}{\#define CLARA\_OVERRIDE}}
\DoxyCodeLine{4420 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4421 }
\DoxyCodeLine{4422 \textcolor{comment}{// unique\_ptr support}}
\DoxyCodeLine{4423 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CPP11\_UNIQUE\_PTR}}
\DoxyCodeLine{4424 \textcolor{preprocessor}{\#   define CLARA\_AUTO\_PTR( T ) std::unique\_ptr<T>}}
\DoxyCodeLine{4425 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4426 \textcolor{preprocessor}{\#   define CLARA\_AUTO\_PTR( T ) std::auto\_ptr<T>}}
\DoxyCodeLine{4427 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4428 }
\DoxyCodeLine{4429 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_CLARA\_COMPILERS\_H\_INCLUDED}}
\DoxyCodeLine{4430 }
\DoxyCodeLine{4431 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ end of \#include from clara\_compilers.h -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{4432 \textcolor{comment}{// ........... back in clara.h}}
\DoxyCodeLine{4433 }
\DoxyCodeLine{4434 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{4435 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{4436 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4437 }
\DoxyCodeLine{4438 \textcolor{preprocessor}{\#if defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER)}}
\DoxyCodeLine{4439 \textcolor{preprocessor}{\#define CLARA\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{4440 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4441 }
\DoxyCodeLine{4442 \textcolor{comment}{// Use optional outer namespace}}
\DoxyCodeLine{4443 \textcolor{preprocessor}{\#ifdef STITCH\_CLARA\_OPEN\_NAMESPACE}}
\DoxyCodeLine{4444 STITCH\_CLARA\_OPEN\_NAMESPACE}
\DoxyCodeLine{4445 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4446 }
\DoxyCodeLine{4447 \textcolor{keyword}{namespace }Clara \{}
\DoxyCodeLine{4448 }
\DoxyCodeLine{4449     \textcolor{keyword}{struct }UnpositionalTag \{\};}
\DoxyCodeLine{4450 }
\DoxyCodeLine{4451     \textcolor{keyword}{extern} UnpositionalTag \_;}
\DoxyCodeLine{4452 }
\DoxyCodeLine{4453 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{4454     UnpositionalTag \_;}
\DoxyCodeLine{4455 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4456 }
\DoxyCodeLine{4457     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{4458 }
\DoxyCodeLine{4459 \textcolor{preprocessor}{\#ifdef CLARA\_CONSOLE\_WIDTH}}
\DoxyCodeLine{4460     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} consoleWidth = CLARA\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{4461 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4462     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} consoleWidth = 80;}
\DoxyCodeLine{4463 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4464 }
\DoxyCodeLine{4465         \textcolor{keyword}{using namespace }Tbc;}
\DoxyCodeLine{4466 }
\DoxyCodeLine{4467         \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& str, std::string \textcolor{keyword}{const}\& prefix ) \{}
\DoxyCodeLine{4468             \textcolor{keywordflow}{return} str.size() >= prefix.size() \&\& str.substr( 0, prefix.size() ) == prefix;}
\DoxyCodeLine{4469         \}}
\DoxyCodeLine{4470 }
\DoxyCodeLine{4471         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }RemoveConstRef\{ \textcolor{keyword}{typedef} T type; \};}
\DoxyCodeLine{4472         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }RemoveConstRef<T\&>\{ \textcolor{keyword}{typedef} T type; \};}
\DoxyCodeLine{4473         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }RemoveConstRef<T const\&>\{ \textcolor{keyword}{typedef} T type; \};}
\DoxyCodeLine{4474         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }RemoveConstRef<T const>\{ \textcolor{keyword}{typedef} T type; \};}
\DoxyCodeLine{4475 }
\DoxyCodeLine{4476         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>    \textcolor{keyword}{struct }IsBool       \{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false}; \};}
\DoxyCodeLine{4477         \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }IsBool<bool> \{ \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{true}; \};}
\DoxyCodeLine{4478 }
\DoxyCodeLine{4479         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4480         \textcolor{keywordtype}{void} convertInto( std::string \textcolor{keyword}{const}\& \_source, T\& \_dest ) \{}
\DoxyCodeLine{4481             std::stringstream ss;}
\DoxyCodeLine{4482             ss << \_source;}
\DoxyCodeLine{4483             ss >> \_dest;}
\DoxyCodeLine{4484             \textcolor{keywordflow}{if}( ss.fail() )}
\DoxyCodeLine{4485                 \textcolor{keywordflow}{throw} std::runtime\_error( \textcolor{stringliteral}{"{}Unable to convert "{}} + \_source + \textcolor{stringliteral}{"{} to destination type"{}} );}
\DoxyCodeLine{4486         \}}
\DoxyCodeLine{4487         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} convertInto( std::string \textcolor{keyword}{const}\& \_source, std::string\& \_dest ) \{}
\DoxyCodeLine{4488             \_dest = \_source;}
\DoxyCodeLine{4489         \}}
\DoxyCodeLine{4490         \textcolor{keywordtype}{char} toLowerCh(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{4491             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( std::tolower( c ) );}
\DoxyCodeLine{4492         \}}
\DoxyCodeLine{4493         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} convertInto( std::string \textcolor{keyword}{const}\& \_source, \textcolor{keywordtype}{bool}\& \_dest ) \{}
\DoxyCodeLine{4494             std::string sourceLC = \_source;}
\DoxyCodeLine{4495             std::transform( sourceLC.begin(), sourceLC.end(), sourceLC.begin(), toLowerCh );}
\DoxyCodeLine{4496             \textcolor{keywordflow}{if}( sourceLC == \textcolor{stringliteral}{"{}y"{}} || sourceLC == \textcolor{stringliteral}{"{}1"{}} || sourceLC == \textcolor{stringliteral}{"{}true"{}} || sourceLC == \textcolor{stringliteral}{"{}yes"{}} || sourceLC == \textcolor{stringliteral}{"{}on"{}} )}
\DoxyCodeLine{4497                 \_dest = \textcolor{keyword}{true};}
\DoxyCodeLine{4498             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( sourceLC == \textcolor{stringliteral}{"{}n"{}} || sourceLC == \textcolor{stringliteral}{"{}0"{}} || sourceLC == \textcolor{stringliteral}{"{}false"{}} || sourceLC == \textcolor{stringliteral}{"{}no"{}} || sourceLC == \textcolor{stringliteral}{"{}off"{}} )}
\DoxyCodeLine{4499                 \_dest = \textcolor{keyword}{false};}
\DoxyCodeLine{4500             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4501                 \textcolor{keywordflow}{throw} std::runtime\_error( \textcolor{stringliteral}{"{}Expected a boolean value but did not recognise:\(\backslash\)n  '"{}} + \_source + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{4502         \}}
\DoxyCodeLine{4503 }
\DoxyCodeLine{4504         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ConfigT>}
\DoxyCodeLine{4505         \textcolor{keyword}{struct }IArgFunction \{}
\DoxyCodeLine{4506             \textcolor{keyword}{virtual} \string~IArgFunction() \{\}}
\DoxyCodeLine{4507 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{4508             IArgFunction()                      = \textcolor{keywordflow}{default};}
\DoxyCodeLine{4509             IArgFunction( IArgFunction \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{4510 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4511             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} set( ConfigT\& config, std::string \textcolor{keyword}{const}\& value ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4512             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} takesArg() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4513             \textcolor{keyword}{virtual} IArgFunction* clone() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4514         \};}
\DoxyCodeLine{4515 }
\DoxyCodeLine{4516         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ConfigT>}
\DoxyCodeLine{4517         \textcolor{keyword}{class }BoundArgFunction \{}
\DoxyCodeLine{4518         \textcolor{keyword}{public}:}
\DoxyCodeLine{4519             BoundArgFunction() : functionObj( CLARA\_NULL ) \{\}}
\DoxyCodeLine{4520             BoundArgFunction( IArgFunction<ConfigT>* \_functionObj ) : functionObj( \_functionObj ) \{\}}
\DoxyCodeLine{4521             BoundArgFunction( BoundArgFunction \textcolor{keyword}{const}\& other ) : functionObj( other.functionObj ? other.functionObj-\/>clone() : CLARA\_NULL ) \{\}}
\DoxyCodeLine{4522             BoundArgFunction\& operator = ( BoundArgFunction \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{4523                 IArgFunction<ConfigT>* newFunctionObj = other.functionObj ? other.functionObj-\/>clone() : CLARA\_NULL;}
\DoxyCodeLine{4524                 \textcolor{keyword}{delete} functionObj;}
\DoxyCodeLine{4525                 functionObj = newFunctionObj;}
\DoxyCodeLine{4526                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4527             \}}
\DoxyCodeLine{4528             \string~BoundArgFunction() \{ \textcolor{keyword}{delete} functionObj; \}}
\DoxyCodeLine{4529 }
\DoxyCodeLine{4530             \textcolor{keywordtype}{void} set( ConfigT\& config, std::string \textcolor{keyword}{const}\& value )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4531                 functionObj-\/>set( config, value );}
\DoxyCodeLine{4532             \}}
\DoxyCodeLine{4533             \textcolor{keywordtype}{bool} takesArg()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} functionObj-\/>takesArg(); \}}
\DoxyCodeLine{4534 }
\DoxyCodeLine{4535             \textcolor{keywordtype}{bool} isSet()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4536                 \textcolor{keywordflow}{return} functionObj != CLARA\_NULL;}
\DoxyCodeLine{4537             \}}
\DoxyCodeLine{4538         \textcolor{keyword}{private}:}
\DoxyCodeLine{4539             IArgFunction<ConfigT>* functionObj;}
\DoxyCodeLine{4540         \};}
\DoxyCodeLine{4541 }
\DoxyCodeLine{4542         \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{4543         \textcolor{keyword}{struct }NullBinder : IArgFunction<C>\{}
\DoxyCodeLine{4544             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} set( C\&, std::string \textcolor{keyword}{const}\& )\textcolor{keyword}{ const }\{\}}
\DoxyCodeLine{4545             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} takesArg()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{4546             \textcolor{keyword}{virtual} IArgFunction<C>* clone()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} NullBinder( *\textcolor{keyword}{this} ); \}}
\DoxyCodeLine{4547         \};}
\DoxyCodeLine{4548 }
\DoxyCodeLine{4549         \textcolor{keyword}{template}<\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4550         \textcolor{keyword}{struct }BoundDataMember : IArgFunction<C>\{}
\DoxyCodeLine{4551             BoundDataMember( M C::* \_member ) : member( \_member ) \{\}}
\DoxyCodeLine{4552             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} set( C\& p, std::string \textcolor{keyword}{const}\& stringValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4553                 convertInto( stringValue, p.*member );}
\DoxyCodeLine{4554             \}}
\DoxyCodeLine{4555             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} takesArg()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !IsBool<M>::value; \}}
\DoxyCodeLine{4556             \textcolor{keyword}{virtual} IArgFunction<C>* clone()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} BoundDataMember( *\textcolor{keyword}{this} ); \}}
\DoxyCodeLine{4557             M C::* member;}
\DoxyCodeLine{4558         \};}
\DoxyCodeLine{4559         \textcolor{keyword}{template}<\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4560         \textcolor{keyword}{struct }BoundUnaryMethod : IArgFunction<C>\{}
\DoxyCodeLine{4561             BoundUnaryMethod( \textcolor{keywordtype}{void} (C::*\_member)( M ) ) : member( \_member ) \{\}}
\DoxyCodeLine{4562             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} set( C\& p, std::string \textcolor{keyword}{const}\& stringValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4563                 \textcolor{keyword}{typename} RemoveConstRef<M>::type value;}
\DoxyCodeLine{4564                 convertInto( stringValue, value );}
\DoxyCodeLine{4565                 (p.*member)( value );}
\DoxyCodeLine{4566             \}}
\DoxyCodeLine{4567             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} takesArg()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !IsBool<M>::value; \}}
\DoxyCodeLine{4568             \textcolor{keyword}{virtual} IArgFunction<C>* clone()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} BoundUnaryMethod( *\textcolor{keyword}{this} ); \}}
\DoxyCodeLine{4569             void (C::*member)( M );}
\DoxyCodeLine{4570         \};}
\DoxyCodeLine{4571         \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{4572         \textcolor{keyword}{struct }BoundNullaryMethod : IArgFunction<C>\{}
\DoxyCodeLine{4573             BoundNullaryMethod( \textcolor{keywordtype}{void} (C::*\_member)() ) : member( \_member ) \{\}}
\DoxyCodeLine{4574             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} set( C\& p, std::string \textcolor{keyword}{const}\& stringValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4575                 \textcolor{keywordtype}{bool} value;}
\DoxyCodeLine{4576                 convertInto( stringValue, value );}
\DoxyCodeLine{4577                 \textcolor{keywordflow}{if}( value )}
\DoxyCodeLine{4578                     (p.*member)();}
\DoxyCodeLine{4579             \}}
\DoxyCodeLine{4580             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} takesArg()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4581             \textcolor{keyword}{virtual} IArgFunction<C>* clone()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} BoundNullaryMethod( *\textcolor{keyword}{this} ); \}}
\DoxyCodeLine{4582             void (C::*member)();}
\DoxyCodeLine{4583         \};}
\DoxyCodeLine{4584 }
\DoxyCodeLine{4585         \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{4586         \textcolor{keyword}{struct }BoundUnaryFunction : IArgFunction<C>\{}
\DoxyCodeLine{4587             BoundUnaryFunction( \textcolor{keywordtype}{void} (*\_function)( C\& ) ) : function( \_function ) \{\}}
\DoxyCodeLine{4588             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} set( C\& obj, std::string \textcolor{keyword}{const}\& stringValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4589                 \textcolor{keywordtype}{bool} value;}
\DoxyCodeLine{4590                 convertInto( stringValue, value );}
\DoxyCodeLine{4591                 \textcolor{keywordflow}{if}( value )}
\DoxyCodeLine{4592                     function( obj );}
\DoxyCodeLine{4593             \}}
\DoxyCodeLine{4594             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} takesArg()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4595             \textcolor{keyword}{virtual} IArgFunction<C>* clone()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} BoundUnaryFunction( *\textcolor{keyword}{this} ); \}}
\DoxyCodeLine{4596             void (*function)( C\& );}
\DoxyCodeLine{4597         \};}
\DoxyCodeLine{4598 }
\DoxyCodeLine{4599         \textcolor{keyword}{template}<\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4600         \textcolor{keyword}{struct }BoundBinaryFunction : IArgFunction<C>\{}
\DoxyCodeLine{4601             BoundBinaryFunction( \textcolor{keywordtype}{void} (*\_function)( C\&, T ) ) : function( \_function ) \{\}}
\DoxyCodeLine{4602             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} set( C\& obj, std::string \textcolor{keyword}{const}\& stringValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4603                 \textcolor{keyword}{typename} RemoveConstRef<T>::type value;}
\DoxyCodeLine{4604                 convertInto( stringValue, value );}
\DoxyCodeLine{4605                 function( obj, value );}
\DoxyCodeLine{4606             \}}
\DoxyCodeLine{4607             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} takesArg()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !IsBool<T>::value; \}}
\DoxyCodeLine{4608             \textcolor{keyword}{virtual} IArgFunction<C>* clone()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} BoundBinaryFunction( *\textcolor{keyword}{this} ); \}}
\DoxyCodeLine{4609             void (*function)( C\&, T );}
\DoxyCodeLine{4610         \};}
\DoxyCodeLine{4611 }
\DoxyCodeLine{4612     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{4613 }
\DoxyCodeLine{4614     \textcolor{keyword}{inline} std::vector<std::string> argsToVector( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const}* \textcolor{keyword}{const} argv ) \{}
\DoxyCodeLine{4615         std::vector<std::string> args( \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}( argc ) );}
\DoxyCodeLine{4616         \textcolor{keywordflow}{for}( std::size\_t i = 0; i < static\_cast<std::size\_t>( argc ); ++i )}
\DoxyCodeLine{4617             args[i] = argv[i];}
\DoxyCodeLine{4618 }
\DoxyCodeLine{4619         \textcolor{keywordflow}{return} args;}
\DoxyCodeLine{4620     \}}
\DoxyCodeLine{4621 }
\DoxyCodeLine{4622     \textcolor{keyword}{class }Parser \{}
\DoxyCodeLine{4623         \textcolor{keyword}{enum} Mode \{ \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}}, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional \};}
\DoxyCodeLine{4624         Mode mode;}
\DoxyCodeLine{4625         std::size\_t from;}
\DoxyCodeLine{4626         \textcolor{keywordtype}{bool} inQuotes;}
\DoxyCodeLine{4627     \textcolor{keyword}{public}:}
\DoxyCodeLine{4628 }
\DoxyCodeLine{4629         \textcolor{keyword}{struct }Token \{}
\DoxyCodeLine{4630             \textcolor{keyword}{enum} Type \{ Positional, ShortOpt, LongOpt \};}
\DoxyCodeLine{4631             Token( Type \_type, std::string \textcolor{keyword}{const}\& \_data ) : type( \_type ), data( \_data ) \{\}}
\DoxyCodeLine{4632             Type type;}
\DoxyCodeLine{4633             std::string data;}
\DoxyCodeLine{4634         \};}
\DoxyCodeLine{4635 }
\DoxyCodeLine{4636         Parser() : mode( \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}} ), from( 0 ), inQuotes( false )\{\}}
\DoxyCodeLine{4637 }
\DoxyCodeLine{4638         \textcolor{keywordtype}{void} parseIntoTokens( std::vector<std::string> \textcolor{keyword}{const}\& args, std::vector<Token>\& tokens ) \{}
\DoxyCodeLine{4639             \textcolor{keyword}{const} std::string doubleDash = \textcolor{stringliteral}{"{}-\/-\/"{}};}
\DoxyCodeLine{4640             \textcolor{keywordflow}{for}( std::size\_t i = 1; i < args.size() \&\& args[i] != doubleDash; ++i )}
\DoxyCodeLine{4641                 parseIntoTokens( args[i], tokens);}
\DoxyCodeLine{4642         \}}
\DoxyCodeLine{4643 }
\DoxyCodeLine{4644         \textcolor{keywordtype}{void} parseIntoTokens( std::string \textcolor{keyword}{const}\& arg, std::vector<Token>\& tokens ) \{}
\DoxyCodeLine{4645             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < arg.size(); ++i ) \{}
\DoxyCodeLine{4646                 \textcolor{keywordtype}{char} c = arg[i];}
\DoxyCodeLine{4647                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'"{}'} )}
\DoxyCodeLine{4648                     inQuotes = !inQuotes;}
\DoxyCodeLine{4649                 mode = handleMode( i, c, arg, tokens );}
\DoxyCodeLine{4650             \}}
\DoxyCodeLine{4651             mode = handleMode( arg.size(), \textcolor{charliteral}{'\(\backslash\)0'}, arg, tokens );}
\DoxyCodeLine{4652         \}}
\DoxyCodeLine{4653         Mode handleMode( std::size\_t i, \textcolor{keywordtype}{char} c, std::string \textcolor{keyword}{const}\& arg, std::vector<Token>\& tokens ) \{}
\DoxyCodeLine{4654             \textcolor{keywordflow}{switch}( mode ) \{}
\DoxyCodeLine{4655                 \textcolor{keywordflow}{case} \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}}: \textcolor{keywordflow}{return} handleNone( i, c );}
\DoxyCodeLine{4656                 \textcolor{keywordflow}{case} MaybeShortOpt: \textcolor{keywordflow}{return} handleMaybeShortOpt( i, c );}
\DoxyCodeLine{4657                 \textcolor{keywordflow}{case} ShortOpt:}
\DoxyCodeLine{4658                 \textcolor{keywordflow}{case} LongOpt:}
\DoxyCodeLine{4659                 \textcolor{keywordflow}{case} SlashOpt: \textcolor{keywordflow}{return} handleOpt( i, c, arg, tokens );}
\DoxyCodeLine{4660                 \textcolor{keywordflow}{case} Positional: \textcolor{keywordflow}{return} handlePositional( i, c, arg, tokens );}
\DoxyCodeLine{4661                 \textcolor{keywordflow}{default}: \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}Unknown mode"{}} );}
\DoxyCodeLine{4662             \}}
\DoxyCodeLine{4663         \}}
\DoxyCodeLine{4664 }
\DoxyCodeLine{4665         Mode handleNone( std::size\_t i, \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{4666             \textcolor{keywordflow}{if}( inQuotes ) \{}
\DoxyCodeLine{4667                 from = i;}
\DoxyCodeLine{4668                 \textcolor{keywordflow}{return} Positional;}
\DoxyCodeLine{4669             \}}
\DoxyCodeLine{4670             \textcolor{keywordflow}{switch}( c ) \{}
\DoxyCodeLine{4671                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}: \textcolor{keywordflow}{return} MaybeShortOpt;}
\DoxyCodeLine{4672 \textcolor{preprocessor}{\#ifdef CLARA\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{4673                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'/'}: from = i+1; \textcolor{keywordflow}{return} SlashOpt;}
\DoxyCodeLine{4674 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4675                 \textcolor{keywordflow}{default}: from = i; \textcolor{keywordflow}{return} Positional;}
\DoxyCodeLine{4676             \}}
\DoxyCodeLine{4677         \}}
\DoxyCodeLine{4678         Mode handleMaybeShortOpt( std::size\_t i, \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{4679             \textcolor{keywordflow}{switch}( c ) \{}
\DoxyCodeLine{4680                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}: from = i+1; \textcolor{keywordflow}{return} LongOpt;}
\DoxyCodeLine{4681                 \textcolor{keywordflow}{default}: from = i; \textcolor{keywordflow}{return} ShortOpt;}
\DoxyCodeLine{4682             \}}
\DoxyCodeLine{4683         \}}
\DoxyCodeLine{4684 }
\DoxyCodeLine{4685         Mode handleOpt( std::size\_t i, \textcolor{keywordtype}{char} c, std::string \textcolor{keyword}{const}\& arg, std::vector<Token>\& tokens ) \{}
\DoxyCodeLine{4686             \textcolor{keywordflow}{if}( std::string( \textcolor{stringliteral}{"{}:=\(\backslash\)0"{}}, 3 ).find( c ) == std::string::npos )}
\DoxyCodeLine{4687                 \textcolor{keywordflow}{return} mode;}
\DoxyCodeLine{4688 }
\DoxyCodeLine{4689             std::string optName = arg.substr( from, i-\/from );}
\DoxyCodeLine{4690             \textcolor{keywordflow}{if}( mode == ShortOpt )}
\DoxyCodeLine{4691                 \textcolor{keywordflow}{for}( std::size\_t j = 0; j < optName.size(); ++j )}
\DoxyCodeLine{4692                     tokens.push\_back( Token( Token::ShortOpt, optName.substr( j, 1 ) ) );}
\DoxyCodeLine{4693             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == SlashOpt \&\& optName.size() == 1 )}
\DoxyCodeLine{4694                 tokens.push\_back( Token( Token::ShortOpt, optName ) );}
\DoxyCodeLine{4695             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4696                 tokens.push\_back( Token( Token::LongOpt, optName ) );}
\DoxyCodeLine{4697             \textcolor{keywordflow}{return} \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}};}
\DoxyCodeLine{4698         \}}
\DoxyCodeLine{4699         Mode handlePositional( std::size\_t i, \textcolor{keywordtype}{char} c, std::string \textcolor{keyword}{const}\& arg, std::vector<Token>\& tokens ) \{}
\DoxyCodeLine{4700             \textcolor{keywordflow}{if}( inQuotes || std::string( \textcolor{stringliteral}{"{}\(\backslash\)0"{}}, 1 ).find( c ) == std::string::npos )}
\DoxyCodeLine{4701                 \textcolor{keywordflow}{return} mode;}
\DoxyCodeLine{4702 }
\DoxyCodeLine{4703             std::string data = arg.substr( from, i-\/from );}
\DoxyCodeLine{4704             tokens.push\_back( Token( Token::Positional, data ) );}
\DoxyCodeLine{4705             \textcolor{keywordflow}{return} \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}};}
\DoxyCodeLine{4706         \}}
\DoxyCodeLine{4707     \};}
\DoxyCodeLine{4708 }
\DoxyCodeLine{4709     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ConfigT>}
\DoxyCodeLine{4710     \textcolor{keyword}{struct }CommonArgProperties \{}
\DoxyCodeLine{4711         CommonArgProperties() \{\}}
\DoxyCodeLine{4712         CommonArgProperties( Detail::BoundArgFunction<ConfigT> \textcolor{keyword}{const}\& \_boundField ) : boundField( \_boundField ) \{\}}
\DoxyCodeLine{4713 }
\DoxyCodeLine{4714         Detail::BoundArgFunction<ConfigT> boundField;}
\DoxyCodeLine{4715         std::string description;}
\DoxyCodeLine{4716         std::string detail;}
\DoxyCodeLine{4717         std::string placeholder; \textcolor{comment}{// Only value if boundField takes an arg}}
\DoxyCodeLine{4718 }
\DoxyCodeLine{4719         \textcolor{keywordtype}{bool} takesArg()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4720             \textcolor{keywordflow}{return} !placeholder.empty();}
\DoxyCodeLine{4721         \}}
\DoxyCodeLine{4722         \textcolor{keywordtype}{void} validate()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4723             \textcolor{keywordflow}{if}( !boundField.isSet() )}
\DoxyCodeLine{4724                 \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}option not bound"{}} );}
\DoxyCodeLine{4725         \}}
\DoxyCodeLine{4726     \};}
\DoxyCodeLine{4727     \textcolor{keyword}{struct }OptionArgProperties \{}
\DoxyCodeLine{4728         std::vector<std::string> shortNames;}
\DoxyCodeLine{4729         std::string longName;}
\DoxyCodeLine{4730 }
\DoxyCodeLine{4731         \textcolor{keywordtype}{bool} hasShortName( std::string \textcolor{keyword}{const}\& shortName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4732             \textcolor{keywordflow}{return} std::find( shortNames.begin(), shortNames.end(), shortName ) != shortNames.end();}
\DoxyCodeLine{4733         \}}
\DoxyCodeLine{4734         \textcolor{keywordtype}{bool} hasLongName( std::string \textcolor{keyword}{const}\& \_longName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4735             \textcolor{keywordflow}{return} \_longName == longName;}
\DoxyCodeLine{4736         \}}
\DoxyCodeLine{4737     \};}
\DoxyCodeLine{4738     \textcolor{keyword}{struct }PositionalArgProperties \{}
\DoxyCodeLine{4739         PositionalArgProperties() : position( -\/1 ) \{\}}
\DoxyCodeLine{4740         \textcolor{keywordtype}{int} position; \textcolor{comment}{// -\/1 means non-\/positional (floating)}}
\DoxyCodeLine{4741 }
\DoxyCodeLine{4742         \textcolor{keywordtype}{bool} isFixedPositional()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4743             \textcolor{keywordflow}{return} position != -\/1;}
\DoxyCodeLine{4744         \}}
\DoxyCodeLine{4745     \};}
\DoxyCodeLine{4746 }
\DoxyCodeLine{4747     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ConfigT>}
\DoxyCodeLine{4748     \textcolor{keyword}{class }CommandLine \{}
\DoxyCodeLine{4749 }
\DoxyCodeLine{4750         \textcolor{keyword}{struct }Arg : CommonArgProperties<ConfigT>, OptionArgProperties, PositionalArgProperties \{}
\DoxyCodeLine{4751             Arg() \{\}}
\DoxyCodeLine{4752             Arg( Detail::BoundArgFunction<ConfigT> \textcolor{keyword}{const}\& \_boundField ) : CommonArgProperties<ConfigT>( \_boundField ) \{\}}
\DoxyCodeLine{4753 }
\DoxyCodeLine{4754             \textcolor{keyword}{using }CommonArgProperties<ConfigT>::placeholder; \textcolor{comment}{// !TBD}}
\DoxyCodeLine{4755 }
\DoxyCodeLine{4756             std::string dbgName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4757                 \textcolor{keywordflow}{if}( !longName.empty() )}
\DoxyCodeLine{4758                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}-\/-\/"{}} + longName;}
\DoxyCodeLine{4759                 \textcolor{keywordflow}{if}( !shortNames.empty() )}
\DoxyCodeLine{4760                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}-\/"{}} + shortNames[0];}
\DoxyCodeLine{4761                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}positional args"{}};}
\DoxyCodeLine{4762             \}}
\DoxyCodeLine{4763             std::string commands()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4764                 std::ostringstream oss;}
\DoxyCodeLine{4765                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{4766                 std::vector<std::string>::const\_iterator it = shortNames.begin(), itEnd = shortNames.end();}
\DoxyCodeLine{4767                 \textcolor{keywordflow}{for}(; it != itEnd; ++it ) \{}
\DoxyCodeLine{4768                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{4769                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{4770                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4771                         oss << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{4772                     oss << \textcolor{stringliteral}{"{}-\/"{}} << *it;}
\DoxyCodeLine{4773                 \}}
\DoxyCodeLine{4774                 \textcolor{keywordflow}{if}( !longName.empty() ) \{}
\DoxyCodeLine{4775                     if( !first )}
\DoxyCodeLine{4776                         oss << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{4777                     oss << \textcolor{stringliteral}{"{}-\/-\/"{}} << longName;}
\DoxyCodeLine{4778                 \}}
\DoxyCodeLine{4779                 \textcolor{keywordflow}{if}( !placeholder.empty() )}
\DoxyCodeLine{4780                     oss << \textcolor{stringliteral}{"{} <"{}} << placeholder << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{4781                 \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{4782             \}}
\DoxyCodeLine{4783         \};}
\DoxyCodeLine{4784 }
\DoxyCodeLine{4785         \textcolor{keyword}{typedef} CLARA\_AUTO\_PTR( Arg ) ArgAutoPtr;}
\DoxyCodeLine{4786 }
\DoxyCodeLine{4787         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} addOptName( Arg\& arg, std::string \textcolor{keyword}{const}\& optName )}
\DoxyCodeLine{4788         \{}
\DoxyCodeLine{4789             \textcolor{keywordflow}{if}( optName.empty() )}
\DoxyCodeLine{4790                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{4791             \textcolor{keywordflow}{if}( Detail::startsWith( optName, \textcolor{stringliteral}{"{}-\/-\/"{}} ) ) \{}
\DoxyCodeLine{4792                 \textcolor{keywordflow}{if}( !arg.longName.empty() )}
\DoxyCodeLine{4793                     \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}Only one long opt may be specified. '"{}}}
\DoxyCodeLine{4794                         + arg.longName}
\DoxyCodeLine{4795                         + \textcolor{stringliteral}{"{}' already specified, now attempting to add '"{}}}
\DoxyCodeLine{4796                         + optName + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{4797                 arg.longName = optName.substr( 2 );}
\DoxyCodeLine{4798             \}}
\DoxyCodeLine{4799             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( Detail::startsWith( optName, \textcolor{stringliteral}{"{}-\/"{}} ) )}
\DoxyCodeLine{4800                 arg.shortNames.push\_back( optName.substr( 1 ) );}
\DoxyCodeLine{4801             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4802                 \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}option must begin with -\/ or -\/-\/. Option was: '"{}} + optName + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{4803         \}}
\DoxyCodeLine{4804         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} setPositionalArg( Arg\& arg, \textcolor{keywordtype}{int} position )}
\DoxyCodeLine{4805         \{}
\DoxyCodeLine{4806             arg.position = position;}
\DoxyCodeLine{4807         \}}
\DoxyCodeLine{4808 }
\DoxyCodeLine{4809         \textcolor{keyword}{class }ArgBuilder \{}
\DoxyCodeLine{4810         \textcolor{keyword}{public}:}
\DoxyCodeLine{4811             ArgBuilder( Arg* arg ) : m\_arg( arg ) \{\}}
\DoxyCodeLine{4812 }
\DoxyCodeLine{4813             \textcolor{comment}{// Bind a non-\/boolean data member (requires placeholder string)}}
\DoxyCodeLine{4814             \textcolor{keyword}{template}<\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4815             \textcolor{keywordtype}{void} bind( M C::* field, std::string \textcolor{keyword}{const}\& placeholder ) \{}
\DoxyCodeLine{4816                 m\_arg-\/>boundField = \textcolor{keyword}{new} Detail::BoundDataMember<C,M>( field );}
\DoxyCodeLine{4817                 m\_arg-\/>placeholder = placeholder;}
\DoxyCodeLine{4818             \}}
\DoxyCodeLine{4819             \textcolor{comment}{// Bind a boolean data member (no placeholder required)}}
\DoxyCodeLine{4820             \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{4821             \textcolor{keywordtype}{void} bind( \textcolor{keywordtype}{bool} C::* field ) \{}
\DoxyCodeLine{4822                 m\_arg-\/>boundField = \textcolor{keyword}{new} Detail::BoundDataMember<C,bool>( field );}
\DoxyCodeLine{4823             \}}
\DoxyCodeLine{4824 }
\DoxyCodeLine{4825             \textcolor{comment}{// Bind a method taking a single, non-\/boolean argument (requires a placeholder string)}}
\DoxyCodeLine{4826             \textcolor{keyword}{template}<\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4827             \textcolor{keywordtype}{void} bind( \textcolor{keywordtype}{void} (C::* unaryMethod)( M ), std::string \textcolor{keyword}{const}\& placeholder ) \{}
\DoxyCodeLine{4828                 m\_arg-\/>boundField = \textcolor{keyword}{new} Detail::BoundUnaryMethod<C,M>( unaryMethod );}
\DoxyCodeLine{4829                 m\_arg-\/>placeholder = placeholder;}
\DoxyCodeLine{4830             \}}
\DoxyCodeLine{4831 }
\DoxyCodeLine{4832             \textcolor{comment}{// Bind a method taking a single, boolean argument (no placeholder string required)}}
\DoxyCodeLine{4833             \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{4834             \textcolor{keywordtype}{void} bind( \textcolor{keywordtype}{void} (C::* unaryMethod)( \textcolor{keywordtype}{bool} ) ) \{}
\DoxyCodeLine{4835                 m\_arg-\/>boundField = \textcolor{keyword}{new} Detail::BoundUnaryMethod<C,bool>( unaryMethod );}
\DoxyCodeLine{4836             \}}
\DoxyCodeLine{4837 }
\DoxyCodeLine{4838             \textcolor{comment}{// Bind a method that takes no arguments (will be called if opt is present)}}
\DoxyCodeLine{4839             \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{4840             \textcolor{keywordtype}{void} bind( \textcolor{keywordtype}{void} (C::* nullaryMethod)() ) \{}
\DoxyCodeLine{4841                 m\_arg-\/>boundField = \textcolor{keyword}{new} Detail::BoundNullaryMethod<C>( nullaryMethod );}
\DoxyCodeLine{4842             \}}
\DoxyCodeLine{4843 }
\DoxyCodeLine{4844             \textcolor{comment}{// Bind a free function taking a single argument -\/ the object to operate on (no placeholder string required)}}
\DoxyCodeLine{4845             \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{4846             \textcolor{keywordtype}{void} bind( \textcolor{keywordtype}{void} (* unaryFunction)( C\& ) ) \{}
\DoxyCodeLine{4847                 m\_arg-\/>boundField = \textcolor{keyword}{new} Detail::BoundUnaryFunction<C>( unaryFunction );}
\DoxyCodeLine{4848             \}}
\DoxyCodeLine{4849 }
\DoxyCodeLine{4850             \textcolor{comment}{// Bind a free function taking a single argument -\/ the object to operate on (requires a placeholder string)}}
\DoxyCodeLine{4851             \textcolor{keyword}{template}<\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4852             \textcolor{keywordtype}{void} bind( \textcolor{keywordtype}{void} (* binaryFunction)( C\&, T ), std::string \textcolor{keyword}{const}\& placeholder ) \{}
\DoxyCodeLine{4853                 m\_arg-\/>boundField = \textcolor{keyword}{new} Detail::BoundBinaryFunction<C, T>( binaryFunction );}
\DoxyCodeLine{4854                 m\_arg-\/>placeholder = placeholder;}
\DoxyCodeLine{4855             \}}
\DoxyCodeLine{4856 }
\DoxyCodeLine{4857             ArgBuilder\& describe( std::string \textcolor{keyword}{const}\& description ) \{}
\DoxyCodeLine{4858                 m\_arg-\/>description = description;}
\DoxyCodeLine{4859                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4860             \}}
\DoxyCodeLine{4861             ArgBuilder\& detail( std::string \textcolor{keyword}{const}\& detail ) \{}
\DoxyCodeLine{4862                 m\_arg-\/>detail = detail;}
\DoxyCodeLine{4863                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4864             \}}
\DoxyCodeLine{4865 }
\DoxyCodeLine{4866         \textcolor{keyword}{protected}:}
\DoxyCodeLine{4867             Arg* m\_arg;}
\DoxyCodeLine{4868         \};}
\DoxyCodeLine{4869 }
\DoxyCodeLine{4870         \textcolor{keyword}{class }OptBuilder : \textcolor{keyword}{public} ArgBuilder \{}
\DoxyCodeLine{4871         \textcolor{keyword}{public}:}
\DoxyCodeLine{4872             OptBuilder( Arg* arg ) : ArgBuilder( arg ) \{\}}
\DoxyCodeLine{4873             OptBuilder( OptBuilder\& other ) : ArgBuilder( other ) \{\}}
\DoxyCodeLine{4874 }
\DoxyCodeLine{4875             OptBuilder\& operator[]( std::string \textcolor{keyword}{const}\& optName ) \{}
\DoxyCodeLine{4876                 addOptName( *ArgBuilder::m\_arg, optName );}
\DoxyCodeLine{4877                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4878             \}}
\DoxyCodeLine{4879         \};}
\DoxyCodeLine{4880 }
\DoxyCodeLine{4881     \textcolor{keyword}{public}:}
\DoxyCodeLine{4882 }
\DoxyCodeLine{4883         CommandLine()}
\DoxyCodeLine{4884         :   m\_boundProcessName( new Detail::NullBinder<ConfigT>() ),}
\DoxyCodeLine{4885             m\_highestSpecifiedArgPosition( 0 ),}
\DoxyCodeLine{4886             m\_throwOnUnrecognisedTokens( false )}
\DoxyCodeLine{4887         \{\}}
\DoxyCodeLine{4888         CommandLine( CommandLine \textcolor{keyword}{const}\& other )}
\DoxyCodeLine{4889         :   m\_boundProcessName( other.m\_boundProcessName ),}
\DoxyCodeLine{4890             m\_options ( other.m\_options ),}
\DoxyCodeLine{4891             m\_positionalArgs( other.m\_positionalArgs ),}
\DoxyCodeLine{4892             m\_highestSpecifiedArgPosition( other.m\_highestSpecifiedArgPosition ),}
\DoxyCodeLine{4893             m\_throwOnUnrecognisedTokens( other.m\_throwOnUnrecognisedTokens )}
\DoxyCodeLine{4894         \{}
\DoxyCodeLine{4895             \textcolor{keywordflow}{if}( other.m\_floatingArg.get() )}
\DoxyCodeLine{4896                 m\_floatingArg.reset( \textcolor{keyword}{new} Arg( *other.m\_floatingArg ) );}
\DoxyCodeLine{4897         \}}
\DoxyCodeLine{4898 }
\DoxyCodeLine{4899         CommandLine\& setThrowOnUnrecognisedTokens( \textcolor{keywordtype}{bool} shouldThrow = \textcolor{keyword}{true} ) \{}
\DoxyCodeLine{4900             m\_throwOnUnrecognisedTokens = shouldThrow;}
\DoxyCodeLine{4901             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4902         \}}
\DoxyCodeLine{4903 }
\DoxyCodeLine{4904         OptBuilder operator[]( std::string \textcolor{keyword}{const}\& optName ) \{}
\DoxyCodeLine{4905             m\_options.push\_back( Arg() );}
\DoxyCodeLine{4906             addOptName( m\_options.back(), optName );}
\DoxyCodeLine{4907             OptBuilder builder( \&m\_options.back() );}
\DoxyCodeLine{4908             \textcolor{keywordflow}{return} builder;}
\DoxyCodeLine{4909         \}}
\DoxyCodeLine{4910 }
\DoxyCodeLine{4911         ArgBuilder operator[]( \textcolor{keywordtype}{int} position ) \{}
\DoxyCodeLine{4912             m\_positionalArgs.insert( std::make\_pair( position, Arg() ) );}
\DoxyCodeLine{4913             \textcolor{keywordflow}{if}( position > m\_highestSpecifiedArgPosition )}
\DoxyCodeLine{4914                 m\_highestSpecifiedArgPosition = position;}
\DoxyCodeLine{4915             setPositionalArg( m\_positionalArgs[position], position );}
\DoxyCodeLine{4916             ArgBuilder builder( \&m\_positionalArgs[position] );}
\DoxyCodeLine{4917             \textcolor{keywordflow}{return} builder;}
\DoxyCodeLine{4918         \}}
\DoxyCodeLine{4919 }
\DoxyCodeLine{4920         \textcolor{comment}{// Invoke this with the \_ instance}}
\DoxyCodeLine{4921         ArgBuilder operator[]( UnpositionalTag ) \{}
\DoxyCodeLine{4922             \textcolor{keywordflow}{if}( m\_floatingArg.get() )}
\DoxyCodeLine{4923                 \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}Only one unpositional argument can be added"{}} );}
\DoxyCodeLine{4924             m\_floatingArg.reset( \textcolor{keyword}{new} Arg() );}
\DoxyCodeLine{4925             ArgBuilder builder( m\_floatingArg.get() );}
\DoxyCodeLine{4926             \textcolor{keywordflow}{return} builder;}
\DoxyCodeLine{4927         \}}
\DoxyCodeLine{4928 }
\DoxyCodeLine{4929         \textcolor{keyword}{template}<\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4930         \textcolor{keywordtype}{void} bindProcessName( M C::* field ) \{}
\DoxyCodeLine{4931             m\_boundProcessName = \textcolor{keyword}{new} Detail::BoundDataMember<C,M>( field );}
\DoxyCodeLine{4932         \}}
\DoxyCodeLine{4933         \textcolor{keyword}{template}<\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4934         \textcolor{keywordtype}{void} bindProcessName( \textcolor{keywordtype}{void} (C::*\_unaryMethod)( M ) ) \{}
\DoxyCodeLine{4935             m\_boundProcessName = \textcolor{keyword}{new} Detail::BoundUnaryMethod<C,M>( \_unaryMethod );}
\DoxyCodeLine{4936         \}}
\DoxyCodeLine{4937 }
\DoxyCodeLine{4938         \textcolor{keywordtype}{void} optUsage( std::ostream\& os, std::size\_t indent = 0, std::size\_t width = Detail::consoleWidth )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4939             \textcolor{keyword}{typename} std::vector<Arg>::const\_iterator itBegin = m\_options.begin(), itEnd = m\_options.end(), it;}
\DoxyCodeLine{4940             std::size\_t maxWidth = 0;}
\DoxyCodeLine{4941             \textcolor{keywordflow}{for}( it = itBegin; it != itEnd; ++it )}
\DoxyCodeLine{4942                 maxWidth = (std::max)( maxWidth, it-\/>commands().size() );}
\DoxyCodeLine{4943 }
\DoxyCodeLine{4944             \textcolor{keywordflow}{for}( it = itBegin; it != itEnd; ++it ) \{}
\DoxyCodeLine{4945                 Detail::Text usage( it-\/>commands(), Detail::TextAttributes()}
\DoxyCodeLine{4946                                                         .setWidth( maxWidth+indent )}
\DoxyCodeLine{4947                                                         .setIndent( indent ) );}
\DoxyCodeLine{4948                 Detail::Text desc( it-\/>description, Detail::TextAttributes()}
\DoxyCodeLine{4949                                                         .setWidth( width -\/ maxWidth -\/ 3 ) );}
\DoxyCodeLine{4950 }
\DoxyCodeLine{4951                 \textcolor{keywordflow}{for}( std::size\_t i = 0; i < (std::max)( usage.size(), desc.size() ); ++i ) \{}
\DoxyCodeLine{4952                     std::string usageCol = i < usage.size() ? usage[i] : \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4953                     os << usageCol;}
\DoxyCodeLine{4954 }
\DoxyCodeLine{4955                     \textcolor{keywordflow}{if}( i < desc.size() \&\& !desc[i].empty() )}
\DoxyCodeLine{4956                         os  << std::string( indent + 2 + maxWidth -\/ usageCol.size(), \textcolor{charliteral}{' '} )}
\DoxyCodeLine{4957                             << desc[i];}
\DoxyCodeLine{4958                     os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{4959                 \}}
\DoxyCodeLine{4960             \}}
\DoxyCodeLine{4961         \}}
\DoxyCodeLine{4962         std::string optUsage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4963             std::ostringstream oss;}
\DoxyCodeLine{4964             optUsage( oss );}
\DoxyCodeLine{4965             \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{4966         \}}
\DoxyCodeLine{4967 }
\DoxyCodeLine{4968         \textcolor{keywordtype}{void} argSynopsis( std::ostream\& os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4969             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} i = 1; i <= m\_highestSpecifiedArgPosition; ++i ) \{}
\DoxyCodeLine{4970                 \textcolor{keywordflow}{if}( i > 1 )}
\DoxyCodeLine{4971                     os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{4972                 \textcolor{keyword}{typename} std::map<int, Arg>::const\_iterator it = m\_positionalArgs.find( i );}
\DoxyCodeLine{4973                 \textcolor{keywordflow}{if}( it != m\_positionalArgs.end() )}
\DoxyCodeLine{4974                     os << \textcolor{stringliteral}{"{}<"{}} << it-\/>second.placeholder << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{4975                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( m\_floatingArg.get() )}
\DoxyCodeLine{4976                     os << \textcolor{stringliteral}{"{}<"{}} << m\_floatingArg-\/>placeholder << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{4977                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{4978                     \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}non consecutive positional arguments with no floating args"{}} );}
\DoxyCodeLine{4979             \}}
\DoxyCodeLine{4980             \textcolor{comment}{// !TBD No indication of mandatory args}}
\DoxyCodeLine{4981             \textcolor{keywordflow}{if}( m\_floatingArg.get() ) \{}
\DoxyCodeLine{4982                 if( m\_highestSpecifiedArgPosition > 1 )}
\DoxyCodeLine{4983                     os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{4984                 os << \textcolor{stringliteral}{"{}[<"{}} << m\_floatingArg-\/>placeholder << \textcolor{stringliteral}{"{}> ...]"{}};}
\DoxyCodeLine{4985             \}}
\DoxyCodeLine{4986         \}}
\DoxyCodeLine{4987         std::string argSynopsis()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4988             std::ostringstream oss;}
\DoxyCodeLine{4989             argSynopsis( oss );}
\DoxyCodeLine{4990             \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{4991         \}}
\DoxyCodeLine{4992 }
\DoxyCodeLine{4993         \textcolor{keywordtype}{void} usage( std::ostream\& os, std::string \textcolor{keyword}{const}\& procName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4994             validate();}
\DoxyCodeLine{4995             os << \textcolor{stringliteral}{"{}usage:\(\backslash\)n  "{}} << procName << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{4996             argSynopsis( os );}
\DoxyCodeLine{4997             \textcolor{keywordflow}{if}( !m\_options.empty() ) \{}
\DoxyCodeLine{4998                 os << \textcolor{stringliteral}{"{} [options]\(\backslash\)n\(\backslash\)nwhere options are: \(\backslash\)n"{}};}
\DoxyCodeLine{4999                 optUsage( os, 2 );}
\DoxyCodeLine{5000             \}}
\DoxyCodeLine{5001             os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{5002         \}}
\DoxyCodeLine{5003         std::string usage( std::string \textcolor{keyword}{const}\& procName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5004             std::ostringstream oss;}
\DoxyCodeLine{5005             usage( oss, procName );}
\DoxyCodeLine{5006             \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{5007         \}}
\DoxyCodeLine{5008 }
\DoxyCodeLine{5009         ConfigT parse( std::vector<std::string> \textcolor{keyword}{const}\& args )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5010             ConfigT config;}
\DoxyCodeLine{5011             parseInto( args, config );}
\DoxyCodeLine{5012             \textcolor{keywordflow}{return} config;}
\DoxyCodeLine{5013         \}}
\DoxyCodeLine{5014 }
\DoxyCodeLine{5015         std::vector<Parser::Token> parseInto( std::vector<std::string> \textcolor{keyword}{const}\& args, ConfigT\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5016             std::string processName = args.empty() ? std::string() : args[0];}
\DoxyCodeLine{5017             std::size\_t lastSlash = processName.find\_last\_of( \textcolor{stringliteral}{"{}/\(\backslash\)\(\backslash\)"{}} );}
\DoxyCodeLine{5018             \textcolor{keywordflow}{if}( lastSlash != std::string::npos )}
\DoxyCodeLine{5019                 processName = processName.substr( lastSlash+1 );}
\DoxyCodeLine{5020             m\_boundProcessName.set( config, processName );}
\DoxyCodeLine{5021             std::vector<Parser::Token> tokens;}
\DoxyCodeLine{5022             Parser parser;}
\DoxyCodeLine{5023             parser.parseIntoTokens( args, tokens );}
\DoxyCodeLine{5024             \textcolor{keywordflow}{return} populate( tokens, config );}
\DoxyCodeLine{5025         \}}
\DoxyCodeLine{5026 }
\DoxyCodeLine{5027         std::vector<Parser::Token> populate( std::vector<Parser::Token> \textcolor{keyword}{const}\& tokens, ConfigT\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5028             validate();}
\DoxyCodeLine{5029             std::vector<Parser::Token> unusedTokens = populateOptions( tokens, config );}
\DoxyCodeLine{5030             unusedTokens = populateFixedArgs( unusedTokens, config );}
\DoxyCodeLine{5031             unusedTokens = populateFloatingArgs( unusedTokens, config );}
\DoxyCodeLine{5032             \textcolor{keywordflow}{return} unusedTokens;}
\DoxyCodeLine{5033         \}}
\DoxyCodeLine{5034 }
\DoxyCodeLine{5035         std::vector<Parser::Token> populateOptions( std::vector<Parser::Token> \textcolor{keyword}{const}\& tokens, ConfigT\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5036             std::vector<Parser::Token> unusedTokens;}
\DoxyCodeLine{5037             std::vector<std::string> errors;}
\DoxyCodeLine{5038             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < tokens.size(); ++i ) \{}
\DoxyCodeLine{5039                 Parser::Token \textcolor{keyword}{const}\& token = tokens[i];}
\DoxyCodeLine{5040                 \textcolor{keyword}{typename} std::vector<Arg>::const\_iterator it = m\_options.begin(), itEnd = m\_options.end();}
\DoxyCodeLine{5041                 \textcolor{keywordflow}{for}(; it != itEnd; ++it ) \{}
\DoxyCodeLine{5042                     Arg const\& arg = *it;}
\DoxyCodeLine{5043 }
\DoxyCodeLine{5044                     try \{}
\DoxyCodeLine{5045                         if( ( token.type == Parser::Token::ShortOpt \&\& arg.hasShortName( token.data ) ) ||}
\DoxyCodeLine{5046                             ( token.type == Parser::Token::LongOpt \&\& arg.hasLongName( token.data ) ) ) \{}
\DoxyCodeLine{5047                             if( arg.takesArg() ) \{}
\DoxyCodeLine{5048                                 if( i == tokens.size()-\/1 || tokens[i+1].type != Parser::Token::Positional )}
\DoxyCodeLine{5049                                     errors.push\_back( \textcolor{stringliteral}{"{}Expected argument to option: "{}} + token.data );}
\DoxyCodeLine{5050                                 else}
\DoxyCodeLine{5051                                     arg.boundField.set( config, tokens[++i].data );}
\DoxyCodeLine{5052                             \}}
\DoxyCodeLine{5053                             else \{}
\DoxyCodeLine{5054                                 arg.boundField.set( config, \textcolor{stringliteral}{"{}true"{}} );}
\DoxyCodeLine{5055                             \}}
\DoxyCodeLine{5056                             break;}
\DoxyCodeLine{5057                         \}}
\DoxyCodeLine{5058                     \}}
\DoxyCodeLine{5059                     \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{5060                         errors.push\_back( std::string( ex.what() ) + \textcolor{stringliteral}{"{}\(\backslash\)n-\/ while parsing: ("{}} + arg.commands() + \textcolor{stringliteral}{"{})"{}} );}
\DoxyCodeLine{5061                     \}}
\DoxyCodeLine{5062                 \}}
\DoxyCodeLine{5063                 \textcolor{keywordflow}{if}( it == itEnd ) \{}
\DoxyCodeLine{5064                     \textcolor{keywordflow}{if}( token.type == Parser::Token::Positional || !m\_throwOnUnrecognisedTokens )}
\DoxyCodeLine{5065                         unusedTokens.push\_back( token );}
\DoxyCodeLine{5066                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( errors.empty() \&\& m\_throwOnUnrecognisedTokens )}
\DoxyCodeLine{5067                         errors.push\_back( \textcolor{stringliteral}{"{}unrecognised option: "{}} + token.data );}
\DoxyCodeLine{5068                 \}}
\DoxyCodeLine{5069             \}}
\DoxyCodeLine{5070             \textcolor{keywordflow}{if}( !errors.empty() ) \{}
\DoxyCodeLine{5071                 std::ostringstream oss;}
\DoxyCodeLine{5072                 for( std::vector<std::string>::const\_iterator it = errors.begin(), itEnd = errors.end();}
\DoxyCodeLine{5073                         it != itEnd;}
\DoxyCodeLine{5074                         ++it ) \{}
\DoxyCodeLine{5075                     if( it != errors.begin() )}
\DoxyCodeLine{5076                         oss << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{5077                     oss << *it;}
\DoxyCodeLine{5078                 \}}
\DoxyCodeLine{5079                 \textcolor{keywordflow}{throw} std::runtime\_error( oss.str() );}
\DoxyCodeLine{5080             \}}
\DoxyCodeLine{5081             \textcolor{keywordflow}{return} unusedTokens;}
\DoxyCodeLine{5082         \}}
\DoxyCodeLine{5083         std::vector<Parser::Token> populateFixedArgs( std::vector<Parser::Token> \textcolor{keyword}{const}\& tokens, ConfigT\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5084             std::vector<Parser::Token> unusedTokens;}
\DoxyCodeLine{5085             \textcolor{keywordtype}{int} position = 1;}
\DoxyCodeLine{5086             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < tokens.size(); ++i ) \{}
\DoxyCodeLine{5087                 Parser::Token \textcolor{keyword}{const}\& token = tokens[i];}
\DoxyCodeLine{5088                 \textcolor{keyword}{typename} std::map<int, Arg>::const\_iterator it = m\_positionalArgs.find( position );}
\DoxyCodeLine{5089                 \textcolor{keywordflow}{if}( it != m\_positionalArgs.end() )}
\DoxyCodeLine{5090                     it-\/>second.boundField.set( config, token.data );}
\DoxyCodeLine{5091                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5092                     unusedTokens.push\_back( token );}
\DoxyCodeLine{5093                 \textcolor{keywordflow}{if}( token.type == Parser::Token::Positional )}
\DoxyCodeLine{5094                     position++;}
\DoxyCodeLine{5095             \}}
\DoxyCodeLine{5096             \textcolor{keywordflow}{return} unusedTokens;}
\DoxyCodeLine{5097         \}}
\DoxyCodeLine{5098         std::vector<Parser::Token> populateFloatingArgs( std::vector<Parser::Token> \textcolor{keyword}{const}\& tokens, ConfigT\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5099             \textcolor{keywordflow}{if}( !m\_floatingArg.get() )}
\DoxyCodeLine{5100                 \textcolor{keywordflow}{return} tokens;}
\DoxyCodeLine{5101             std::vector<Parser::Token> unusedTokens;}
\DoxyCodeLine{5102             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < tokens.size(); ++i ) \{}
\DoxyCodeLine{5103                 Parser::Token \textcolor{keyword}{const}\& token = tokens[i];}
\DoxyCodeLine{5104                 \textcolor{keywordflow}{if}( token.type == Parser::Token::Positional )}
\DoxyCodeLine{5105                     m\_floatingArg-\/>boundField.set( config, token.data );}
\DoxyCodeLine{5106                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5107                     unusedTokens.push\_back( token );}
\DoxyCodeLine{5108             \}}
\DoxyCodeLine{5109             \textcolor{keywordflow}{return} unusedTokens;}
\DoxyCodeLine{5110         \}}
\DoxyCodeLine{5111 }
\DoxyCodeLine{5112         \textcolor{keywordtype}{void} validate()\textcolor{keyword}{ const}}
\DoxyCodeLine{5113 \textcolor{keyword}{        }\{}
\DoxyCodeLine{5114             \textcolor{keywordflow}{if}( m\_options.empty() \&\& m\_positionalArgs.empty() \&\& !m\_floatingArg.get() )}
\DoxyCodeLine{5115                 \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}No options or arguments specified"{}} );}
\DoxyCodeLine{5116 }
\DoxyCodeLine{5117             \textcolor{keywordflow}{for}( \textcolor{keyword}{typename} std::vector<Arg>::const\_iterator  it = m\_options.begin(),}
\DoxyCodeLine{5118                                                             itEnd = m\_options.end();}
\DoxyCodeLine{5119                     it != itEnd; ++it )}
\DoxyCodeLine{5120                 it-\/>validate();}
\DoxyCodeLine{5121         \}}
\DoxyCodeLine{5122 }
\DoxyCodeLine{5123     \textcolor{keyword}{private}:}
\DoxyCodeLine{5124         Detail::BoundArgFunction<ConfigT> m\_boundProcessName;}
\DoxyCodeLine{5125         std::vector<Arg> m\_options;}
\DoxyCodeLine{5126         std::map<int, Arg> m\_positionalArgs;}
\DoxyCodeLine{5127         ArgAutoPtr m\_floatingArg;}
\DoxyCodeLine{5128         \textcolor{keywordtype}{int} m\_highestSpecifiedArgPosition;}
\DoxyCodeLine{5129         \textcolor{keywordtype}{bool} m\_throwOnUnrecognisedTokens;}
\DoxyCodeLine{5130     \};}
\DoxyCodeLine{5131 }
\DoxyCodeLine{5132 \} \textcolor{comment}{// end namespace Clara}}
\DoxyCodeLine{5133 }
\DoxyCodeLine{5134 STITCH\_CLARA\_CLOSE\_NAMESPACE}
\DoxyCodeLine{5135 \textcolor{preprocessor}{\#undef STITCH\_CLARA\_OPEN\_NAMESPACE}}
\DoxyCodeLine{5136 \textcolor{preprocessor}{\#undef STITCH\_CLARA\_CLOSE\_NAMESPACE}}
\DoxyCodeLine{5137 }
\DoxyCodeLine{5138 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_CLARA\_H\_INCLUDED}}
\DoxyCodeLine{5139 \textcolor{preprocessor}{\#undef STITCH\_CLARA\_OPEN\_NAMESPACE}}
\DoxyCodeLine{5140 }
\DoxyCodeLine{5141 \textcolor{comment}{// Restore Clara's value for console width, if present}}
\DoxyCodeLine{5142 \textcolor{preprocessor}{\#ifdef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{5143 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_CONSOLE\_WIDTH CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{5144 \textcolor{preprocessor}{\#undef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{5145 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5146 }
\DoxyCodeLine{5147 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{5148 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{5149 }
\DoxyCodeLine{5150 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5151 }
\DoxyCodeLine{5152     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} abortAfterFirst( ConfigData\& config ) \{ config.abortAfter = 1; \}}
\DoxyCodeLine{5153     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} abortAfterX( ConfigData\& config, \textcolor{keywordtype}{int} x ) \{}
\DoxyCodeLine{5154         \textcolor{keywordflow}{if}( x < 1 )}
\DoxyCodeLine{5155             \textcolor{keywordflow}{throw} std::runtime\_error( \textcolor{stringliteral}{"{}Value after -\/x or -\/-\/abortAfter must be greater than zero"{}} );}
\DoxyCodeLine{5156         config.abortAfter = x;}
\DoxyCodeLine{5157     \}}
\DoxyCodeLine{5158     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addTestOrTags( ConfigData\& config, std::string \textcolor{keyword}{const}\& \_testSpec ) \{ config.testsOrTags.push\_back( \_testSpec ); \}}
\DoxyCodeLine{5159     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addSectionToRun( ConfigData\& config, std::string \textcolor{keyword}{const}\& sectionName ) \{ config.sectionsToRun.push\_back( sectionName ); \}}
\DoxyCodeLine{5160     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addReporterName( ConfigData\& config, std::string \textcolor{keyword}{const}\& \_reporterName ) \{ config.reporterNames.push\_back( \_reporterName ); \}}
\DoxyCodeLine{5161 }
\DoxyCodeLine{5162     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addWarning( ConfigData\& config, std::string \textcolor{keyword}{const}\& \_warning ) \{}
\DoxyCodeLine{5163         \textcolor{keywordflow}{if}( \_warning == \textcolor{stringliteral}{"{}NoAssertions"{}} )}
\DoxyCodeLine{5164             config.warnings = \textcolor{keyword}{static\_cast<}WarnAbout::What\textcolor{keyword}{>}( config.warnings | WarnAbout::NoAssertions );}
\DoxyCodeLine{5165         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5166             \textcolor{keywordflow}{throw} std::runtime\_error( \textcolor{stringliteral}{"{}Unrecognised warning: '"{}} + \_warning + \textcolor{charliteral}{'\(\backslash\)''} );}
\DoxyCodeLine{5167     \}}
\DoxyCodeLine{5168     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setOrder( ConfigData\& config, std::string \textcolor{keyword}{const}\& order ) \{}
\DoxyCodeLine{5169         \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}declared"{}}, order ) )}
\DoxyCodeLine{5170             config.runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{5171         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}lexical"{}}, order ) )}
\DoxyCodeLine{5172             config.runOrder = RunTests::InLexicographicalOrder;}
\DoxyCodeLine{5173         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}random"{}}, order ) )}
\DoxyCodeLine{5174             config.runOrder = RunTests::InRandomOrder;}
\DoxyCodeLine{5175         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5176             \textcolor{keywordflow}{throw} std::runtime\_error( \textcolor{stringliteral}{"{}Unrecognised ordering: '"{}} + order + \textcolor{charliteral}{'\(\backslash\)''} );}
\DoxyCodeLine{5177     \}}
\DoxyCodeLine{5178     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setRngSeed( ConfigData\& config, std::string \textcolor{keyword}{const}\& seed ) \{}
\DoxyCodeLine{5179         \textcolor{keywordflow}{if}( seed == \textcolor{stringliteral}{"{}time"{}} ) \{}
\DoxyCodeLine{5180             config.rngSeed = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( std::time(0) );}
\DoxyCodeLine{5181         \}}
\DoxyCodeLine{5182         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5183             std::stringstream ss;}
\DoxyCodeLine{5184             ss << seed;}
\DoxyCodeLine{5185             ss >> config.rngSeed;}
\DoxyCodeLine{5186             \textcolor{keywordflow}{if}( ss.fail() )}
\DoxyCodeLine{5187                 \textcolor{keywordflow}{throw} std::runtime\_error( \textcolor{stringliteral}{"{}Argument to -\/-\/rng-\/seed should be the word 'time' or a number"{}} );}
\DoxyCodeLine{5188         \}}
\DoxyCodeLine{5189     \}}
\DoxyCodeLine{5190     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setVerbosity( ConfigData\& config, \textcolor{keywordtype}{int} level ) \{}
\DoxyCodeLine{5191         \textcolor{comment}{// !TBD: accept strings?}}
\DoxyCodeLine{5192         config.verbosity = \textcolor{keyword}{static\_cast<}Verbosity::Level\textcolor{keyword}{>}( level );}
\DoxyCodeLine{5193     \}}
\DoxyCodeLine{5194     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setShowDurations( ConfigData\& config, \textcolor{keywordtype}{bool} \_showDurations ) \{}
\DoxyCodeLine{5195         config.showDurations = \_showDurations}
\DoxyCodeLine{5196             ? ShowDurations::Always}
\DoxyCodeLine{5197             : ShowDurations::Never;}
\DoxyCodeLine{5198     \}}
\DoxyCodeLine{5199     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setUseColour( ConfigData\& config, std::string \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{5200         std::string mode = toLower( value );}
\DoxyCodeLine{5201 }
\DoxyCodeLine{5202         \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}yes"{}} )}
\DoxyCodeLine{5203             config.useColour = UseColour::Yes;}
\DoxyCodeLine{5204         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}no"{}} )}
\DoxyCodeLine{5205             config.useColour = UseColour::No;}
\DoxyCodeLine{5206         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}auto"{}} )}
\DoxyCodeLine{5207             config.useColour = UseColour::Auto;}
\DoxyCodeLine{5208         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5209             \textcolor{keywordflow}{throw} std::runtime\_error( \textcolor{stringliteral}{"{}colour mode must be one of: auto, yes or no"{}} );}
\DoxyCodeLine{5210     \}}
\DoxyCodeLine{5211     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setWaitForKeypress( ConfigData\& config, std::string \textcolor{keyword}{const}\& keypress ) \{}
\DoxyCodeLine{5212         std::string keypressLc = toLower( keypress );}
\DoxyCodeLine{5213         \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}start"{}} )}
\DoxyCodeLine{5214             config.waitForKeypress = WaitForKeypress::BeforeStart;}
\DoxyCodeLine{5215         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}exit"{}} )}
\DoxyCodeLine{5216             config.waitForKeypress = WaitForKeypress::BeforeExit;}
\DoxyCodeLine{5217         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}both"{}} )}
\DoxyCodeLine{5218             config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;}
\DoxyCodeLine{5219         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5220             \textcolor{keywordflow}{throw} std::runtime\_error( \textcolor{stringliteral}{"{}keypress argument must be one of: start, exit or both. '"{}} + keypress + \textcolor{stringliteral}{"{}' not recognised"{}} );}
\DoxyCodeLine{5221     \};}
\DoxyCodeLine{5222 }
\DoxyCodeLine{5223     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} forceColour( ConfigData\& config ) \{}
\DoxyCodeLine{5224         config.useColour = UseColour::Yes;}
\DoxyCodeLine{5225     \}}
\DoxyCodeLine{5226     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} loadTestNamesFromFile( ConfigData\& config, std::string \textcolor{keyword}{const}\& \_filename ) \{}
\DoxyCodeLine{5227         std::ifstream f( \_filename.c\_str() );}
\DoxyCodeLine{5228         \textcolor{keywordflow}{if}( !f.is\_open() )}
\DoxyCodeLine{5229             \textcolor{keywordflow}{throw} std::domain\_error( \textcolor{stringliteral}{"{}Unable to load input file: "{}} + \_filename );}
\DoxyCodeLine{5230 }
\DoxyCodeLine{5231         std::string line;}
\DoxyCodeLine{5232         \textcolor{keywordflow}{while}( std::getline( f, line ) ) \{}
\DoxyCodeLine{5233             line = trim(line);}
\DoxyCodeLine{5234             \textcolor{keywordflow}{if}( !line.empty() \&\& !startsWith( line, \textcolor{charliteral}{'\#'} ) ) \{}
\DoxyCodeLine{5235                 \textcolor{keywordflow}{if}( !startsWith( line, \textcolor{charliteral}{'"{}'} ) )}
\DoxyCodeLine{5236                     line = \textcolor{charliteral}{'"{}'} + line + '"{}';}
\DoxyCodeLine{5237                 addTestOrTags( config, line + \textcolor{charliteral}{','} );}
\DoxyCodeLine{5238             \}}
\DoxyCodeLine{5239         \}}
\DoxyCodeLine{5240     \}}
\DoxyCodeLine{5241 }
\DoxyCodeLine{5242     \textcolor{keyword}{inline} Clara::CommandLine<ConfigData> makeCommandLineParser() \{}
\DoxyCodeLine{5243 }
\DoxyCodeLine{5244         \textcolor{keyword}{using namespace }Clara;}
\DoxyCodeLine{5245         CommandLine<ConfigData> cli;}
\DoxyCodeLine{5246 }
\DoxyCodeLine{5247         cli.bindProcessName( \&ConfigData::processName );}
\DoxyCodeLine{5248 }
\DoxyCodeLine{5249         cli["{}-\/?"{}]["{}-\/h"{}]["{}-\/-\/help"{}]}
\DoxyCodeLine{5250             .describe( \textcolor{stringliteral}{"{}display usage information"{}} )}
\DoxyCodeLine{5251             .bind( \&ConfigData::showHelp );}
\DoxyCodeLine{5252 }
\DoxyCodeLine{5253         cli["{}-\/l"{}]["{}-\/-\/list-\/tests"{}]}
\DoxyCodeLine{5254             .describe( \textcolor{stringliteral}{"{}list all/matching test cases"{}} )}
\DoxyCodeLine{5255             .bind( \&ConfigData::listTests );}
\DoxyCodeLine{5256 }
\DoxyCodeLine{5257         cli["{}-\/t"{}]["{}-\/-\/list-\/tags"{}]}
\DoxyCodeLine{5258             .describe( \textcolor{stringliteral}{"{}list all/matching tags"{}} )}
\DoxyCodeLine{5259             .bind( \&ConfigData::listTags );}
\DoxyCodeLine{5260 }
\DoxyCodeLine{5261         cli["{}-\/s"{}]["{}-\/-\/success"{}]}
\DoxyCodeLine{5262             .describe( \textcolor{stringliteral}{"{}include successful tests in output"{}} )}
\DoxyCodeLine{5263             .bind( \&ConfigData::showSuccessfulTests );}
\DoxyCodeLine{5264 }
\DoxyCodeLine{5265         cli["{}-\/b"{}]["{}-\/-\/break"{}]}
\DoxyCodeLine{5266             .describe( \textcolor{stringliteral}{"{}break into debugger on failure"{}} )}
\DoxyCodeLine{5267             .bind( \&ConfigData::shouldDebugBreak );}
\DoxyCodeLine{5268 }
\DoxyCodeLine{5269         cli["{}-\/e"{}]["{}-\/-\/nothrow"{}]}
\DoxyCodeLine{5270             .describe( \textcolor{stringliteral}{"{}skip exception tests"{}} )}
\DoxyCodeLine{5271             .bind( \&ConfigData::noThrow );}
\DoxyCodeLine{5272 }
\DoxyCodeLine{5273         cli["{}-\/i"{}]["{}-\/-\/invisibles"{}]}
\DoxyCodeLine{5274             .describe( \textcolor{stringliteral}{"{}show invisibles (tabs, newlines)"{}} )}
\DoxyCodeLine{5275             .bind( \&ConfigData::showInvisibles );}
\DoxyCodeLine{5276 }
\DoxyCodeLine{5277         cli["{}-\/o"{}]["{}-\/-\/out"{}]}
\DoxyCodeLine{5278             .describe( \textcolor{stringliteral}{"{}output filename"{}} )}
\DoxyCodeLine{5279             .bind( \&ConfigData::outputFilename, \textcolor{stringliteral}{"{}filename"{}} );}
\DoxyCodeLine{5280 }
\DoxyCodeLine{5281         cli["{}-\/r"{}]["{}-\/-\/reporter"{}]}
\DoxyCodeLine{5282 \textcolor{comment}{//            .placeholder( "{}name[:filename]"{} )}}
\DoxyCodeLine{5283             .describe( \textcolor{stringliteral}{"{}reporter to use (defaults to console)"{}} )}
\DoxyCodeLine{5284             .bind( \&addReporterName, \textcolor{stringliteral}{"{}name"{}} );}
\DoxyCodeLine{5285 }
\DoxyCodeLine{5286         cli["{}-\/n"{}]["{}-\/-\/name"{}]}
\DoxyCodeLine{5287             .describe( \textcolor{stringliteral}{"{}suite name"{}} )}
\DoxyCodeLine{5288             .bind( \&ConfigData::name, \textcolor{stringliteral}{"{}name"{}} );}
\DoxyCodeLine{5289 }
\DoxyCodeLine{5290         cli["{}-\/a"{}]["{}-\/-\/abort"{}]}
\DoxyCodeLine{5291             .describe( \textcolor{stringliteral}{"{}abort at first failure"{}} )}
\DoxyCodeLine{5292             .bind( \&abortAfterFirst );}
\DoxyCodeLine{5293 }
\DoxyCodeLine{5294         cli["{}-\/x"{}]["{}-\/-\/abortx"{}]}
\DoxyCodeLine{5295             .describe( \textcolor{stringliteral}{"{}abort after x failures"{}} )}
\DoxyCodeLine{5296             .bind( \&abortAfterX, \textcolor{stringliteral}{"{}no. failures"{}} );}
\DoxyCodeLine{5297 }
\DoxyCodeLine{5298         cli["{}-\/w"{}]["{}-\/-\/warn"{}]}
\DoxyCodeLine{5299             .describe( \textcolor{stringliteral}{"{}enable warnings"{}} )}
\DoxyCodeLine{5300             .bind( \&addWarning, \textcolor{stringliteral}{"{}warning name"{}} );}
\DoxyCodeLine{5301 }
\DoxyCodeLine{5302 \textcolor{comment}{// -\/ needs updating if reinstated}}
\DoxyCodeLine{5303 \textcolor{comment}{//        cli.into( \&setVerbosity )}}
\DoxyCodeLine{5304 \textcolor{comment}{//            .describe( "{}level of verbosity (0=no output)"{} )}}
\DoxyCodeLine{5305 \textcolor{comment}{//            .shortOpt( "{}v"{})}}
\DoxyCodeLine{5306 \textcolor{comment}{//            .longOpt( "{}verbosity"{} )}}
\DoxyCodeLine{5307 \textcolor{comment}{//            .placeholder( "{}level"{} );}}
\DoxyCodeLine{5308 }
\DoxyCodeLine{5309         cli[\_]}
\DoxyCodeLine{5310             .describe( \textcolor{stringliteral}{"{}which test or tests to use"{}} )}
\DoxyCodeLine{5311             .bind( \&addTestOrTags, \textcolor{stringliteral}{"{}test name, pattern or tags"{}} );}
\DoxyCodeLine{5312 }
\DoxyCodeLine{5313         cli["{}-\/d"{}]["{}-\/-\/durations"{}]}
\DoxyCodeLine{5314             .describe( \textcolor{stringliteral}{"{}show test durations"{}} )}
\DoxyCodeLine{5315             .bind( \&setShowDurations, \textcolor{stringliteral}{"{}yes|no"{}} );}
\DoxyCodeLine{5316 }
\DoxyCodeLine{5317         cli["{}-\/f"{}]["{}-\/-\/input-\/file"{}]}
\DoxyCodeLine{5318             .describe( \textcolor{stringliteral}{"{}load test names to run from a file"{}} )}
\DoxyCodeLine{5319             .bind( \&loadTestNamesFromFile, \textcolor{stringliteral}{"{}filename"{}} );}
\DoxyCodeLine{5320 }
\DoxyCodeLine{5321         cli["{}-\/\#"{}]["{}-\/-\/filenames-\/as-\/tags"{}]}
\DoxyCodeLine{5322             .describe( \textcolor{stringliteral}{"{}adds a tag for the filename"{}} )}
\DoxyCodeLine{5323             .bind( \&ConfigData::filenamesAsTags );}
\DoxyCodeLine{5324 }
\DoxyCodeLine{5325         cli["{}-\/c"{}]["{}-\/-\/section"{}]}
\DoxyCodeLine{5326                 .describe( \textcolor{stringliteral}{"{}specify section to run"{}} )}
\DoxyCodeLine{5327                 .bind( \&addSectionToRun, \textcolor{stringliteral}{"{}section name"{}} );}
\DoxyCodeLine{5328 }
\DoxyCodeLine{5329         \textcolor{comment}{// Less common commands which don't have a short form}}
\DoxyCodeLine{5330         cli["{}-\/-\/list-\/test-\/names-\/only"{}]}
\DoxyCodeLine{5331             .describe( \textcolor{stringliteral}{"{}list all/matching test cases names only"{}} )}
\DoxyCodeLine{5332             .bind( \&ConfigData::listTestNamesOnly );}
\DoxyCodeLine{5333 }
\DoxyCodeLine{5334         cli["{}-\/-\/list-\/extra-\/info"{}]}
\DoxyCodeLine{5335             .describe( \textcolor{stringliteral}{"{}list all/matching test cases with more info"{}} )}
\DoxyCodeLine{5336             .bind( \&ConfigData::listExtraInfo );}
\DoxyCodeLine{5337 }
\DoxyCodeLine{5338         cli["{}-\/-\/list-\/reporters"{}]}
\DoxyCodeLine{5339             .describe( \textcolor{stringliteral}{"{}list all reporters"{}} )}
\DoxyCodeLine{5340             .bind( \&ConfigData::listReporters );}
\DoxyCodeLine{5341 }
\DoxyCodeLine{5342         cli["{}-\/-\/order"{}]}
\DoxyCodeLine{5343             .describe( \textcolor{stringliteral}{"{}test case order (defaults to decl)"{}} )}
\DoxyCodeLine{5344             .bind( \&setOrder, \textcolor{stringliteral}{"{}decl|lex|rand"{}} );}
\DoxyCodeLine{5345 }
\DoxyCodeLine{5346         cli["{}-\/-\/rng-\/seed"{}]}
\DoxyCodeLine{5347             .describe( \textcolor{stringliteral}{"{}set a specific seed for random numbers"{}} )}
\DoxyCodeLine{5348             .bind( \&setRngSeed, \textcolor{stringliteral}{"{}'time'|number"{}} );}
\DoxyCodeLine{5349 }
\DoxyCodeLine{5350         cli["{}-\/-\/force-\/colour"{}]}
\DoxyCodeLine{5351             .describe( \textcolor{stringliteral}{"{}force colourised output (deprecated)"{}} )}
\DoxyCodeLine{5352             .bind( \&forceColour );}
\DoxyCodeLine{5353 }
\DoxyCodeLine{5354         cli["{}-\/-\/use-\/colour"{}]}
\DoxyCodeLine{5355             .describe( \textcolor{stringliteral}{"{}should output be colourised"{}} )}
\DoxyCodeLine{5356             .bind( \&setUseColour, \textcolor{stringliteral}{"{}yes|no"{}} );}
\DoxyCodeLine{5357 }
\DoxyCodeLine{5358         cli["{}-\/-\/libidentify"{}]}
\DoxyCodeLine{5359             .describe( \textcolor{stringliteral}{"{}report name and version according to libidentify standard"{}} )}
\DoxyCodeLine{5360             .bind( \&ConfigData::libIdentify );}
\DoxyCodeLine{5361 }
\DoxyCodeLine{5362         cli["{}-\/-\/wait-\/for-\/keypress"{}]}
\DoxyCodeLine{5363                 .describe( \textcolor{stringliteral}{"{}waits for a keypress before exiting"{}} )}
\DoxyCodeLine{5364                 .bind( \&setWaitForKeypress, \textcolor{stringliteral}{"{}start|exit|both"{}} );}
\DoxyCodeLine{5365 }
\DoxyCodeLine{5366         \textcolor{keywordflow}{return} cli;}
\DoxyCodeLine{5367     \}}
\DoxyCodeLine{5368 }
\DoxyCodeLine{5369 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5370 }
\DoxyCodeLine{5371 \textcolor{comment}{// \#included from: internal/catch\_list.hpp}}
\DoxyCodeLine{5372 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_LIST\_HPP\_INCLUDED}}
\DoxyCodeLine{5373 }
\DoxyCodeLine{5374 \textcolor{comment}{// \#included from: catch\_text.h}}
\DoxyCodeLine{5375 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TEXT\_H\_INCLUDED}}
\DoxyCodeLine{5376 }
\DoxyCodeLine{5377 \textcolor{preprocessor}{\#define TBC\_TEXT\_FORMAT\_CONSOLE\_WIDTH CATCH\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{5378 }
\DoxyCodeLine{5379 \textcolor{preprocessor}{\#define CLICHE\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE Catch}}
\DoxyCodeLine{5380 \textcolor{comment}{// \#included from: ../external/tbc\_text\_format.h}}
\DoxyCodeLine{5381 \textcolor{comment}{// Only use header guard if we are not using an outer namespace}}
\DoxyCodeLine{5382 \textcolor{preprocessor}{\#ifndef CLICHE\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE}}
\DoxyCodeLine{5383 \textcolor{preprocessor}{\# ifdef TWOBLUECUBES\_TEXT\_FORMAT\_H\_INCLUDED}}
\DoxyCodeLine{5384 \textcolor{preprocessor}{\#  ifndef TWOBLUECUBES\_TEXT\_FORMAT\_H\_ALREADY\_INCLUDED}}
\DoxyCodeLine{5385 \textcolor{preprocessor}{\#   define TWOBLUECUBES\_TEXT\_FORMAT\_H\_ALREADY\_INCLUDED}}
\DoxyCodeLine{5386 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{5387 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{5388 \textcolor{preprocessor}{\#  define TWOBLUECUBES\_TEXT\_FORMAT\_H\_INCLUDED}}
\DoxyCodeLine{5389 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{5390 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5391 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_TEXT\_FORMAT\_H\_ALREADY\_INCLUDED}}
\DoxyCodeLine{5392 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5393 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5394 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{5395 }
\DoxyCodeLine{5396 \textcolor{comment}{// Use optional outer namespace}}
\DoxyCodeLine{5397 \textcolor{preprocessor}{\#ifdef CLICHE\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE}}
\DoxyCodeLine{5398 \textcolor{keyword}{namespace }CLICHE\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE \{}
\DoxyCodeLine{5399 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5400 }
\DoxyCodeLine{5401 \textcolor{keyword}{namespace }Tbc \{}
\DoxyCodeLine{5402 }
\DoxyCodeLine{5403 \textcolor{preprocessor}{\#ifdef TBC\_TEXT\_FORMAT\_CONSOLE\_WIDTH}}
\DoxyCodeLine{5404     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} consoleWidth = TBC\_TEXT\_FORMAT\_CONSOLE\_WIDTH;}
\DoxyCodeLine{5405 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{5406     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} consoleWidth = 80;}
\DoxyCodeLine{5407 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5408 }
\DoxyCodeLine{5409     \textcolor{keyword}{struct }TextAttributes \{}
\DoxyCodeLine{5410         TextAttributes()}
\DoxyCodeLine{5411         :   initialIndent( std::string::npos ),}
\DoxyCodeLine{5412             indent( 0 ),}
\DoxyCodeLine{5413             width( consoleWidth-\/1 )}
\DoxyCodeLine{5414         \{\}}
\DoxyCodeLine{5415 }
\DoxyCodeLine{5416         TextAttributes\& setInitialIndent( std::size\_t \_value )  \{ initialIndent = \_value; \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{5417         TextAttributes\& setIndent( std::size\_t \_value )         \{ indent = \_value; \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{5418         TextAttributes\& setWidth( std::size\_t \_value )          \{ width = \_value; \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{5419 }
\DoxyCodeLine{5420         std::size\_t initialIndent;  \textcolor{comment}{// indent of first line, or npos}}
\DoxyCodeLine{5421         std::size\_t indent;         \textcolor{comment}{// indent of subsequent lines, or all if initialIndent is npos}}
\DoxyCodeLine{5422         std::size\_t width;          \textcolor{comment}{// maximum width of text, including indent. Longer text will wrap}}
\DoxyCodeLine{5423     \};}
\DoxyCodeLine{5424 }
\DoxyCodeLine{5425     \textcolor{keyword}{class }Text \{}
\DoxyCodeLine{5426     \textcolor{keyword}{public}:}
\DoxyCodeLine{5427         Text( std::string \textcolor{keyword}{const}\& \_str, TextAttributes \textcolor{keyword}{const}\& \_attr = TextAttributes() )}
\DoxyCodeLine{5428         : attr( \_attr )}
\DoxyCodeLine{5429         \{}
\DoxyCodeLine{5430             \textcolor{keyword}{const} std::string wrappableBeforeChars = \textcolor{stringliteral}{"{}[(\{<\(\backslash\)t"{}};}
\DoxyCodeLine{5431             \textcolor{keyword}{const} std::string wrappableAfterChars = \textcolor{stringliteral}{"{}])\}>-\/,./|\(\backslash\)\(\backslash\)"{}};}
\DoxyCodeLine{5432             \textcolor{keyword}{const} std::string wrappableInsteadOfChars = \textcolor{stringliteral}{"{} \(\backslash\)n\(\backslash\)r"{}};}
\DoxyCodeLine{5433             std::string indent = \_attr.initialIndent != std::string::npos}
\DoxyCodeLine{5434                 ? std::string( \_attr.initialIndent, \textcolor{charliteral}{' '} )}
\DoxyCodeLine{5435                 : std::string( \_attr.indent, \textcolor{stringliteral}{' '} );}
\DoxyCodeLine{5436 }
\DoxyCodeLine{5437             \textcolor{keyword}{typedef} std::string::const\_iterator iterator;}
\DoxyCodeLine{5438             iterator it = \_str.begin();}
\DoxyCodeLine{5439             \textcolor{keyword}{const} iterator strEnd = \_str.end();}
\DoxyCodeLine{5440 }
\DoxyCodeLine{5441             \textcolor{keywordflow}{while}( it != strEnd ) \{}
\DoxyCodeLine{5442 }
\DoxyCodeLine{5443                 \textcolor{keywordflow}{if}( lines.size() >= 1000 ) \{}
\DoxyCodeLine{5444                     lines.push\_back( \textcolor{stringliteral}{"{}... message truncated due to excessive size"{}} );}
\DoxyCodeLine{5445                     \textcolor{keywordflow}{return};}
\DoxyCodeLine{5446                 \}}
\DoxyCodeLine{5447 }
\DoxyCodeLine{5448                 std::string suffix;}
\DoxyCodeLine{5449                 std::size\_t width = (std::min)( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}( strEnd-\/it ), \_attr.width-\/static\_cast<size\_t>( indent.size() ) );}
\DoxyCodeLine{5450                 iterator itEnd = it+width;}
\DoxyCodeLine{5451                 iterator itNext = \_str.end();}
\DoxyCodeLine{5452 }
\DoxyCodeLine{5453                 iterator itNewLine = std::find( it, itEnd, \textcolor{charliteral}{'\(\backslash\)n'} );}
\DoxyCodeLine{5454                 \textcolor{keywordflow}{if}( itNewLine != itEnd )}
\DoxyCodeLine{5455                     itEnd = itNewLine;}
\DoxyCodeLine{5456 }
\DoxyCodeLine{5457                 \textcolor{keywordflow}{if}( itEnd != strEnd  ) \{}
\DoxyCodeLine{5458                     \textcolor{keywordtype}{bool} foundWrapPoint = \textcolor{keyword}{false};}
\DoxyCodeLine{5459                     iterator findIt = itEnd;}
\DoxyCodeLine{5460                     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{5461                         \textcolor{keywordflow}{if}( wrappableAfterChars.find( *findIt ) != std::string::npos \&\& findIt != itEnd ) \{}
\DoxyCodeLine{5462                             itEnd = findIt+1;}
\DoxyCodeLine{5463                             itNext = findIt+1;}
\DoxyCodeLine{5464                             foundWrapPoint = \textcolor{keyword}{true};}
\DoxyCodeLine{5465                         \}}
\DoxyCodeLine{5466                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( findIt > it \&\& wrappableBeforeChars.find( *findIt ) != std::string::npos ) \{}
\DoxyCodeLine{5467                             itEnd = findIt;}
\DoxyCodeLine{5468                             itNext = findIt;}
\DoxyCodeLine{5469                             foundWrapPoint = \textcolor{keyword}{true};}
\DoxyCodeLine{5470                         \}}
\DoxyCodeLine{5471                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( wrappableInsteadOfChars.find( *findIt ) != std::string::npos ) \{}
\DoxyCodeLine{5472                             itNext = findIt+1;}
\DoxyCodeLine{5473                             itEnd = findIt;}
\DoxyCodeLine{5474                             foundWrapPoint = \textcolor{keyword}{true};}
\DoxyCodeLine{5475                         \}}
\DoxyCodeLine{5476                         \textcolor{keywordflow}{if}( findIt == it )}
\DoxyCodeLine{5477                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{5478                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5479                             -\/-\/findIt;}
\DoxyCodeLine{5480                     \}}
\DoxyCodeLine{5481                     \textcolor{keywordflow}{while}( !foundWrapPoint );}
\DoxyCodeLine{5482 }
\DoxyCodeLine{5483                     \textcolor{keywordflow}{if}( !foundWrapPoint ) \{}
\DoxyCodeLine{5484                         \textcolor{comment}{// No good wrap char, so we'll break mid word and add a hyphen}}
\DoxyCodeLine{5485                         -\/-\/itEnd;}
\DoxyCodeLine{5486                         itNext = itEnd;}
\DoxyCodeLine{5487                         suffix = \textcolor{stringliteral}{"{}-\/"{}};}
\DoxyCodeLine{5488                     \}}
\DoxyCodeLine{5489                     \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5490                         \textcolor{keywordflow}{while}( itEnd > it \&\& wrappableInsteadOfChars.find( *(itEnd-\/1) ) != std::string::npos )}
\DoxyCodeLine{5491                             -\/-\/itEnd;}
\DoxyCodeLine{5492                     \}}
\DoxyCodeLine{5493                 \}}
\DoxyCodeLine{5494                 lines.push\_back( indent + std::string( it, itEnd ) + suffix );}
\DoxyCodeLine{5495 }
\DoxyCodeLine{5496                 \textcolor{keywordflow}{if}( indent.size() != \_attr.indent )}
\DoxyCodeLine{5497                     indent = std::string( \_attr.indent, \textcolor{charliteral}{' '} );}
\DoxyCodeLine{5498                 it = itNext;}
\DoxyCodeLine{5499             \}}
\DoxyCodeLine{5500         \}}
\DoxyCodeLine{5501 }
\DoxyCodeLine{5502         \textcolor{keyword}{typedef} std::vector<std::string>::const\_iterator const\_iterator;}
\DoxyCodeLine{5503 }
\DoxyCodeLine{5504         const\_iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines.begin(); \}}
\DoxyCodeLine{5505         const\_iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines.end(); \}}
\DoxyCodeLine{5506         std::string \textcolor{keyword}{const}\& last()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines.back(); \}}
\DoxyCodeLine{5507         std::size\_t size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines.size(); \}}
\DoxyCodeLine{5508         std::string \textcolor{keyword}{const}\& operator[]( std::size\_t \_index )\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lines[\_index]; \}}
\DoxyCodeLine{5509         std::string toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5510             std::ostringstream oss;}
\DoxyCodeLine{5511             oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{5512             \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{5513         \}}
\DoxyCodeLine{5514 }
\DoxyCodeLine{5515         \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& \_stream, Text \textcolor{keyword}{const}\& \_text ) \{}
\DoxyCodeLine{5516             \textcolor{keywordflow}{for}( Text::const\_iterator it = \_text.begin(), itEnd = \_text.end();}
\DoxyCodeLine{5517                 it != itEnd; ++it ) \{}
\DoxyCodeLine{5518                 \textcolor{keywordflow}{if}( it != \_text.begin() )}
\DoxyCodeLine{5519                     \_stream << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{5520                 \_stream << *it;}
\DoxyCodeLine{5521             \}}
\DoxyCodeLine{5522             \textcolor{keywordflow}{return} \_stream;}
\DoxyCodeLine{5523         \}}
\DoxyCodeLine{5524 }
\DoxyCodeLine{5525     \textcolor{keyword}{private}:}
\DoxyCodeLine{5526         std::string str;}
\DoxyCodeLine{5527         TextAttributes attr;}
\DoxyCodeLine{5528         std::vector<std::string> lines;}
\DoxyCodeLine{5529     \};}
\DoxyCodeLine{5530 }
\DoxyCodeLine{5531 \} \textcolor{comment}{// end namespace Tbc}}
\DoxyCodeLine{5532 }
\DoxyCodeLine{5533 \textcolor{preprocessor}{\#ifdef CLICHE\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE}}
\DoxyCodeLine{5534 \} \textcolor{comment}{// end outer namespace}}
\DoxyCodeLine{5535 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5536 }
\DoxyCodeLine{5537 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_TEXT\_FORMAT\_H\_ALREADY\_INCLUDED}}
\DoxyCodeLine{5538 \textcolor{preprocessor}{\#undef CLICHE\_TBC\_TEXT\_FORMAT\_OUTER\_NAMESPACE}}
\DoxyCodeLine{5539 }
\DoxyCodeLine{5540 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5541     \textcolor{keyword}{using }Tbc::Text;}
\DoxyCodeLine{5542     \textcolor{keyword}{using }Tbc::TextAttributes;}
\DoxyCodeLine{5543 \}}
\DoxyCodeLine{5544 }
\DoxyCodeLine{5545 \textcolor{comment}{// \#included from: catch\_console\_colour.hpp}}
\DoxyCodeLine{5546 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_CONSOLE\_COLOUR\_HPP\_INCLUDED}}
\DoxyCodeLine{5547 }
\DoxyCodeLine{5548 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5549 }
\DoxyCodeLine{5550     \textcolor{keyword}{struct }Colour \{}
\DoxyCodeLine{5551         \textcolor{keyword}{enum} Code \{}
\DoxyCodeLine{5552             \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}} = 0,}
\DoxyCodeLine{5553 }
\DoxyCodeLine{5554             White,}
\DoxyCodeLine{5555             Red,}
\DoxyCodeLine{5556             Green,}
\DoxyCodeLine{5557             Blue,}
\DoxyCodeLine{5558             Cyan,}
\DoxyCodeLine{5559             Yellow,}
\DoxyCodeLine{5560             Grey,}
\DoxyCodeLine{5561 }
\DoxyCodeLine{5562             Bright = 0x10,}
\DoxyCodeLine{5563 }
\DoxyCodeLine{5564             BrightRed = Bright | Red,}
\DoxyCodeLine{5565             BrightGreen = Bright | Green,}
\DoxyCodeLine{5566             LightGrey = Bright | Grey,}
\DoxyCodeLine{5567             BrightWhite = Bright | White,}
\DoxyCodeLine{5568 }
\DoxyCodeLine{5569             \textcolor{comment}{// By intention}}
\DoxyCodeLine{5570             FileName = LightGrey,}
\DoxyCodeLine{5571             Warning = Yellow,}
\DoxyCodeLine{5572             ResultError = BrightRed,}
\DoxyCodeLine{5573             ResultSuccess = BrightGreen,}
\DoxyCodeLine{5574             ResultExpectedFailure = Warning,}
\DoxyCodeLine{5575 }
\DoxyCodeLine{5576             Error = BrightRed,}
\DoxyCodeLine{5577             Success = Green,}
\DoxyCodeLine{5578 }
\DoxyCodeLine{5579             OriginalExpression = Cyan,}
\DoxyCodeLine{5580             ReconstructedExpression = Yellow,}
\DoxyCodeLine{5581 }
\DoxyCodeLine{5582             SecondaryText = LightGrey,}
\DoxyCodeLine{5583             Headers = White}
\DoxyCodeLine{5584         \};}
\DoxyCodeLine{5585 }
\DoxyCodeLine{5586         \textcolor{comment}{// Use constructed object for RAII guard}}
\DoxyCodeLine{5587         Colour( Code \_colourCode );}
\DoxyCodeLine{5588         Colour( Colour \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{5589         \string~Colour();}
\DoxyCodeLine{5590 }
\DoxyCodeLine{5591         \textcolor{comment}{// Use static method for one-\/shot changes}}
\DoxyCodeLine{5592         \textcolor{keyword}{static} \textcolor{keywordtype}{void} use( Code \_colourCode );}
\DoxyCodeLine{5593 }
\DoxyCodeLine{5594     \textcolor{keyword}{private}:}
\DoxyCodeLine{5595         \textcolor{keywordtype}{bool} m\_moved;}
\DoxyCodeLine{5596     \};}
\DoxyCodeLine{5597 }
\DoxyCodeLine{5598     \textcolor{keyword}{inline} std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& ) \{ \textcolor{keywordflow}{return} os; \}}
\DoxyCodeLine{5599 }
\DoxyCodeLine{5600 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5601 }
\DoxyCodeLine{5602 \textcolor{comment}{// \#included from: catch\_interfaces\_reporter.h}}
\DoxyCodeLine{5603 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_INTERFACES\_REPORTER\_H\_INCLUDED}}
\DoxyCodeLine{5604 }
\DoxyCodeLine{5605 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5606 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{5607 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{5608 }
\DoxyCodeLine{5609 \textcolor{keyword}{namespace }Catch}
\DoxyCodeLine{5610 \{}
\DoxyCodeLine{5611     \textcolor{keyword}{struct }ReporterConfig \{}
\DoxyCodeLine{5612         \textcolor{keyword}{explicit} ReporterConfig( Ptr<IConfig const> \textcolor{keyword}{const}\& \_fullConfig )}
\DoxyCodeLine{5613         :   m\_stream( \&\_fullConfig-\/>stream() ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{5614 }
\DoxyCodeLine{5615         ReporterConfig( Ptr<IConfig const> \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream )}
\DoxyCodeLine{5616         :   m\_stream( \&\_stream ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{5617 }
\DoxyCodeLine{5618         std::ostream\& stream()\textcolor{keyword}{ const    }\{ \textcolor{keywordflow}{return} *m\_stream; \}}
\DoxyCodeLine{5619         Ptr<IConfig const> fullConfig()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_fullConfig; \}}
\DoxyCodeLine{5620 }
\DoxyCodeLine{5621     \textcolor{keyword}{private}:}
\DoxyCodeLine{5622         std::ostream* m\_stream;}
\DoxyCodeLine{5623         Ptr<IConfig const> m\_fullConfig;}
\DoxyCodeLine{5624     \};}
\DoxyCodeLine{5625 }
\DoxyCodeLine{5626     \textcolor{keyword}{struct }ReporterPreferences \{}
\DoxyCodeLine{5627         ReporterPreferences()}
\DoxyCodeLine{5628         : shouldRedirectStdOut( false )}
\DoxyCodeLine{5629         \{\}}
\DoxyCodeLine{5630 }
\DoxyCodeLine{5631         \textcolor{keywordtype}{bool} shouldRedirectStdOut;}
\DoxyCodeLine{5632     \};}
\DoxyCodeLine{5633 }
\DoxyCodeLine{5634     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5635     \textcolor{keyword}{struct }LazyStat : Option<T> \{}
\DoxyCodeLine{5636         LazyStat() : used( false ) \{\}}
\DoxyCodeLine{5637         LazyStat\& operator=( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{5638             Option<T>::operator=( \_value );}
\DoxyCodeLine{5639             used = \textcolor{keyword}{false};}
\DoxyCodeLine{5640             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{5641         \}}
\DoxyCodeLine{5642         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{5643             Option<T>::reset();}
\DoxyCodeLine{5644             used = \textcolor{keyword}{false};}
\DoxyCodeLine{5645         \}}
\DoxyCodeLine{5646         \textcolor{keywordtype}{bool} used;}
\DoxyCodeLine{5647     \};}
\DoxyCodeLine{5648 }
\DoxyCodeLine{5649     \textcolor{keyword}{struct }TestRunInfo \{}
\DoxyCodeLine{5650         TestRunInfo( std::string \textcolor{keyword}{const}\& \_name ) : name( \_name ) \{\}}
\DoxyCodeLine{5651         std::string name;}
\DoxyCodeLine{5652     \};}
\DoxyCodeLine{5653     \textcolor{keyword}{struct }GroupInfo \{}
\DoxyCodeLine{5654         GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{5655                     std::size\_t \_groupIndex,}
\DoxyCodeLine{5656                     std::size\_t \_groupsCount )}
\DoxyCodeLine{5657         :   name( \_name ),}
\DoxyCodeLine{5658             groupIndex( \_groupIndex ),}
\DoxyCodeLine{5659             groupsCounts( \_groupsCount )}
\DoxyCodeLine{5660         \{\}}
\DoxyCodeLine{5661 }
\DoxyCodeLine{5662         std::string name;}
\DoxyCodeLine{5663         std::size\_t groupIndex;}
\DoxyCodeLine{5664         std::size\_t groupsCounts;}
\DoxyCodeLine{5665     \};}
\DoxyCodeLine{5666 }
\DoxyCodeLine{5667     \textcolor{keyword}{struct }AssertionStats \{}
\DoxyCodeLine{5668         AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{5669                         std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{5670                         Totals \textcolor{keyword}{const}\& \_totals )}
\DoxyCodeLine{5671         :   assertionResult( \_assertionResult ),}
\DoxyCodeLine{5672             infoMessages( \_infoMessages ),}
\DoxyCodeLine{5673             totals( \_totals )}
\DoxyCodeLine{5674         \{}
\DoxyCodeLine{5675             \textcolor{keywordflow}{if}( assertionResult.hasMessage() ) \{}
\DoxyCodeLine{5676                 \textcolor{comment}{// Copy message into messages list.}}
\DoxyCodeLine{5677                 \textcolor{comment}{// !TBD This should have been done earlier, somewhere}}
\DoxyCodeLine{5678                 MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );}
\DoxyCodeLine{5679                 builder << assertionResult.getMessage();}
\DoxyCodeLine{5680                 builder.m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{5681 }
\DoxyCodeLine{5682                 infoMessages.push\_back( builder.m\_info );}
\DoxyCodeLine{5683             \}}
\DoxyCodeLine{5684         \}}
\DoxyCodeLine{5685         \textcolor{keyword}{virtual} \string~AssertionStats();}
\DoxyCodeLine{5686 }
\DoxyCodeLine{5687 \textcolor{preprocessor}{\#  ifdef CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{5688         AssertionStats( AssertionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5689         AssertionStats( AssertionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5690         AssertionStats\& operator = ( AssertionStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5691         AssertionStats\& operator = ( AssertionStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5692 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{5693 }
\DoxyCodeLine{5694         AssertionResult assertionResult;}
\DoxyCodeLine{5695         std::vector<MessageInfo> infoMessages;}
\DoxyCodeLine{5696         Totals totals;}
\DoxyCodeLine{5697     \};}
\DoxyCodeLine{5698 }
\DoxyCodeLine{5699     \textcolor{keyword}{struct }SectionStats \{}
\DoxyCodeLine{5700         SectionStats(   SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{5701                         Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{5702                         \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{5703                         \textcolor{keywordtype}{bool} \_missingAssertions )}
\DoxyCodeLine{5704         :   sectionInfo( \_sectionInfo ),}
\DoxyCodeLine{5705             assertions( \_assertions ),}
\DoxyCodeLine{5706             durationInSeconds( \_durationInSeconds ),}
\DoxyCodeLine{5707             missingAssertions( \_missingAssertions )}
\DoxyCodeLine{5708         \{\}}
\DoxyCodeLine{5709         \textcolor{keyword}{virtual} \string~SectionStats();}
\DoxyCodeLine{5710 \textcolor{preprocessor}{\#  ifdef CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{5711         SectionStats( SectionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5712         SectionStats( SectionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5713         SectionStats\& operator = ( SectionStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5714         SectionStats\& operator = ( SectionStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5715 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{5716 }
\DoxyCodeLine{5717         SectionInfo sectionInfo;}
\DoxyCodeLine{5718         Counts assertions;}
\DoxyCodeLine{5719         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{5720         \textcolor{keywordtype}{bool} missingAssertions;}
\DoxyCodeLine{5721     \};}
\DoxyCodeLine{5722 }
\DoxyCodeLine{5723     \textcolor{keyword}{struct }TestCaseStats \{}
\DoxyCodeLine{5724         TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{5725                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5726                         std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{5727                         std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{5728                         \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{5729         : testInfo( \_testInfo ),}
\DoxyCodeLine{5730             totals( \_totals ),}
\DoxyCodeLine{5731             stdOut( \_stdOut ),}
\DoxyCodeLine{5732             stdErr( \_stdErr ),}
\DoxyCodeLine{5733             aborting( \_aborting )}
\DoxyCodeLine{5734         \{\}}
\DoxyCodeLine{5735         \textcolor{keyword}{virtual} \string~TestCaseStats();}
\DoxyCodeLine{5736 }
\DoxyCodeLine{5737 \textcolor{preprocessor}{\#  ifdef CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{5738         TestCaseStats( TestCaseStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5739         TestCaseStats( TestCaseStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5740         TestCaseStats\& operator = ( TestCaseStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5741         TestCaseStats\& operator = ( TestCaseStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5742 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{5743 }
\DoxyCodeLine{5744         TestCaseInfo testInfo;}
\DoxyCodeLine{5745         Totals totals;}
\DoxyCodeLine{5746         std::string stdOut;}
\DoxyCodeLine{5747         std::string stdErr;}
\DoxyCodeLine{5748         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5749     \};}
\DoxyCodeLine{5750 }
\DoxyCodeLine{5751     \textcolor{keyword}{struct }TestGroupStats \{}
\DoxyCodeLine{5752         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{5753                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5754                         \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{5755         :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{5756             totals( \_totals ),}
\DoxyCodeLine{5757             aborting( \_aborting )}
\DoxyCodeLine{5758         \{\}}
\DoxyCodeLine{5759         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo )}
\DoxyCodeLine{5760         :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{5761             aborting( false )}
\DoxyCodeLine{5762         \{\}}
\DoxyCodeLine{5763         \textcolor{keyword}{virtual} \string~TestGroupStats();}
\DoxyCodeLine{5764 }
\DoxyCodeLine{5765 \textcolor{preprocessor}{\#  ifdef CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{5766         TestGroupStats( TestGroupStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5767         TestGroupStats( TestGroupStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5768         TestGroupStats\& operator = ( TestGroupStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5769         TestGroupStats\& operator = ( TestGroupStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5770 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{5771 }
\DoxyCodeLine{5772         GroupInfo groupInfo;}
\DoxyCodeLine{5773         Totals totals;}
\DoxyCodeLine{5774         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5775     \};}
\DoxyCodeLine{5776 }
\DoxyCodeLine{5777     \textcolor{keyword}{struct }TestRunStats \{}
\DoxyCodeLine{5778         TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{5779                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5780                         \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{5781         :   runInfo( \_runInfo ),}
\DoxyCodeLine{5782             totals( \_totals ),}
\DoxyCodeLine{5783             aborting( \_aborting )}
\DoxyCodeLine{5784         \{\}}
\DoxyCodeLine{5785         \textcolor{keyword}{virtual} \string~TestRunStats();}
\DoxyCodeLine{5786 }
\DoxyCodeLine{5787 \textcolor{preprocessor}{\#  ifndef CATCH\_CONFIG\_CPP11\_GENERATED\_METHODS}}
\DoxyCodeLine{5788         TestRunStats( TestRunStats \textcolor{keyword}{const}\& \_other )}
\DoxyCodeLine{5789         :   runInfo( \_other.runInfo ),}
\DoxyCodeLine{5790             totals( \_other.totals ),}
\DoxyCodeLine{5791             aborting( \_other.aborting )}
\DoxyCodeLine{5792         \{\}}
\DoxyCodeLine{5793 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{5794         TestRunStats( TestRunStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5795         TestRunStats( TestRunStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5796         TestRunStats\& operator = ( TestRunStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5797         TestRunStats\& operator = ( TestRunStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5798 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{5799 }
\DoxyCodeLine{5800         TestRunInfo runInfo;}
\DoxyCodeLine{5801         Totals totals;}
\DoxyCodeLine{5802         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5803     \};}
\DoxyCodeLine{5804 }
\DoxyCodeLine{5805     \textcolor{keyword}{class }MultipleReporters;}
\DoxyCodeLine{5806 }
\DoxyCodeLine{5807     \textcolor{keyword}{struct }IStreamingReporter : IShared \{}
\DoxyCodeLine{5808         \textcolor{keyword}{virtual} \string~IStreamingReporter();}
\DoxyCodeLine{5809 }
\DoxyCodeLine{5810         \textcolor{comment}{// Implementing class must also provide the following static method:}}
\DoxyCodeLine{5811         \textcolor{comment}{// static std::string getDescription();}}
\DoxyCodeLine{5812 }
\DoxyCodeLine{5813         \textcolor{keyword}{virtual} ReporterPreferences getPreferences() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5814 }
\DoxyCodeLine{5815         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) = 0;}
\DoxyCodeLine{5816 }
\DoxyCodeLine{5817         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) = 0;}
\DoxyCodeLine{5818         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) = 0;}
\DoxyCodeLine{5819 }
\DoxyCodeLine{5820         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{5821         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) = 0;}
\DoxyCodeLine{5822 }
\DoxyCodeLine{5823         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) = 0;}
\DoxyCodeLine{5824 }
\DoxyCodeLine{5825         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{5826         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) = 0;}
\DoxyCodeLine{5827 }
\DoxyCodeLine{5828         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) = 0;}
\DoxyCodeLine{5829         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) = 0;}
\DoxyCodeLine{5830         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) = 0;}
\DoxyCodeLine{5831         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) = 0;}
\DoxyCodeLine{5832 }
\DoxyCodeLine{5833         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{5834 }
\DoxyCodeLine{5835         \textcolor{keyword}{virtual} MultipleReporters* tryAsMulti() \{ \textcolor{keywordflow}{return} CATCH\_NULL; \}}
\DoxyCodeLine{5836     \};}
\DoxyCodeLine{5837 }
\DoxyCodeLine{5838     \textcolor{keyword}{struct }IReporterFactory : IShared \{}
\DoxyCodeLine{5839         \textcolor{keyword}{virtual} \string~IReporterFactory();}
\DoxyCodeLine{5840         \textcolor{keyword}{virtual} IStreamingReporter* create( ReporterConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5841         \textcolor{keyword}{virtual} std::string getDescription() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5842     \};}
\DoxyCodeLine{5843 }
\DoxyCodeLine{5844     \textcolor{keyword}{struct }IReporterRegistry \{}
\DoxyCodeLine{5845         \textcolor{keyword}{typedef} std::map<std::string, Ptr<IReporterFactory> > FactoryMap;}
\DoxyCodeLine{5846         \textcolor{keyword}{typedef} std::vector<Ptr<IReporterFactory> > Listeners;}
\DoxyCodeLine{5847 }
\DoxyCodeLine{5848         \textcolor{keyword}{virtual} \string~IReporterRegistry();}
\DoxyCodeLine{5849         \textcolor{keyword}{virtual} IStreamingReporter* create( std::string \textcolor{keyword}{const}\& name, Ptr<IConfig const> \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5850         \textcolor{keyword}{virtual} FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5851         \textcolor{keyword}{virtual} Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5852     \};}
\DoxyCodeLine{5853 }
\DoxyCodeLine{5854     Ptr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> \textcolor{keyword}{const}\& existingReporter, Ptr<IStreamingReporter> \textcolor{keyword}{const}\& additionalReporter );}
\DoxyCodeLine{5855 }
\DoxyCodeLine{5856 \}}
\DoxyCodeLine{5857 }
\DoxyCodeLine{5858 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{5859 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{5860 }
\DoxyCodeLine{5861 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5862 }
\DoxyCodeLine{5863     \textcolor{keyword}{inline} std::size\_t listTests( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{5864 }
\DoxyCodeLine{5865         TestSpec testSpec = config.testSpec();}
\DoxyCodeLine{5866         \textcolor{keywordflow}{if}( config.testSpec().hasFilters() )}
\DoxyCodeLine{5867             Catch::cout() << \textcolor{stringliteral}{"{}Matching test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{5868         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5869             Catch::cout() << \textcolor{stringliteral}{"{}All available test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{5870             testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( \textcolor{stringliteral}{"{}*"{}} ).testSpec();}
\DoxyCodeLine{5871         \}}
\DoxyCodeLine{5872 }
\DoxyCodeLine{5873         std::size\_t matchedTests = 0;}
\DoxyCodeLine{5874         TextAttributes nameAttr, descAttr, tagsAttr;}
\DoxyCodeLine{5875         nameAttr.setInitialIndent( 2 ).setIndent( 4 );}
\DoxyCodeLine{5876         descAttr.setIndent( 4 );}
\DoxyCodeLine{5877         tagsAttr.setIndent( 6 );}
\DoxyCodeLine{5878 }
\DoxyCodeLine{5879         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{5880         \textcolor{keywordflow}{for}( std::vector<TestCase>::const\_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();}
\DoxyCodeLine{5881                 it != itEnd;}
\DoxyCodeLine{5882                 ++it ) \{}
\DoxyCodeLine{5883             matchedTests++;}
\DoxyCodeLine{5884             TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo = it-\/>getTestCaseInfo();}
\DoxyCodeLine{5885             Colour::Code colour = testCaseInfo.isHidden()}
\DoxyCodeLine{5886                 ? Colour::SecondaryText}
\DoxyCodeLine{5887                 : Colour::None;}
\DoxyCodeLine{5888             Colour colourGuard( colour );}
\DoxyCodeLine{5889 }
\DoxyCodeLine{5890             Catch::cout() << Text( testCaseInfo.name, nameAttr ) << std::endl;}
\DoxyCodeLine{5891             \textcolor{keywordflow}{if}( config.listExtraInfo() ) \{}
\DoxyCodeLine{5892                 Catch::cout() << \textcolor{stringliteral}{"{}    "{}} << testCaseInfo.lineInfo << std::endl;}
\DoxyCodeLine{5893                 std::string description = testCaseInfo.description;}
\DoxyCodeLine{5894                 \textcolor{keywordflow}{if}( description.empty() )}
\DoxyCodeLine{5895                     description = \textcolor{stringliteral}{"{}(NO DESCRIPTION)"{}};}
\DoxyCodeLine{5896                 Catch::cout() << Text( description, descAttr ) << std::endl;}
\DoxyCodeLine{5897             \}}
\DoxyCodeLine{5898             \textcolor{keywordflow}{if}( !testCaseInfo.tags.empty() )}
\DoxyCodeLine{5899                 Catch::cout() << Text( testCaseInfo.tagsAsString, tagsAttr ) << std::endl;}
\DoxyCodeLine{5900         \}}
\DoxyCodeLine{5901 }
\DoxyCodeLine{5902         \textcolor{keywordflow}{if}( !config.testSpec().hasFilters() )}
\DoxyCodeLine{5903             Catch::cout() << pluralise( matchedTests, \textcolor{stringliteral}{"{}test case"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{5904         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5905             Catch::cout() << pluralise( matchedTests, \textcolor{stringliteral}{"{}matching test case"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{5906         \textcolor{keywordflow}{return} matchedTests;}
\DoxyCodeLine{5907     \}}
\DoxyCodeLine{5908 }
\DoxyCodeLine{5909     \textcolor{keyword}{inline} std::size\_t listTestsNamesOnly( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{5910         TestSpec testSpec = config.testSpec();}
\DoxyCodeLine{5911         \textcolor{keywordflow}{if}( !config.testSpec().hasFilters() )}
\DoxyCodeLine{5912             testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( \textcolor{stringliteral}{"{}*"{}} ).testSpec();}
\DoxyCodeLine{5913         std::size\_t matchedTests = 0;}
\DoxyCodeLine{5914         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{5915         \textcolor{keywordflow}{for}( std::vector<TestCase>::const\_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();}
\DoxyCodeLine{5916                 it != itEnd;}
\DoxyCodeLine{5917                 ++it ) \{}
\DoxyCodeLine{5918             matchedTests++;}
\DoxyCodeLine{5919             TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo = it-\/>getTestCaseInfo();}
\DoxyCodeLine{5920             \textcolor{keywordflow}{if}( startsWith( testCaseInfo.name, \textcolor{charliteral}{'\#'} ) )}
\DoxyCodeLine{5921                Catch::cout() << \textcolor{charliteral}{'"{}'} << testCaseInfo.name << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{5922             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5923                Catch::cout() << testCaseInfo.name;}
\DoxyCodeLine{5924             \textcolor{keywordflow}{if} ( config.listExtraInfo() )}
\DoxyCodeLine{5925                 Catch::cout() << \textcolor{stringliteral}{"{}\(\backslash\)t@"{}} << testCaseInfo.lineInfo;}
\DoxyCodeLine{5926             Catch::cout() << std::endl;}
\DoxyCodeLine{5927         \}}
\DoxyCodeLine{5928         \textcolor{keywordflow}{return} matchedTests;}
\DoxyCodeLine{5929     \}}
\DoxyCodeLine{5930 }
\DoxyCodeLine{5931     \textcolor{keyword}{struct }TagInfo \{}
\DoxyCodeLine{5932         TagInfo() : count ( 0 ) \{\}}
\DoxyCodeLine{5933         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& spelling ) \{}
\DoxyCodeLine{5934             ++count;}
\DoxyCodeLine{5935             spellings.insert( spelling );}
\DoxyCodeLine{5936         \}}
\DoxyCodeLine{5937         std::string all()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5938             std::string out;}
\DoxyCodeLine{5939             \textcolor{keywordflow}{for}( std::set<std::string>::const\_iterator it = spellings.begin(), itEnd = spellings.end();}
\DoxyCodeLine{5940                         it != itEnd;}
\DoxyCodeLine{5941                         ++it )}
\DoxyCodeLine{5942                 out += "{}["{} + *it + "{}]"{};}
\DoxyCodeLine{5943             \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{5944         \}}
\DoxyCodeLine{5945         std::set<std::string> spellings;}
\DoxyCodeLine{5946         std::size\_t count;}
\DoxyCodeLine{5947     \};}
\DoxyCodeLine{5948 }
\DoxyCodeLine{5949     \textcolor{keyword}{inline} std::size\_t listTags( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{5950         TestSpec testSpec = config.testSpec();}
\DoxyCodeLine{5951         \textcolor{keywordflow}{if}( config.testSpec().hasFilters() )}
\DoxyCodeLine{5952             Catch::cout() << \textcolor{stringliteral}{"{}Tags for matching test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{5953         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5954             Catch::cout() << \textcolor{stringliteral}{"{}All available tags:\(\backslash\)n"{}};}
\DoxyCodeLine{5955             testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( \textcolor{stringliteral}{"{}*"{}} ).testSpec();}
\DoxyCodeLine{5956         \}}
\DoxyCodeLine{5957 }
\DoxyCodeLine{5958         std::map<std::string, TagInfo> tagCounts;}
\DoxyCodeLine{5959 }
\DoxyCodeLine{5960         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{5961         \textcolor{keywordflow}{for}( std::vector<TestCase>::const\_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();}
\DoxyCodeLine{5962                 it != itEnd;}
\DoxyCodeLine{5963                 ++it ) \{}
\DoxyCodeLine{5964             \textcolor{keywordflow}{for}( std::set<std::string>::const\_iterator  tagIt = it-\/>getTestCaseInfo().tags.begin(),}
\DoxyCodeLine{5965                                                         tagItEnd = it-\/>getTestCaseInfo().tags.end();}
\DoxyCodeLine{5966                     tagIt != tagItEnd;}
\DoxyCodeLine{5967                     ++tagIt ) \{}
\DoxyCodeLine{5968                 std::string tagName = *tagIt;}
\DoxyCodeLine{5969                 std::string lcaseTagName = toLower( tagName );}
\DoxyCodeLine{5970                 std::map<std::string, TagInfo>::iterator countIt = tagCounts.find( lcaseTagName );}
\DoxyCodeLine{5971                 \textcolor{keywordflow}{if}( countIt == tagCounts.end() )}
\DoxyCodeLine{5972                     countIt = tagCounts.insert( std::make\_pair( lcaseTagName, TagInfo() ) ).first;}
\DoxyCodeLine{5973                 countIt-\/>second.add( tagName );}
\DoxyCodeLine{5974             \}}
\DoxyCodeLine{5975         \}}
\DoxyCodeLine{5976 }
\DoxyCodeLine{5977         \textcolor{keywordflow}{for}( std::map<std::string, TagInfo>::const\_iterator countIt = tagCounts.begin(),}
\DoxyCodeLine{5978                                                             countItEnd = tagCounts.end();}
\DoxyCodeLine{5979                 countIt != countItEnd;}
\DoxyCodeLine{5980                 ++countIt ) \{}
\DoxyCodeLine{5981             std::ostringstream oss;}
\DoxyCodeLine{5982             oss << \textcolor{stringliteral}{"{}  "{}} << std::setw(2) << countIt-\/>second.count << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{5983             Text wrapper( countIt-\/>second.all(), TextAttributes()}
\DoxyCodeLine{5984                                                     .setInitialIndent( 0 )}
\DoxyCodeLine{5985                                                     .setIndent( oss.str().size() )}
\DoxyCodeLine{5986                                                     .setWidth( CATCH\_CONFIG\_CONSOLE\_WIDTH-\/10 ) );}
\DoxyCodeLine{5987             Catch::cout() << oss.str() << wrapper << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{5988         \}}
\DoxyCodeLine{5989         Catch::cout() << pluralise( tagCounts.size(), \textcolor{stringliteral}{"{}tag"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{5990         \textcolor{keywordflow}{return} tagCounts.size();}
\DoxyCodeLine{5991     \}}
\DoxyCodeLine{5992 }
\DoxyCodeLine{5993     \textcolor{keyword}{inline} std::size\_t listReporters( Config \textcolor{keyword}{const}\& \textcolor{comment}{/*config*/} ) \{}
\DoxyCodeLine{5994         Catch::cout() << \textcolor{stringliteral}{"{}Available reporters:\(\backslash\)n"{}};}
\DoxyCodeLine{5995         IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{5996         IReporterRegistry::FactoryMap::const\_iterator itBegin = factories.begin(), itEnd = factories.end(), it;}
\DoxyCodeLine{5997         std::size\_t maxNameLen = 0;}
\DoxyCodeLine{5998         \textcolor{keywordflow}{for}(it = itBegin; it != itEnd; ++it )}
\DoxyCodeLine{5999             maxNameLen = (std::max)( maxNameLen, it-\/>first.size() );}
\DoxyCodeLine{6000 }
\DoxyCodeLine{6001         \textcolor{keywordflow}{for}(it = itBegin; it != itEnd; ++it ) \{}
\DoxyCodeLine{6002             Text wrapper( it-\/>second-\/>getDescription(), TextAttributes()}
\DoxyCodeLine{6003                                                         .setInitialIndent( 0 )}
\DoxyCodeLine{6004                                                         .setIndent( 7+maxNameLen )}
\DoxyCodeLine{6005                                                         .setWidth( CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ maxNameLen-\/8 ) );}
\DoxyCodeLine{6006             Catch::cout() << \textcolor{stringliteral}{"{}  "{}}}
\DoxyCodeLine{6007                     << it-\/>first}
\DoxyCodeLine{6008                     << \textcolor{charliteral}{':'}}
\DoxyCodeLine{6009                     << std::string( maxNameLen -\/ it-\/>first.size() + 2, \textcolor{charliteral}{' '} )}
\DoxyCodeLine{6010                     << wrapper << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{6011         \}}
\DoxyCodeLine{6012         Catch::cout() << std::endl;}
\DoxyCodeLine{6013         \textcolor{keywordflow}{return} factories.size();}
\DoxyCodeLine{6014     \}}
\DoxyCodeLine{6015 }
\DoxyCodeLine{6016     \textcolor{keyword}{inline} Option<std::size\_t> list( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{6017         Option<std::size\_t> listedCount;}
\DoxyCodeLine{6018         \textcolor{keywordflow}{if}( config.listTests() || ( config.listExtraInfo() \&\& !config.listTestNamesOnly() ) )}
\DoxyCodeLine{6019             listedCount = listedCount.valueOr(0) + listTests( config );}
\DoxyCodeLine{6020         \textcolor{keywordflow}{if}( config.listTestNamesOnly() )}
\DoxyCodeLine{6021             listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );}
\DoxyCodeLine{6022         \textcolor{keywordflow}{if}( config.listTags() )}
\DoxyCodeLine{6023             listedCount = listedCount.valueOr(0) + listTags( config );}
\DoxyCodeLine{6024         \textcolor{keywordflow}{if}( config.listReporters() )}
\DoxyCodeLine{6025             listedCount = listedCount.valueOr(0) + listReporters( config );}
\DoxyCodeLine{6026         \textcolor{keywordflow}{return} listedCount;}
\DoxyCodeLine{6027     \}}
\DoxyCodeLine{6028 }
\DoxyCodeLine{6029 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6030 }
\DoxyCodeLine{6031 \textcolor{comment}{// \#included from: internal/catch\_run\_context.hpp}}
\DoxyCodeLine{6032 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_RUNNER\_IMPL\_HPP\_INCLUDED}}
\DoxyCodeLine{6033 }
\DoxyCodeLine{6034 \textcolor{comment}{// \#included from: catch\_test\_case\_tracker.hpp}}
\DoxyCodeLine{6035 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TEST\_CASE\_TRACKER\_HPP\_INCLUDED}}
\DoxyCodeLine{6036 }
\DoxyCodeLine{6037 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{6038 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{6039 \textcolor{preprocessor}{\#include <assert.h>}}
\DoxyCodeLine{6040 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{6041 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{6042 }
\DoxyCodeLine{6043 CATCH\_INTERNAL\_SUPPRESS\_ETD\_WARNINGS}
\DoxyCodeLine{6044 }
\DoxyCodeLine{6045 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6046 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{6047 }
\DoxyCodeLine{6048     \textcolor{keyword}{struct }NameAndLocation \{}
\DoxyCodeLine{6049         std::string name;}
\DoxyCodeLine{6050         SourceLineInfo location;}
\DoxyCodeLine{6051 }
\DoxyCodeLine{6052         NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location )}
\DoxyCodeLine{6053         :   name( \_name ),}
\DoxyCodeLine{6054             location( \_location )}
\DoxyCodeLine{6055         \{\}}
\DoxyCodeLine{6056     \};}
\DoxyCodeLine{6057 }
\DoxyCodeLine{6058     \textcolor{keyword}{struct }ITracker : SharedImpl<> \{}
\DoxyCodeLine{6059         \textcolor{keyword}{virtual} \string~ITracker();}
\DoxyCodeLine{6060 }
\DoxyCodeLine{6061         \textcolor{comment}{// static queries}}
\DoxyCodeLine{6062         \textcolor{keyword}{virtual} NameAndLocation \textcolor{keyword}{const}\& nameAndLocation() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6063 }
\DoxyCodeLine{6064         \textcolor{comment}{// dynamic queries}}
\DoxyCodeLine{6065         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Successfully completed or failed}}
\DoxyCodeLine{6066         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6067         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Started but not complete}}
\DoxyCodeLine{6068         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6069 }
\DoxyCodeLine{6070         \textcolor{keyword}{virtual} ITracker\& parent() = 0;}
\DoxyCodeLine{6071 }
\DoxyCodeLine{6072         \textcolor{comment}{// actions}}
\DoxyCodeLine{6073         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} close() = 0; \textcolor{comment}{// Successfully complete}}
\DoxyCodeLine{6074         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fail() = 0;}
\DoxyCodeLine{6075         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} markAsNeedingAnotherRun() = 0;}
\DoxyCodeLine{6076 }
\DoxyCodeLine{6077         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} addChild( Ptr<ITracker> \textcolor{keyword}{const}\& child ) = 0;}
\DoxyCodeLine{6078         \textcolor{keyword}{virtual} ITracker* findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) = 0;}
\DoxyCodeLine{6079         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} openChild() = 0;}
\DoxyCodeLine{6080 }
\DoxyCodeLine{6081         \textcolor{comment}{// Debug/ checking}}
\DoxyCodeLine{6082         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6083         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isIndexTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6084     \};}
\DoxyCodeLine{6085 }
\DoxyCodeLine{6086     \textcolor{keyword}{class  }TrackerContext \{}
\DoxyCodeLine{6087 }
\DoxyCodeLine{6088         \textcolor{keyword}{enum} RunState \{}
\DoxyCodeLine{6089             NotStarted,}
\DoxyCodeLine{6090             Executing,}
\DoxyCodeLine{6091             CompletedCycle}
\DoxyCodeLine{6092         \};}
\DoxyCodeLine{6093 }
\DoxyCodeLine{6094         Ptr<ITracker> m\_rootTracker;}
\DoxyCodeLine{6095         ITracker* m\_currentTracker;}
\DoxyCodeLine{6096         RunState m\_runState;}
\DoxyCodeLine{6097 }
\DoxyCodeLine{6098     \textcolor{keyword}{public}:}
\DoxyCodeLine{6099 }
\DoxyCodeLine{6100         \textcolor{keyword}{static} TrackerContext\& instance() \{}
\DoxyCodeLine{6101             \textcolor{keyword}{static} TrackerContext s\_instance;}
\DoxyCodeLine{6102             \textcolor{keywordflow}{return} s\_instance;}
\DoxyCodeLine{6103         \}}
\DoxyCodeLine{6104 }
\DoxyCodeLine{6105         TrackerContext()}
\DoxyCodeLine{6106         :   m\_currentTracker( CATCH\_NULL ),}
\DoxyCodeLine{6107             m\_runState( NotStarted )}
\DoxyCodeLine{6108         \{\}}
\DoxyCodeLine{6109 }
\DoxyCodeLine{6110         ITracker\& startRun();}
\DoxyCodeLine{6111 }
\DoxyCodeLine{6112         \textcolor{keywordtype}{void} endRun() \{}
\DoxyCodeLine{6113             m\_rootTracker.reset();}
\DoxyCodeLine{6114             m\_currentTracker = CATCH\_NULL;}
\DoxyCodeLine{6115             m\_runState = NotStarted;}
\DoxyCodeLine{6116         \}}
\DoxyCodeLine{6117 }
\DoxyCodeLine{6118         \textcolor{keywordtype}{void} startCycle() \{}
\DoxyCodeLine{6119             m\_currentTracker = m\_rootTracker.get();}
\DoxyCodeLine{6120             m\_runState = Executing;}
\DoxyCodeLine{6121         \}}
\DoxyCodeLine{6122         \textcolor{keywordtype}{void} completeCycle() \{}
\DoxyCodeLine{6123             m\_runState = CompletedCycle;}
\DoxyCodeLine{6124         \}}
\DoxyCodeLine{6125 }
\DoxyCodeLine{6126         \textcolor{keywordtype}{bool} completedCycle()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6127             \textcolor{keywordflow}{return} m\_runState == CompletedCycle;}
\DoxyCodeLine{6128         \}}
\DoxyCodeLine{6129         ITracker\& currentTracker() \{}
\DoxyCodeLine{6130             \textcolor{keywordflow}{return} *m\_currentTracker;}
\DoxyCodeLine{6131         \}}
\DoxyCodeLine{6132         \textcolor{keywordtype}{void} setCurrentTracker( ITracker* tracker ) \{}
\DoxyCodeLine{6133             m\_currentTracker = tracker;}
\DoxyCodeLine{6134         \}}
\DoxyCodeLine{6135     \};}
\DoxyCodeLine{6136 }
\DoxyCodeLine{6137     \textcolor{keyword}{class }TrackerBase : \textcolor{keyword}{public} ITracker \{}
\DoxyCodeLine{6138     \textcolor{keyword}{protected}:}
\DoxyCodeLine{6139         \textcolor{keyword}{enum} CycleState \{}
\DoxyCodeLine{6140             NotStarted,}
\DoxyCodeLine{6141             Executing,}
\DoxyCodeLine{6142             ExecutingChildren,}
\DoxyCodeLine{6143             NeedsAnotherRun,}
\DoxyCodeLine{6144             CompletedSuccessfully,}
\DoxyCodeLine{6145             Failed}
\DoxyCodeLine{6146         \};}
\DoxyCodeLine{6147         \textcolor{keyword}{class }TrackerHasName \{}
\DoxyCodeLine{6148             NameAndLocation m\_nameAndLocation;}
\DoxyCodeLine{6149         \textcolor{keyword}{public}:}
\DoxyCodeLine{6150             TrackerHasName( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) : m\_nameAndLocation( nameAndLocation ) \{\}}
\DoxyCodeLine{6151             \textcolor{keywordtype}{bool} operator ()( Ptr<ITracker> \textcolor{keyword}{const}\& tracker ) \{}
\DoxyCodeLine{6152                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{6153                     tracker-\/>nameAndLocation().name == m\_nameAndLocation.name \&\&}
\DoxyCodeLine{6154                     tracker-\/>nameAndLocation().location == m\_nameAndLocation.location;}
\DoxyCodeLine{6155             \}}
\DoxyCodeLine{6156         \};}
\DoxyCodeLine{6157         \textcolor{keyword}{typedef} std::vector<Ptr<ITracker> > Children;}
\DoxyCodeLine{6158         NameAndLocation m\_nameAndLocation;}
\DoxyCodeLine{6159         TrackerContext\& m\_ctx;}
\DoxyCodeLine{6160         ITracker* m\_parent;}
\DoxyCodeLine{6161         Children m\_children;}
\DoxyCodeLine{6162         CycleState m\_runState;}
\DoxyCodeLine{6163     \textcolor{keyword}{public}:}
\DoxyCodeLine{6164         TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{6165         :   m\_nameAndLocation( nameAndLocation ),}
\DoxyCodeLine{6166             m\_ctx( ctx ),}
\DoxyCodeLine{6167             m\_parent( parent ),}
\DoxyCodeLine{6168             m\_runState( NotStarted )}
\DoxyCodeLine{6169         \{\}}
\DoxyCodeLine{6170         \textcolor{keyword}{virtual} \string~TrackerBase();}
\DoxyCodeLine{6171 }
\DoxyCodeLine{6172         \textcolor{keyword}{virtual} NameAndLocation \textcolor{keyword}{const}\& nameAndLocation() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{6173             \textcolor{keywordflow}{return} m\_nameAndLocation;}
\DoxyCodeLine{6174         \}}
\DoxyCodeLine{6175         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isComplete() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{6176             \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully || m\_runState == Failed;}
\DoxyCodeLine{6177         \}}
\DoxyCodeLine{6178         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSuccessfullyCompleted() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{6179             \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully;}
\DoxyCodeLine{6180         \}}
\DoxyCodeLine{6181         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isOpen() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{6182             \textcolor{keywordflow}{return} m\_runState != NotStarted \&\& !isComplete();}
\DoxyCodeLine{6183         \}}
\DoxyCodeLine{6184         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasChildren() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{6185             \textcolor{keywordflow}{return} !m\_children.empty();}
\DoxyCodeLine{6186         \}}
\DoxyCodeLine{6187 }
\DoxyCodeLine{6188         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} addChild( Ptr<ITracker> \textcolor{keyword}{const}\& child ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{6189             m\_children.push\_back( child );}
\DoxyCodeLine{6190         \}}
\DoxyCodeLine{6191 }
\DoxyCodeLine{6192         \textcolor{keyword}{virtual} ITracker* findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{6193             Children::const\_iterator it = std::find\_if( m\_children.begin(), m\_children.end(), TrackerHasName( nameAndLocation ) );}
\DoxyCodeLine{6194             \textcolor{keywordflow}{return}( it != m\_children.end() )}
\DoxyCodeLine{6195                 ? it-\/>get()}
\DoxyCodeLine{6196                 : CATCH\_NULL;}
\DoxyCodeLine{6197         \}}
\DoxyCodeLine{6198         \textcolor{keyword}{virtual} ITracker\& parent() CATCH\_OVERRIDE \{}
\DoxyCodeLine{6199             assert( m\_parent ); \textcolor{comment}{// Should always be non-\/null except for root}}
\DoxyCodeLine{6200             \textcolor{keywordflow}{return} *m\_parent;}
\DoxyCodeLine{6201         \}}
\DoxyCodeLine{6202 }
\DoxyCodeLine{6203         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} openChild() CATCH\_OVERRIDE \{}
\DoxyCodeLine{6204             \textcolor{keywordflow}{if}( m\_runState != ExecutingChildren ) \{}
\DoxyCodeLine{6205                 m\_runState = ExecutingChildren;}
\DoxyCodeLine{6206                 \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{6207                     m\_parent-\/>openChild();}
\DoxyCodeLine{6208             \}}
\DoxyCodeLine{6209         \}}
\DoxyCodeLine{6210 }
\DoxyCodeLine{6211         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSectionTracker() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{6212         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isIndexTracker() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{6213 }
\DoxyCodeLine{6214         \textcolor{keywordtype}{void} open() \{}
\DoxyCodeLine{6215             m\_runState = Executing;}
\DoxyCodeLine{6216             moveToThis();}
\DoxyCodeLine{6217             \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{6218                 m\_parent-\/>openChild();}
\DoxyCodeLine{6219         \}}
\DoxyCodeLine{6220 }
\DoxyCodeLine{6221         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} close() CATCH\_OVERRIDE \{}
\DoxyCodeLine{6222 }
\DoxyCodeLine{6223             \textcolor{comment}{// Close any still open children (e.g. generators)}}
\DoxyCodeLine{6224             \textcolor{keywordflow}{while}( \&m\_ctx.currentTracker() != \textcolor{keyword}{this} )}
\DoxyCodeLine{6225                 m\_ctx.currentTracker().close();}
\DoxyCodeLine{6226 }
\DoxyCodeLine{6227             \textcolor{keywordflow}{switch}( m\_runState ) \{}
\DoxyCodeLine{6228                 \textcolor{keywordflow}{case} NotStarted:}
\DoxyCodeLine{6229                 \textcolor{keywordflow}{case} CompletedSuccessfully:}
\DoxyCodeLine{6230                 \textcolor{keywordflow}{case} Failed:}
\DoxyCodeLine{6231                     \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}Illogical state"{}} );}
\DoxyCodeLine{6232 }
\DoxyCodeLine{6233                 \textcolor{keywordflow}{case} NeedsAnotherRun:}
\DoxyCodeLine{6234                     \textcolor{keywordflow}{break};;}
\DoxyCodeLine{6235 }
\DoxyCodeLine{6236                 \textcolor{keywordflow}{case} Executing:}
\DoxyCodeLine{6237                     m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{6238                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{6239                 \textcolor{keywordflow}{case} ExecutingChildren:}
\DoxyCodeLine{6240                     \textcolor{keywordflow}{if}( m\_children.empty() || m\_children.back()-\/>isComplete() )}
\DoxyCodeLine{6241                         m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{6242                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{6243 }
\DoxyCodeLine{6244                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{6245                     \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}Unexpected state"{}} );}
\DoxyCodeLine{6246             \}}
\DoxyCodeLine{6247             moveToParent();}
\DoxyCodeLine{6248             m\_ctx.completeCycle();}
\DoxyCodeLine{6249         \}}
\DoxyCodeLine{6250         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fail() CATCH\_OVERRIDE \{}
\DoxyCodeLine{6251             m\_runState = Failed;}
\DoxyCodeLine{6252             \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{6253                 m\_parent-\/>markAsNeedingAnotherRun();}
\DoxyCodeLine{6254             moveToParent();}
\DoxyCodeLine{6255             m\_ctx.completeCycle();}
\DoxyCodeLine{6256         \}}
\DoxyCodeLine{6257         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} markAsNeedingAnotherRun() CATCH\_OVERRIDE \{}
\DoxyCodeLine{6258             m\_runState = NeedsAnotherRun;}
\DoxyCodeLine{6259         \}}
\DoxyCodeLine{6260     \textcolor{keyword}{private}:}
\DoxyCodeLine{6261         \textcolor{keywordtype}{void} moveToParent() \{}
\DoxyCodeLine{6262             assert( m\_parent );}
\DoxyCodeLine{6263             m\_ctx.setCurrentTracker( m\_parent );}
\DoxyCodeLine{6264         \}}
\DoxyCodeLine{6265         \textcolor{keywordtype}{void} moveToThis() \{}
\DoxyCodeLine{6266             m\_ctx.setCurrentTracker( \textcolor{keyword}{this} );}
\DoxyCodeLine{6267         \}}
\DoxyCodeLine{6268     \};}
\DoxyCodeLine{6269 }
\DoxyCodeLine{6270     \textcolor{keyword}{class }SectionTracker : \textcolor{keyword}{public} TrackerBase \{}
\DoxyCodeLine{6271         std::vector<std::string> m\_filters;}
\DoxyCodeLine{6272     \textcolor{keyword}{public}:}
\DoxyCodeLine{6273         SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{6274         :   TrackerBase( nameAndLocation, ctx, parent )}
\DoxyCodeLine{6275         \{}
\DoxyCodeLine{6276             \textcolor{keywordflow}{if}( parent ) \{}
\DoxyCodeLine{6277                 \textcolor{keywordflow}{while}( !parent-\/>isSectionTracker() )}
\DoxyCodeLine{6278                     parent = \&parent-\/>parent();}
\DoxyCodeLine{6279 }
\DoxyCodeLine{6280                 SectionTracker\& parentSection = \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *parent );}
\DoxyCodeLine{6281                 addNextFilters( parentSection.m\_filters );}
\DoxyCodeLine{6282             \}}
\DoxyCodeLine{6283         \}}
\DoxyCodeLine{6284         \textcolor{keyword}{virtual} \string~SectionTracker();}
\DoxyCodeLine{6285 }
\DoxyCodeLine{6286         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSectionTracker() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{6287 }
\DoxyCodeLine{6288         \textcolor{keyword}{static} SectionTracker\& acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{6289             SectionTracker* section = CATCH\_NULL;}
\DoxyCodeLine{6290 }
\DoxyCodeLine{6291             ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{6292             \textcolor{keywordflow}{if}( ITracker* childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{6293                 assert( childTracker );}
\DoxyCodeLine{6294                 assert( childTracker-\/>isSectionTracker() );}
\DoxyCodeLine{6295                 section = \textcolor{keyword}{static\_cast<}SectionTracker*\textcolor{keyword}{>}( childTracker );}
\DoxyCodeLine{6296             \}}
\DoxyCodeLine{6297             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{6298                 section = \textcolor{keyword}{new} SectionTracker( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{6299                 currentTracker.addChild( section );}
\DoxyCodeLine{6300             \}}
\DoxyCodeLine{6301             \textcolor{keywordflow}{if}( !ctx.completedCycle() )}
\DoxyCodeLine{6302                 section-\/>tryOpen();}
\DoxyCodeLine{6303             \textcolor{keywordflow}{return} *section;}
\DoxyCodeLine{6304         \}}
\DoxyCodeLine{6305 }
\DoxyCodeLine{6306         \textcolor{keywordtype}{void} tryOpen() \{}
\DoxyCodeLine{6307             \textcolor{keywordflow}{if}( !isComplete() \&\& (m\_filters.empty() || m\_filters[0].empty() ||  m\_filters[0] == m\_nameAndLocation.name ) )}
\DoxyCodeLine{6308                 open();}
\DoxyCodeLine{6309         \}}
\DoxyCodeLine{6310 }
\DoxyCodeLine{6311         \textcolor{keywordtype}{void} addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{6312             \textcolor{keywordflow}{if}( !filters.empty() ) \{}
\DoxyCodeLine{6313                 m\_filters.push\_back(\textcolor{stringliteral}{"{}"{}}); \textcolor{comment}{// Root -\/ should never be consulted}}
\DoxyCodeLine{6314                 m\_filters.push\_back(\textcolor{stringliteral}{"{}"{}}); \textcolor{comment}{// Test Case -\/ not a section filter}}
\DoxyCodeLine{6315                 m\_filters.insert( m\_filters.end(), filters.begin(), filters.end() );}
\DoxyCodeLine{6316             \}}
\DoxyCodeLine{6317         \}}
\DoxyCodeLine{6318         \textcolor{keywordtype}{void} addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{6319             \textcolor{keywordflow}{if}( filters.size() > 1 )}
\DoxyCodeLine{6320                 m\_filters.insert( m\_filters.end(), ++filters.begin(), filters.end() );}
\DoxyCodeLine{6321         \}}
\DoxyCodeLine{6322     \};}
\DoxyCodeLine{6323 }
\DoxyCodeLine{6324     \textcolor{keyword}{class }IndexTracker : \textcolor{keyword}{public} TrackerBase \{}
\DoxyCodeLine{6325         \textcolor{keywordtype}{int} m\_size;}
\DoxyCodeLine{6326         \textcolor{keywordtype}{int} m\_index;}
\DoxyCodeLine{6327     \textcolor{keyword}{public}:}
\DoxyCodeLine{6328         IndexTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent, \textcolor{keywordtype}{int} size )}
\DoxyCodeLine{6329         :   TrackerBase( nameAndLocation, ctx, parent ),}
\DoxyCodeLine{6330             m\_size( size ),}
\DoxyCodeLine{6331             m\_index( -\/1 )}
\DoxyCodeLine{6332         \{\}}
\DoxyCodeLine{6333         \textcolor{keyword}{virtual} \string~IndexTracker();}
\DoxyCodeLine{6334 }
\DoxyCodeLine{6335         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isIndexTracker() const CATCH\_OVERRIDE \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{6336 }
\DoxyCodeLine{6337         \textcolor{keyword}{static} IndexTracker\& acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, \textcolor{keywordtype}{int} size ) \{}
\DoxyCodeLine{6338             IndexTracker* tracker = CATCH\_NULL;}
\DoxyCodeLine{6339 }
\DoxyCodeLine{6340             ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{6341             \textcolor{keywordflow}{if}( ITracker* childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{6342                 assert( childTracker );}
\DoxyCodeLine{6343                 assert( childTracker-\/>isIndexTracker() );}
\DoxyCodeLine{6344                 tracker = \textcolor{keyword}{static\_cast<}IndexTracker*\textcolor{keyword}{>}( childTracker );}
\DoxyCodeLine{6345             \}}
\DoxyCodeLine{6346             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{6347                 tracker = \textcolor{keyword}{new} IndexTracker( nameAndLocation, ctx, \&currentTracker, size );}
\DoxyCodeLine{6348                 currentTracker.addChild( tracker );}
\DoxyCodeLine{6349             \}}
\DoxyCodeLine{6350 }
\DoxyCodeLine{6351             \textcolor{keywordflow}{if}( !ctx.completedCycle() \&\& !tracker-\/>isComplete() ) \{}
\DoxyCodeLine{6352                 \textcolor{keywordflow}{if}( tracker-\/>m\_runState != ExecutingChildren \&\& tracker-\/>m\_runState != NeedsAnotherRun )}
\DoxyCodeLine{6353                     tracker-\/>moveNext();}
\DoxyCodeLine{6354                 tracker-\/>open();}
\DoxyCodeLine{6355             \}}
\DoxyCodeLine{6356 }
\DoxyCodeLine{6357             \textcolor{keywordflow}{return} *tracker;}
\DoxyCodeLine{6358         \}}
\DoxyCodeLine{6359 }
\DoxyCodeLine{6360         \textcolor{keywordtype}{int} index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_index; \}}
\DoxyCodeLine{6361 }
\DoxyCodeLine{6362         \textcolor{keywordtype}{void} moveNext() \{}
\DoxyCodeLine{6363             m\_index++;}
\DoxyCodeLine{6364             m\_children.clear();}
\DoxyCodeLine{6365         \}}
\DoxyCodeLine{6366 }
\DoxyCodeLine{6367         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} close() CATCH\_OVERRIDE \{}
\DoxyCodeLine{6368             TrackerBase::close();}
\DoxyCodeLine{6369             \textcolor{keywordflow}{if}( m\_runState == CompletedSuccessfully \&\& m\_index < m\_size-\/1 )}
\DoxyCodeLine{6370                 m\_runState = Executing;}
\DoxyCodeLine{6371         \}}
\DoxyCodeLine{6372     \};}
\DoxyCodeLine{6373 }
\DoxyCodeLine{6374     \textcolor{keyword}{inline} ITracker\& TrackerContext::startRun() \{}
\DoxyCodeLine{6375         m\_rootTracker = \textcolor{keyword}{new} SectionTracker( NameAndLocation( \textcolor{stringliteral}{"{}\{root\}"{}}, CATCH\_INTERNAL\_LINEINFO ), *\textcolor{keyword}{this}, CATCH\_NULL );}
\DoxyCodeLine{6376         m\_currentTracker = CATCH\_NULL;}
\DoxyCodeLine{6377         m\_runState = Executing;}
\DoxyCodeLine{6378         \textcolor{keywordflow}{return} *m\_rootTracker;}
\DoxyCodeLine{6379     \}}
\DoxyCodeLine{6380 }
\DoxyCodeLine{6381 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{6382 }
\DoxyCodeLine{6383 \textcolor{keyword}{using }TestCaseTracking::ITracker;}
\DoxyCodeLine{6384 \textcolor{keyword}{using }TestCaseTracking::TrackerContext;}
\DoxyCodeLine{6385 \textcolor{keyword}{using }TestCaseTracking::SectionTracker;}
\DoxyCodeLine{6386 \textcolor{keyword}{using }TestCaseTracking::IndexTracker;}
\DoxyCodeLine{6387 }
\DoxyCodeLine{6388 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6389 }
\DoxyCodeLine{6390 CATCH\_INTERNAL\_UNSUPPRESS\_ETD\_WARNINGS}
\DoxyCodeLine{6391 }
\DoxyCodeLine{6392 \textcolor{comment}{// \#included from: catch\_fatal\_condition.hpp}}
\DoxyCodeLine{6393 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_FATAL\_CONDITION\_H\_INCLUDED}}
\DoxyCodeLine{6394 }
\DoxyCodeLine{6395 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6396 }
\DoxyCodeLine{6397     \textcolor{comment}{// Report the error condition}}
\DoxyCodeLine{6398     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} reportFatal( std::string \textcolor{keyword}{const}\& message ) \{}
\DoxyCodeLine{6399         IContext\& context = Catch::getCurrentContext();}
\DoxyCodeLine{6400         IResultCapture* resultCapture = context.getResultCapture();}
\DoxyCodeLine{6401         resultCapture-\/>handleFatalErrorCondition( message );}
\DoxyCodeLine{6402     \}}
\DoxyCodeLine{6403 }
\DoxyCodeLine{6404 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6405 }
\DoxyCodeLine{6406 \textcolor{preprocessor}{\#if defined ( CATCH\_PLATFORM\_WINDOWS ) }}
\DoxyCodeLine{6407 \textcolor{comment}{// \#included from: catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{6408 }
\DoxyCodeLine{6409 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_WINDOWS\_H\_PROXY\_H\_INCLUDED}}
\DoxyCodeLine{6410 }
\DoxyCodeLine{6411 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINES\_NOMINMAX}}
\DoxyCodeLine{6412 \textcolor{preprocessor}{\#  define NOMINMAX}}
\DoxyCodeLine{6413 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6414 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINES\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{6415 \textcolor{preprocessor}{\#  define WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{6416 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6417 }
\DoxyCodeLine{6418 \textcolor{preprocessor}{\#ifdef \_\_AFXDLL}}
\DoxyCodeLine{6419 \textcolor{preprocessor}{\#include <AfxWin.h>}}
\DoxyCodeLine{6420 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{6421 \textcolor{preprocessor}{\#include <windows.h>}}
\DoxyCodeLine{6422 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6423 }
\DoxyCodeLine{6424 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINES\_NOMINMAX}}
\DoxyCodeLine{6425 \textcolor{preprocessor}{\#  undef NOMINMAX}}
\DoxyCodeLine{6426 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6427 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINES\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{6428 \textcolor{preprocessor}{\#  undef WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{6429 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6430 }
\DoxyCodeLine{6431 }
\DoxyCodeLine{6432 \textcolor{preprocessor}{\#  if !defined ( CATCH\_CONFIG\_WINDOWS\_SEH )}}
\DoxyCodeLine{6433 }
\DoxyCodeLine{6434 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6435     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{6436         \textcolor{keywordtype}{void} reset() \{\}}
\DoxyCodeLine{6437     \};}
\DoxyCodeLine{6438 \}}
\DoxyCodeLine{6439 }
\DoxyCodeLine{6440 \textcolor{preprocessor}{\#  else }\textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH is defined}}
\DoxyCodeLine{6441 }
\DoxyCodeLine{6442 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6443 }
\DoxyCodeLine{6444     \textcolor{keyword}{struct }SignalDefs \{ DWORD id; \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name; \};}
\DoxyCodeLine{6445     \textcolor{keyword}{extern} SignalDefs signalDefs[];}
\DoxyCodeLine{6446     \textcolor{comment}{// There is no 1-\/1 mapping between signals and windows exceptions.}}
\DoxyCodeLine{6447     \textcolor{comment}{// Windows can easily distinguish between SO and SigSegV,}}
\DoxyCodeLine{6448     \textcolor{comment}{// but SigInt, SigTerm, etc are handled differently.}}
\DoxyCodeLine{6449     SignalDefs signalDefs[] = \{}
\DoxyCodeLine{6450         \{ EXCEPTION\_ILLEGAL\_INSTRUCTION,  \textcolor{stringliteral}{"{}SIGILL -\/ Illegal instruction signal"{}} \},}
\DoxyCodeLine{6451         \{ EXCEPTION\_STACK\_OVERFLOW, \textcolor{stringliteral}{"{}SIGSEGV -\/ Stack overflow"{}} \},}
\DoxyCodeLine{6452         \{ EXCEPTION\_ACCESS\_VIOLATION, \textcolor{stringliteral}{"{}SIGSEGV -\/ Segmentation violation signal"{}} \},}
\DoxyCodeLine{6453         \{ EXCEPTION\_INT\_DIVIDE\_BY\_ZERO, \textcolor{stringliteral}{"{}Divide by zero error"{}} \},}
\DoxyCodeLine{6454     \};}
\DoxyCodeLine{6455 }
\DoxyCodeLine{6456     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{6457 }
\DoxyCodeLine{6458         \textcolor{keyword}{static} LONG CALLBACK handleVectoredException(PEXCEPTION\_POINTERS ExceptionInfo) \{}
\DoxyCodeLine{6459             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \textcolor{keyword}{sizeof}(signalDefs) / \textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{6460                 \textcolor{keywordflow}{if} (ExceptionInfo-\/>ExceptionRecord-\/>ExceptionCode == signalDefs[i].id) \{}
\DoxyCodeLine{6461                     reportFatal(signalDefs[i].name);}
\DoxyCodeLine{6462                 \}}
\DoxyCodeLine{6463             \}}
\DoxyCodeLine{6464             \textcolor{comment}{// If its not an exception we care about, pass it along.}}
\DoxyCodeLine{6465             \textcolor{comment}{// This stops us from eating debugger breaks etc.}}
\DoxyCodeLine{6466             \textcolor{keywordflow}{return} EXCEPTION\_CONTINUE\_SEARCH;}
\DoxyCodeLine{6467         \}}
\DoxyCodeLine{6468 }
\DoxyCodeLine{6469         FatalConditionHandler() \{}
\DoxyCodeLine{6470             isSet = \textcolor{keyword}{true};}
\DoxyCodeLine{6471             \textcolor{comment}{// 32k seems enough for Catch to handle stack overflow,}}
\DoxyCodeLine{6472             \textcolor{comment}{// but the value was found experimentally, so there is no strong guarantee}}
\DoxyCodeLine{6473             guaranteeSize = 32 * 1024;}
\DoxyCodeLine{6474             exceptionHandlerHandle = CATCH\_NULL;}
\DoxyCodeLine{6475             \textcolor{comment}{// Register as first handler in current chain}}
\DoxyCodeLine{6476             exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);}
\DoxyCodeLine{6477             \textcolor{comment}{// Pass in guarantee size to be filled}}
\DoxyCodeLine{6478             SetThreadStackGuarantee(\&guaranteeSize);}
\DoxyCodeLine{6479         \}}
\DoxyCodeLine{6480 }
\DoxyCodeLine{6481         \textcolor{keyword}{static} \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{6482             \textcolor{keywordflow}{if} (isSet) \{}
\DoxyCodeLine{6483                 \textcolor{comment}{// Unregister handler and restore the old guarantee}}
\DoxyCodeLine{6484                 RemoveVectoredExceptionHandler(exceptionHandlerHandle);}
\DoxyCodeLine{6485                 SetThreadStackGuarantee(\&guaranteeSize);}
\DoxyCodeLine{6486                 exceptionHandlerHandle = CATCH\_NULL;}
\DoxyCodeLine{6487                 isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{6488             \}}
\DoxyCodeLine{6489         \}}
\DoxyCodeLine{6490 }
\DoxyCodeLine{6491         \string~FatalConditionHandler() \{}
\DoxyCodeLine{6492             reset();}
\DoxyCodeLine{6493         \}}
\DoxyCodeLine{6494     \textcolor{keyword}{private}:}
\DoxyCodeLine{6495         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isSet;}
\DoxyCodeLine{6496         \textcolor{keyword}{static} ULONG guaranteeSize;}
\DoxyCodeLine{6497         \textcolor{keyword}{static} PVOID exceptionHandlerHandle;}
\DoxyCodeLine{6498     \};}
\DoxyCodeLine{6499 }
\DoxyCodeLine{6500     \textcolor{keywordtype}{bool} FatalConditionHandler::isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{6501     ULONG FatalConditionHandler::guaranteeSize = 0;}
\DoxyCodeLine{6502     PVOID FatalConditionHandler::exceptionHandlerHandle = CATCH\_NULL;}
\DoxyCodeLine{6503 }
\DoxyCodeLine{6504 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6505 }
\DoxyCodeLine{6506 \textcolor{preprocessor}{\#  endif }\textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{6507 }
\DoxyCodeLine{6508 \textcolor{preprocessor}{\#else }\textcolor{comment}{// Not Windows -\/ assumed to be POSIX compatible //////////////////////////}}
\DoxyCodeLine{6509 }
\DoxyCodeLine{6510 \textcolor{preprocessor}{\#  if !defined(CATCH\_CONFIG\_POSIX\_SIGNALS)}}
\DoxyCodeLine{6511 }
\DoxyCodeLine{6512 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6513     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{6514         \textcolor{keywordtype}{void} reset() \{\}}
\DoxyCodeLine{6515     \};}
\DoxyCodeLine{6516 \}}
\DoxyCodeLine{6517 }
\DoxyCodeLine{6518 \textcolor{preprocessor}{\#  else }\textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS is defined}}
\DoxyCodeLine{6519 }
\DoxyCodeLine{6520 \textcolor{preprocessor}{\#include <signal.h>}}
\DoxyCodeLine{6521 }
\DoxyCodeLine{6522 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6523 }
\DoxyCodeLine{6524     \textcolor{keyword}{struct }SignalDefs \{}
\DoxyCodeLine{6525         \textcolor{keywordtype}{int} id;}
\DoxyCodeLine{6526         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name;}
\DoxyCodeLine{6527     \};}
\DoxyCodeLine{6528     \textcolor{keyword}{extern} SignalDefs signalDefs[];}
\DoxyCodeLine{6529     SignalDefs signalDefs[] = \{}
\DoxyCodeLine{6530             \{ SIGINT,  \textcolor{stringliteral}{"{}SIGINT -\/ Terminal interrupt signal"{}} \},}
\DoxyCodeLine{6531             \{ SIGILL,  \textcolor{stringliteral}{"{}SIGILL -\/ Illegal instruction signal"{}} \},}
\DoxyCodeLine{6532             \{ SIGFPE,  \textcolor{stringliteral}{"{}SIGFPE -\/ Floating point error signal"{}} \},}
\DoxyCodeLine{6533             \{ SIGSEGV, \textcolor{stringliteral}{"{}SIGSEGV -\/ Segmentation violation signal"{}} \},}
\DoxyCodeLine{6534             \{ SIGTERM, \textcolor{stringliteral}{"{}SIGTERM -\/ Termination request signal"{}} \},}
\DoxyCodeLine{6535             \{ SIGABRT, \textcolor{stringliteral}{"{}SIGABRT -\/ Abort (abnormal termination) signal"{}} \}}
\DoxyCodeLine{6536     \};}
\DoxyCodeLine{6537 }
\DoxyCodeLine{6538     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{6539 }
\DoxyCodeLine{6540         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isSet;}
\DoxyCodeLine{6541         \textcolor{keyword}{static} \textcolor{keyword}{struct }sigaction oldSigActions [sizeof(signalDefs)/sizeof(SignalDefs)];}
\DoxyCodeLine{6542         \textcolor{keyword}{static} stack\_t oldSigStack;}
\DoxyCodeLine{6543         \textcolor{keyword}{static} \textcolor{keywordtype}{char} altStackMem[SIGSTKSZ];}
\DoxyCodeLine{6544 }
\DoxyCodeLine{6545         \textcolor{keyword}{static} \textcolor{keywordtype}{void} handleSignal( \textcolor{keywordtype}{int} sig ) \{}
\DoxyCodeLine{6546             std::string name = \textcolor{stringliteral}{"{}<unknown signal>"{}};}
\DoxyCodeLine{6547             \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs) / \textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{6548                 SignalDefs \&def = signalDefs[i];}
\DoxyCodeLine{6549                 \textcolor{keywordflow}{if} (sig == def.id) \{}
\DoxyCodeLine{6550                     name = def.name;}
\DoxyCodeLine{6551                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{6552                 \}}
\DoxyCodeLine{6553             \}}
\DoxyCodeLine{6554             reset();}
\DoxyCodeLine{6555             reportFatal(name);}
\DoxyCodeLine{6556             raise( sig );}
\DoxyCodeLine{6557         \}}
\DoxyCodeLine{6558 }
\DoxyCodeLine{6559         FatalConditionHandler() \{}
\DoxyCodeLine{6560             isSet = \textcolor{keyword}{true};}
\DoxyCodeLine{6561             stack\_t sigStack;}
\DoxyCodeLine{6562             sigStack.ss\_sp = altStackMem;}
\DoxyCodeLine{6563             sigStack.ss\_size = SIGSTKSZ;}
\DoxyCodeLine{6564             sigStack.ss\_flags = 0;}
\DoxyCodeLine{6565             sigaltstack(\&sigStack, \&oldSigStack);}
\DoxyCodeLine{6566             \textcolor{keyword}{struct }sigaction sa = \{ 0 \};}
\DoxyCodeLine{6567 }
\DoxyCodeLine{6568             sa.sa\_handler = handleSignal;}
\DoxyCodeLine{6569             sa.sa\_flags = SA\_ONSTACK;}
\DoxyCodeLine{6570             \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs)/\textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{6571                 sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&sa, \&oldSigActions[i]);}
\DoxyCodeLine{6572             \}}
\DoxyCodeLine{6573         \}}
\DoxyCodeLine{6574 }
\DoxyCodeLine{6575         \string~FatalConditionHandler() \{}
\DoxyCodeLine{6576             reset();}
\DoxyCodeLine{6577         \}}
\DoxyCodeLine{6578         \textcolor{keyword}{static} \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{6579             \textcolor{keywordflow}{if}( isSet ) \{}
\DoxyCodeLine{6580                 \textcolor{comment}{// Set signals back to previous values -\/-\/ hopefully nobody overwrote them in the meantime}}
\DoxyCodeLine{6581                 \textcolor{keywordflow}{for}( std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs)/\textcolor{keyword}{sizeof}(SignalDefs); ++i ) \{}
\DoxyCodeLine{6582                     sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&oldSigActions[i], CATCH\_NULL);}
\DoxyCodeLine{6583                 \}}
\DoxyCodeLine{6584                 \textcolor{comment}{// Return the old stack}}
\DoxyCodeLine{6585                 sigaltstack(\&oldSigStack, CATCH\_NULL);}
\DoxyCodeLine{6586                 isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{6587             \}}
\DoxyCodeLine{6588         \}}
\DoxyCodeLine{6589     \};}
\DoxyCodeLine{6590 }
\DoxyCodeLine{6591     \textcolor{keywordtype}{bool} FatalConditionHandler::isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{6592     \textcolor{keyword}{struct }sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = \{\};}
\DoxyCodeLine{6593     stack\_t FatalConditionHandler::oldSigStack = \{\};}
\DoxyCodeLine{6594     \textcolor{keywordtype}{char} FatalConditionHandler::altStackMem[SIGSTKSZ] = \{\};}
\DoxyCodeLine{6595 }
\DoxyCodeLine{6596 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6597 }
\DoxyCodeLine{6598 \textcolor{preprocessor}{\#  endif }\textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{6599 }
\DoxyCodeLine{6600 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// not Windows}}
\DoxyCodeLine{6601 }
\DoxyCodeLine{6602 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{6603 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{6604 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{6605 }
\DoxyCodeLine{6606 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6607 }
\DoxyCodeLine{6608     \textcolor{keyword}{class }StreamRedirect \{}
\DoxyCodeLine{6609 }
\DoxyCodeLine{6610     \textcolor{keyword}{public}:}
\DoxyCodeLine{6611         StreamRedirect( std::ostream\& stream, std::string\& targetString )}
\DoxyCodeLine{6612         :   m\_stream( stream ),}
\DoxyCodeLine{6613             m\_prevBuf( stream.rdbuf() ),}
\DoxyCodeLine{6614             m\_targetString( targetString )}
\DoxyCodeLine{6615         \{}
\DoxyCodeLine{6616             stream.rdbuf( m\_oss.rdbuf() );}
\DoxyCodeLine{6617         \}}
\DoxyCodeLine{6618 }
\DoxyCodeLine{6619         \string~StreamRedirect() \{}
\DoxyCodeLine{6620             m\_targetString += m\_oss.str();}
\DoxyCodeLine{6621             m\_stream.rdbuf( m\_prevBuf );}
\DoxyCodeLine{6622         \}}
\DoxyCodeLine{6623 }
\DoxyCodeLine{6624     \textcolor{keyword}{private}:}
\DoxyCodeLine{6625         std::ostream\& m\_stream;}
\DoxyCodeLine{6626         std::streambuf* m\_prevBuf;}
\DoxyCodeLine{6627         std::ostringstream m\_oss;}
\DoxyCodeLine{6628         std::string\& m\_targetString;}
\DoxyCodeLine{6629     \};}
\DoxyCodeLine{6630 }
\DoxyCodeLine{6631     \textcolor{comment}{// StdErr has two constituent streams in C++, std::cerr and std::clog}}
\DoxyCodeLine{6632     \textcolor{comment}{// This means that we need to redirect 2 streams into 1 to keep proper}}
\DoxyCodeLine{6633     \textcolor{comment}{// order of writes and cannot use StreamRedirect on its own}}
\DoxyCodeLine{6634     \textcolor{keyword}{class }StdErrRedirect \{}
\DoxyCodeLine{6635     \textcolor{keyword}{public}:}
\DoxyCodeLine{6636         StdErrRedirect(std::string\& targetString)}
\DoxyCodeLine{6637         :m\_cerrBuf( cerr().rdbuf() ), m\_clogBuf(clog().rdbuf()),}
\DoxyCodeLine{6638         m\_targetString(targetString)\{}
\DoxyCodeLine{6639             cerr().rdbuf(m\_oss.rdbuf());}
\DoxyCodeLine{6640             clog().rdbuf(m\_oss.rdbuf());}
\DoxyCodeLine{6641         \}}
\DoxyCodeLine{6642         \string~StdErrRedirect() \{}
\DoxyCodeLine{6643             m\_targetString += m\_oss.str();}
\DoxyCodeLine{6644             cerr().rdbuf(m\_cerrBuf);}
\DoxyCodeLine{6645             clog().rdbuf(m\_clogBuf);}
\DoxyCodeLine{6646         \}}
\DoxyCodeLine{6647     \textcolor{keyword}{private}:}
\DoxyCodeLine{6648         std::streambuf* m\_cerrBuf;}
\DoxyCodeLine{6649         std::streambuf* m\_clogBuf;}
\DoxyCodeLine{6650         std::ostringstream m\_oss;}
\DoxyCodeLine{6651         std::string\& m\_targetString;}
\DoxyCodeLine{6652     \};}
\DoxyCodeLine{6653 }
\DoxyCodeLine{6655 }
\DoxyCodeLine{6656     \textcolor{keyword}{class }RunContext : \textcolor{keyword}{public} IResultCapture, \textcolor{keyword}{public} IRunner \{}
\DoxyCodeLine{6657 }
\DoxyCodeLine{6658         RunContext( RunContext \textcolor{keyword}{const}\& );}
\DoxyCodeLine{6659         \textcolor{keywordtype}{void} operator =( RunContext \textcolor{keyword}{const}\& );}
\DoxyCodeLine{6660 }
\DoxyCodeLine{6661     \textcolor{keyword}{public}:}
\DoxyCodeLine{6662 }
\DoxyCodeLine{6663         \textcolor{keyword}{explicit} RunContext( Ptr<IConfig const> \textcolor{keyword}{const}\& \_config, Ptr<IStreamingReporter> \textcolor{keyword}{const}\& reporter )}
\DoxyCodeLine{6664         :   m\_runInfo( \_config-\/>name() ),}
\DoxyCodeLine{6665             m\_context( getCurrentMutableContext() ),}
\DoxyCodeLine{6666             m\_activeTestCase( CATCH\_NULL ),}
\DoxyCodeLine{6667             m\_config( \_config ),}
\DoxyCodeLine{6668             m\_reporter( reporter ),}
\DoxyCodeLine{6669             m\_shouldReportUnexpected ( true )}
\DoxyCodeLine{6670         \{}
\DoxyCodeLine{6671             m\_context.setRunner( \textcolor{keyword}{this} );}
\DoxyCodeLine{6672             m\_context.setConfig( m\_config );}
\DoxyCodeLine{6673             m\_context.setResultCapture( \textcolor{keyword}{this} );}
\DoxyCodeLine{6674             m\_reporter-\/>testRunStarting( m\_runInfo );}
\DoxyCodeLine{6675         \}}
\DoxyCodeLine{6676 }
\DoxyCodeLine{6677         \textcolor{keyword}{virtual} \string~RunContext() \{}
\DoxyCodeLine{6678             m\_reporter-\/>testRunEnded( TestRunStats( m\_runInfo, m\_totals, aborting() ) );}
\DoxyCodeLine{6679         \}}
\DoxyCodeLine{6680 }
\DoxyCodeLine{6681         \textcolor{keywordtype}{void} testGroupStarting( std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount ) \{}
\DoxyCodeLine{6682             m\_reporter-\/>testGroupStarting( GroupInfo( testSpec, groupIndex, groupsCount ) );}
\DoxyCodeLine{6683         \}}
\DoxyCodeLine{6684         \textcolor{keywordtype}{void} testGroupEnded( std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount ) \{}
\DoxyCodeLine{6685             m\_reporter-\/>testGroupEnded( TestGroupStats( GroupInfo( testSpec, groupIndex, groupsCount ), totals, aborting() ) );}
\DoxyCodeLine{6686         \}}
\DoxyCodeLine{6687 }
\DoxyCodeLine{6688         Totals runTest( TestCase \textcolor{keyword}{const}\& testCase ) \{}
\DoxyCodeLine{6689             Totals prevTotals = m\_totals;}
\DoxyCodeLine{6690 }
\DoxyCodeLine{6691             std::string redirectedCout;}
\DoxyCodeLine{6692             std::string redirectedCerr;}
\DoxyCodeLine{6693 }
\DoxyCodeLine{6694             TestCaseInfo testInfo = testCase.getTestCaseInfo();}
\DoxyCodeLine{6695 }
\DoxyCodeLine{6696             m\_reporter-\/>testCaseStarting( testInfo );}
\DoxyCodeLine{6697 }
\DoxyCodeLine{6698             m\_activeTestCase = \&testCase;}
\DoxyCodeLine{6699 }
\DoxyCodeLine{6700             \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{6701                 ITracker\& rootTracker = m\_trackerContext.startRun();}
\DoxyCodeLine{6702                 assert( rootTracker.isSectionTracker() );}
\DoxyCodeLine{6703                 \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( rootTracker ).addInitialFilters( m\_config-\/>getSectionsToRun() );}
\DoxyCodeLine{6704                 \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{6705                     m\_trackerContext.startCycle();}
\DoxyCodeLine{6706                     m\_testCaseTracker = \&SectionTracker::acquire( m\_trackerContext, TestCaseTracking::NameAndLocation( testInfo.name, testInfo.lineInfo ) );}
\DoxyCodeLine{6707                     runCurrentTest( redirectedCout, redirectedCerr );}
\DoxyCodeLine{6708                 \}}
\DoxyCodeLine{6709                 \textcolor{keywordflow}{while}( !m\_testCaseTracker-\/>isSuccessfullyCompleted() \&\& !aborting() );}
\DoxyCodeLine{6710             \}}
\DoxyCodeLine{6711             \textcolor{comment}{// !TBD: deprecated -\/ this will be replaced by indexed trackers}}
\DoxyCodeLine{6712             \textcolor{keywordflow}{while}( getCurrentContext().advanceGeneratorsForCurrentTest() \&\& !aborting() );}
\DoxyCodeLine{6713 }
\DoxyCodeLine{6714             Totals deltaTotals = m\_totals.delta( prevTotals );}
\DoxyCodeLine{6715             \textcolor{keywordflow}{if}( testInfo.expectedToFail() \&\& deltaTotals.testCases.passed > 0 ) \{}
\DoxyCodeLine{6716                 deltaTotals.assertions.failed++;}
\DoxyCodeLine{6717                 deltaTotals.testCases.passed-\/-\/;}
\DoxyCodeLine{6718                 deltaTotals.testCases.failed++;}
\DoxyCodeLine{6719             \}}
\DoxyCodeLine{6720             m\_totals.testCases += deltaTotals.testCases;}
\DoxyCodeLine{6721             m\_reporter-\/>testCaseEnded( TestCaseStats(   testInfo,}
\DoxyCodeLine{6722                                                         deltaTotals,}
\DoxyCodeLine{6723                                                         redirectedCout,}
\DoxyCodeLine{6724                                                         redirectedCerr,}
\DoxyCodeLine{6725                                                         aborting() ) );}
\DoxyCodeLine{6726 }
\DoxyCodeLine{6727             m\_activeTestCase = CATCH\_NULL;}
\DoxyCodeLine{6728             m\_testCaseTracker = CATCH\_NULL;}
\DoxyCodeLine{6729 }
\DoxyCodeLine{6730             \textcolor{keywordflow}{return} deltaTotals;}
\DoxyCodeLine{6731         \}}
\DoxyCodeLine{6732 }
\DoxyCodeLine{6733         Ptr<IConfig const> config()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6734             \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{6735         \}}
\DoxyCodeLine{6736 }
\DoxyCodeLine{6737     \textcolor{keyword}{private}: \textcolor{comment}{// IResultCapture}}
\DoxyCodeLine{6738 }
\DoxyCodeLine{6739         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionEnded( AssertionResult \textcolor{keyword}{const}\& result ) \{}
\DoxyCodeLine{6740             \textcolor{keywordflow}{if}( result.getResultType() == ResultWas::Ok ) \{}
\DoxyCodeLine{6741                 m\_totals.assertions.passed++;}
\DoxyCodeLine{6742             \}}
\DoxyCodeLine{6743             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( !result.isOk() ) \{}
\DoxyCodeLine{6744                 \textcolor{keywordflow}{if}( m\_activeTestCase-\/>getTestCaseInfo().okToFail() )}
\DoxyCodeLine{6745                     m\_totals.assertions.failedButOk++;}
\DoxyCodeLine{6746                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{6747                     m\_totals.assertions.failed++;}
\DoxyCodeLine{6748             \}}
\DoxyCodeLine{6749 }
\DoxyCodeLine{6750             \textcolor{comment}{// We have no use for the return value (whether messages should be cleared), because messages were made scoped}}
\DoxyCodeLine{6751             \textcolor{comment}{// and should be let to clear themselves out.}}
\DoxyCodeLine{6752             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(m\_reporter-\/>assertionEnded(AssertionStats(result, m\_messages, m\_totals)));}
\DoxyCodeLine{6753 }
\DoxyCodeLine{6754             \textcolor{comment}{// Reset working state}}
\DoxyCodeLine{6755             m\_lastAssertionInfo = AssertionInfo( \textcolor{stringliteral}{"{}"{}}, m\_lastAssertionInfo.lineInfo, \textcolor{stringliteral}{"{}\{Unknown expression after the reported line\}"{}} , m\_lastAssertionInfo.resultDisposition );}
\DoxyCodeLine{6756             m\_lastResult = result;}
\DoxyCodeLine{6757         \}}
\DoxyCodeLine{6758 }
\DoxyCodeLine{6759         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} lastAssertionPassed()}
\DoxyCodeLine{6760         \{}
\DoxyCodeLine{6761             \textcolor{keywordflow}{return} m\_totals.assertions.passed == (m\_prevPassed + 1);}
\DoxyCodeLine{6762         \}}
\DoxyCodeLine{6763 }
\DoxyCodeLine{6764         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionPassed()}
\DoxyCodeLine{6765         \{}
\DoxyCodeLine{6766             m\_totals.assertions.passed++;}
\DoxyCodeLine{6767             m\_lastAssertionInfo.capturedExpression = \textcolor{stringliteral}{"{}\{Unknown expression after the reported line\}"{}};}
\DoxyCodeLine{6768             m\_lastAssertionInfo.macroName = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{6769         \}}
\DoxyCodeLine{6770 }
\DoxyCodeLine{6771         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionRun()}
\DoxyCodeLine{6772         \{}
\DoxyCodeLine{6773             m\_prevPassed = m\_totals.assertions.passed;}
\DoxyCodeLine{6774         \}}
\DoxyCodeLine{6775 }
\DoxyCodeLine{6776         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} sectionStarted (}
\DoxyCodeLine{6777             SectionInfo \textcolor{keyword}{const}\& sectionInfo,}
\DoxyCodeLine{6778             Counts\& assertions}
\DoxyCodeLine{6779         )}
\DoxyCodeLine{6780         \{}
\DoxyCodeLine{6781             ITracker\& sectionTracker = SectionTracker::acquire( m\_trackerContext, TestCaseTracking::NameAndLocation( sectionInfo.name, sectionInfo.lineInfo ) );}
\DoxyCodeLine{6782             \textcolor{keywordflow}{if}( !sectionTracker.isOpen() )}
\DoxyCodeLine{6783                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6784             m\_activeSections.push\_back( \&sectionTracker );}
\DoxyCodeLine{6785 }
\DoxyCodeLine{6786             m\_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;}
\DoxyCodeLine{6787 }
\DoxyCodeLine{6788             m\_reporter-\/>sectionStarting( sectionInfo );}
\DoxyCodeLine{6789 }
\DoxyCodeLine{6790             assertions = m\_totals.assertions;}
\DoxyCodeLine{6791 }
\DoxyCodeLine{6792             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6793         \}}
\DoxyCodeLine{6794         \textcolor{keywordtype}{bool} testForMissingAssertions( Counts\& assertions ) \{}
\DoxyCodeLine{6795             \textcolor{keywordflow}{if}( assertions.total() != 0 )}
\DoxyCodeLine{6796                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6797             \textcolor{keywordflow}{if}( !m\_config-\/>warnAboutMissingAssertions() )}
\DoxyCodeLine{6798                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6799             \textcolor{keywordflow}{if}( m\_trackerContext.currentTracker().hasChildren() )}
\DoxyCodeLine{6800                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6801             m\_totals.assertions.failed++;}
\DoxyCodeLine{6802             assertions.failed++;}
\DoxyCodeLine{6803             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6804         \}}
\DoxyCodeLine{6805 }
\DoxyCodeLine{6806         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \{}
\DoxyCodeLine{6807             Counts assertions = m\_totals.assertions -\/ endInfo.prevAssertions;}
\DoxyCodeLine{6808             \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions( assertions );}
\DoxyCodeLine{6809 }
\DoxyCodeLine{6810             \textcolor{keywordflow}{if}( !m\_activeSections.empty() ) \{}
\DoxyCodeLine{6811                 m\_activeSections.back()-\/>close();}
\DoxyCodeLine{6812                 m\_activeSections.pop\_back();}
\DoxyCodeLine{6813             \}}
\DoxyCodeLine{6814 }
\DoxyCodeLine{6815             m\_reporter-\/>sectionEnded( SectionStats( endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions ) );}
\DoxyCodeLine{6816             m\_messages.clear();}
\DoxyCodeLine{6817         \}}
\DoxyCodeLine{6818 }
\DoxyCodeLine{6819         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEndedEarly( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \{}
\DoxyCodeLine{6820             \textcolor{keywordflow}{if}( m\_unfinishedSections.empty() )}
\DoxyCodeLine{6821                 m\_activeSections.back()-\/>fail();}
\DoxyCodeLine{6822             \textcolor{keywordflow}{else}}
\DoxyCodeLine{6823                 m\_activeSections.back()-\/>close();}
\DoxyCodeLine{6824             m\_activeSections.pop\_back();}
\DoxyCodeLine{6825 }
\DoxyCodeLine{6826             m\_unfinishedSections.push\_back( endInfo );}
\DoxyCodeLine{6827         \}}
\DoxyCodeLine{6828 }
\DoxyCodeLine{6829         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} pushScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \{}
\DoxyCodeLine{6830             m\_messages.push\_back( message );}
\DoxyCodeLine{6831         \}}
\DoxyCodeLine{6832 }
\DoxyCodeLine{6833         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} popScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \{}
\DoxyCodeLine{6834             m\_messages.erase( std::remove( m\_messages.begin(), m\_messages.end(), message ), m\_messages.end() );}
\DoxyCodeLine{6835         \}}
\DoxyCodeLine{6836 }
\DoxyCodeLine{6837         \textcolor{keyword}{virtual} std::string getCurrentTestName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6838             \textcolor{keywordflow}{return} m\_activeTestCase}
\DoxyCodeLine{6839                 ? m\_activeTestCase-\/>getTestCaseInfo().name}
\DoxyCodeLine{6840                 : std::string();}
\DoxyCodeLine{6841         \}}
\DoxyCodeLine{6842 }
\DoxyCodeLine{6843         \textcolor{keyword}{virtual} \textcolor{keyword}{const} AssertionResult* getLastResult()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6844             \textcolor{keywordflow}{return} \&m\_lastResult;}
\DoxyCodeLine{6845         \}}
\DoxyCodeLine{6846 }
\DoxyCodeLine{6847         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} exceptionEarlyReported() \{}
\DoxyCodeLine{6848             m\_shouldReportUnexpected = \textcolor{keyword}{false};}
\DoxyCodeLine{6849         \}}
\DoxyCodeLine{6850 }
\DoxyCodeLine{6851         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleFatalErrorCondition( std::string \textcolor{keyword}{const}\& message ) \{}
\DoxyCodeLine{6852             \textcolor{comment}{// Don't rebuild the result -\/-\/ the stringification itself can cause more fatal errors}}
\DoxyCodeLine{6853             \textcolor{comment}{// Instead, fake a result data.}}
\DoxyCodeLine{6854             AssertionResultData tempResult;}
\DoxyCodeLine{6855             tempResult.resultType = ResultWas::FatalErrorCondition;}
\DoxyCodeLine{6856             tempResult.message = message;}
\DoxyCodeLine{6857             AssertionResult result(m\_lastAssertionInfo, tempResult);}
\DoxyCodeLine{6858 }
\DoxyCodeLine{6859             getResultCapture().assertionEnded(result);}
\DoxyCodeLine{6860 }
\DoxyCodeLine{6861             handleUnfinishedSections();}
\DoxyCodeLine{6862 }
\DoxyCodeLine{6863             \textcolor{comment}{// Recreate section for test case (as we will lose the one that was in scope)}}
\DoxyCodeLine{6864             TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{6865             SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );}
\DoxyCodeLine{6866 }
\DoxyCodeLine{6867             Counts assertions;}
\DoxyCodeLine{6868             assertions.failed = 1;}
\DoxyCodeLine{6869             SectionStats testCaseSectionStats( testCaseSection, assertions, 0, \textcolor{keyword}{false} );}
\DoxyCodeLine{6870             m\_reporter-\/>sectionEnded( testCaseSectionStats );}
\DoxyCodeLine{6871 }
\DoxyCodeLine{6872             TestCaseInfo testInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{6873 }
\DoxyCodeLine{6874             Totals deltaTotals;}
\DoxyCodeLine{6875             deltaTotals.testCases.failed = 1;}
\DoxyCodeLine{6876             deltaTotals.assertions.failed = 1;}
\DoxyCodeLine{6877             m\_reporter-\/>testCaseEnded( TestCaseStats(   testInfo,}
\DoxyCodeLine{6878                                                         deltaTotals,}
\DoxyCodeLine{6879                                                         std::string(),}
\DoxyCodeLine{6880                                                         std::string(),}
\DoxyCodeLine{6881                                                         \textcolor{keyword}{false} ) );}
\DoxyCodeLine{6882             m\_totals.testCases.failed++;}
\DoxyCodeLine{6883             testGroupEnded( std::string(), m\_totals, 1, 1 );}
\DoxyCodeLine{6884             m\_reporter-\/>testRunEnded( TestRunStats( m\_runInfo, m\_totals, \textcolor{keyword}{false} ) );}
\DoxyCodeLine{6885         \}}
\DoxyCodeLine{6886 }
\DoxyCodeLine{6887     \textcolor{keyword}{public}:}
\DoxyCodeLine{6888         \textcolor{comment}{// !TBD We need to do this another way!}}
\DoxyCodeLine{6889         \textcolor{keywordtype}{bool} aborting()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6890             \textcolor{keywordflow}{return} m\_totals.assertions.failed == \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}( m\_config-\/>abortAfter() );}
\DoxyCodeLine{6891         \}}
\DoxyCodeLine{6892 }
\DoxyCodeLine{6893     \textcolor{keyword}{private}:}
\DoxyCodeLine{6894 }
\DoxyCodeLine{6895         \textcolor{keywordtype}{void} runCurrentTest( std::string\& redirectedCout, std::string\& redirectedCerr ) \{}
\DoxyCodeLine{6896             TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{6897             SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );}
\DoxyCodeLine{6898             m\_reporter-\/>sectionStarting( testCaseSection );}
\DoxyCodeLine{6899             Counts prevAssertions = m\_totals.assertions;}
\DoxyCodeLine{6900             \textcolor{keywordtype}{double} duration = 0;}
\DoxyCodeLine{6901             m\_shouldReportUnexpected = \textcolor{keyword}{true};}
\DoxyCodeLine{6902             \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{6903                 m\_lastAssertionInfo = AssertionInfo( \textcolor{stringliteral}{"{}TEST\_CASE"{}}, testCaseInfo.lineInfo, \textcolor{stringliteral}{"{}"{}}, ResultDisposition::Normal );}
\DoxyCodeLine{6904 }
\DoxyCodeLine{6905                 seedRng( *m\_config );}
\DoxyCodeLine{6906 }
\DoxyCodeLine{6907                 Timer timer;}
\DoxyCodeLine{6908                 timer.start();}
\DoxyCodeLine{6909                 \textcolor{keywordflow}{if}( m\_reporter-\/>getPreferences().shouldRedirectStdOut ) \{}
\DoxyCodeLine{6910                     StreamRedirect coutRedir( Catch::cout(), redirectedCout );}
\DoxyCodeLine{6911                     StdErrRedirect errRedir( redirectedCerr );}
\DoxyCodeLine{6912                     invokeActiveTestCase();}
\DoxyCodeLine{6913                 \}}
\DoxyCodeLine{6914                 \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{6915                     invokeActiveTestCase();}
\DoxyCodeLine{6916                 \}}
\DoxyCodeLine{6917                 duration = timer.getElapsedSeconds();}
\DoxyCodeLine{6918             \}}
\DoxyCodeLine{6919             \textcolor{keywordflow}{catch}( TestFailureException\& ) \{}
\DoxyCodeLine{6920                 \textcolor{comment}{// This just means the test was aborted due to failure}}
\DoxyCodeLine{6921             \}}
\DoxyCodeLine{6922             \textcolor{keywordflow}{catch}(...) \{}
\DoxyCodeLine{6923                 \textcolor{comment}{// Under CATCH\_CONFIG\_FAST\_COMPILE, unexpected exceptions under REQUIRE assertions}}
\DoxyCodeLine{6924                 \textcolor{comment}{// are reported without translation at the point of origin.}}
\DoxyCodeLine{6925                 \textcolor{keywordflow}{if} (m\_shouldReportUnexpected) \{}
\DoxyCodeLine{6926                     makeUnexpectedResultBuilder().useActiveException();}
\DoxyCodeLine{6927                 \}}
\DoxyCodeLine{6928             \}}
\DoxyCodeLine{6929             m\_testCaseTracker-\/>close();}
\DoxyCodeLine{6930             handleUnfinishedSections();}
\DoxyCodeLine{6931             m\_messages.clear();}
\DoxyCodeLine{6932 }
\DoxyCodeLine{6933             Counts assertions = m\_totals.assertions -\/ prevAssertions;}
\DoxyCodeLine{6934             \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions( assertions );}
\DoxyCodeLine{6935 }
\DoxyCodeLine{6936             SectionStats testCaseSectionStats( testCaseSection, assertions, duration, missingAssertions );}
\DoxyCodeLine{6937             m\_reporter-\/>sectionEnded( testCaseSectionStats );}
\DoxyCodeLine{6938         \}}
\DoxyCodeLine{6939 }
\DoxyCodeLine{6940         \textcolor{keywordtype}{void} invokeActiveTestCase() \{}
\DoxyCodeLine{6941             FatalConditionHandler fatalConditionHandler; \textcolor{comment}{// Handle signals}}
\DoxyCodeLine{6942             m\_activeTestCase-\/>invoke();}
\DoxyCodeLine{6943             fatalConditionHandler.reset();}
\DoxyCodeLine{6944         \}}
\DoxyCodeLine{6945 }
\DoxyCodeLine{6946     \textcolor{keyword}{private}:}
\DoxyCodeLine{6947 }
\DoxyCodeLine{6948         ResultBuilder makeUnexpectedResultBuilder()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6949             \textcolor{keywordflow}{return} ResultBuilder(   m\_lastAssertionInfo.macroName,}
\DoxyCodeLine{6950                                     m\_lastAssertionInfo.lineInfo,}
\DoxyCodeLine{6951                                     m\_lastAssertionInfo.capturedExpression,}
\DoxyCodeLine{6952                                     m\_lastAssertionInfo.resultDisposition );}
\DoxyCodeLine{6953         \}}
\DoxyCodeLine{6954 }
\DoxyCodeLine{6955         \textcolor{keywordtype}{void} handleUnfinishedSections() \{}
\DoxyCodeLine{6956             \textcolor{comment}{// If sections ended prematurely due to an exception we stored their}}
\DoxyCodeLine{6957             \textcolor{comment}{// infos here so we can tear them down outside the unwind process.}}
\DoxyCodeLine{6958             \textcolor{keywordflow}{for}( std::vector<SectionEndInfo>::const\_reverse\_iterator it = m\_unfinishedSections.rbegin(),}
\DoxyCodeLine{6959                         itEnd = m\_unfinishedSections.rend();}
\DoxyCodeLine{6960                     it != itEnd;}
\DoxyCodeLine{6961                     ++it )}
\DoxyCodeLine{6962                 sectionEnded( *it );}
\DoxyCodeLine{6963             m\_unfinishedSections.clear();}
\DoxyCodeLine{6964         \}}
\DoxyCodeLine{6965 }
\DoxyCodeLine{6966         TestRunInfo m\_runInfo;}
\DoxyCodeLine{6967         IMutableContext\& m\_context;}
\DoxyCodeLine{6968         TestCase \textcolor{keyword}{const}* m\_activeTestCase;}
\DoxyCodeLine{6969         ITracker* m\_testCaseTracker;}
\DoxyCodeLine{6970         ITracker* m\_currentSectionTracker;}
\DoxyCodeLine{6971         AssertionResult m\_lastResult;}
\DoxyCodeLine{6972 }
\DoxyCodeLine{6973         Ptr<IConfig const> m\_config;}
\DoxyCodeLine{6974         Totals m\_totals;}
\DoxyCodeLine{6975         Ptr<IStreamingReporter> m\_reporter;}
\DoxyCodeLine{6976         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{6977         AssertionInfo m\_lastAssertionInfo;}
\DoxyCodeLine{6978         std::vector<SectionEndInfo> m\_unfinishedSections;}
\DoxyCodeLine{6979         std::vector<ITracker*> m\_activeSections;}
\DoxyCodeLine{6980         TrackerContext m\_trackerContext;}
\DoxyCodeLine{6981         \textcolor{keywordtype}{size\_t} m\_prevPassed;}
\DoxyCodeLine{6982         \textcolor{keywordtype}{bool} m\_shouldReportUnexpected;}
\DoxyCodeLine{6983     \};}
\DoxyCodeLine{6984 }
\DoxyCodeLine{6985     IResultCapture\& getResultCapture() \{}
\DoxyCodeLine{6986         \textcolor{keywordflow}{if}( IResultCapture* capture = getCurrentContext().getResultCapture() )}
\DoxyCodeLine{6987             \textcolor{keywordflow}{return} *capture;}
\DoxyCodeLine{6988         \textcolor{keywordflow}{else}}
\DoxyCodeLine{6989             \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}No result capture instance"{}} );}
\DoxyCodeLine{6990     \}}
\DoxyCodeLine{6991 }
\DoxyCodeLine{6992 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6993 }
\DoxyCodeLine{6994 \textcolor{comment}{// \#included from: internal/catch\_version.h}}
\DoxyCodeLine{6995 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_VERSION\_H\_INCLUDED}}
\DoxyCodeLine{6996 }
\DoxyCodeLine{6997 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6998 }
\DoxyCodeLine{6999     \textcolor{comment}{// Versioning information}}
\DoxyCodeLine{7000     \textcolor{keyword}{struct }Version \{}
\DoxyCodeLine{7001         Version(    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{7002                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{7003                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{7004                     \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{7005                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber );}
\DoxyCodeLine{7006 }
\DoxyCodeLine{7007         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} majorVersion;}
\DoxyCodeLine{7008         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} minorVersion;}
\DoxyCodeLine{7009         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} patchNumber;}
\DoxyCodeLine{7010 }
\DoxyCodeLine{7011         \textcolor{comment}{// buildNumber is only used if branchName is not null}}
\DoxyCodeLine{7012         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} branchName;}
\DoxyCodeLine{7013         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} buildNumber;}
\DoxyCodeLine{7014 }
\DoxyCodeLine{7015         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version );}
\DoxyCodeLine{7016 }
\DoxyCodeLine{7017     \textcolor{keyword}{private}:}
\DoxyCodeLine{7018         \textcolor{keywordtype}{void} operator=( Version \textcolor{keyword}{const}\& );}
\DoxyCodeLine{7019     \};}
\DoxyCodeLine{7020 }
\DoxyCodeLine{7021     \textcolor{keyword}{inline} Version libraryVersion();}
\DoxyCodeLine{7022 \}}
\DoxyCodeLine{7023 }
\DoxyCodeLine{7024 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{7025 \textcolor{preprocessor}{\#include <stdlib.h>}}
\DoxyCodeLine{7026 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{7027 }
\DoxyCodeLine{7028 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7029 }
\DoxyCodeLine{7030     Ptr<IStreamingReporter> createReporter( std::string \textcolor{keyword}{const}\& reporterName, Ptr<Config> \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{7031         Ptr<IStreamingReporter> reporter = getRegistryHub().getReporterRegistry().create( reporterName, config.get() );}
\DoxyCodeLine{7032         \textcolor{keywordflow}{if}( !reporter ) \{}
\DoxyCodeLine{7033             std::ostringstream oss;}
\DoxyCodeLine{7034             oss << \textcolor{stringliteral}{"{}No reporter registered with name: '"{}} << reporterName << \textcolor{stringliteral}{"{}'"{}};}
\DoxyCodeLine{7035             \textcolor{keywordflow}{throw} std::domain\_error( oss.str() );}
\DoxyCodeLine{7036         \}}
\DoxyCodeLine{7037         \textcolor{keywordflow}{return} reporter;}
\DoxyCodeLine{7038     \}}
\DoxyCodeLine{7039 }
\DoxyCodeLine{7040 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DEFAULT\_REPORTER)}}
\DoxyCodeLine{7041 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_DEFAULT\_REPORTER "{}console"{}}}
\DoxyCodeLine{7042 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7043 }
\DoxyCodeLine{7044     Ptr<IStreamingReporter> makeReporter( Ptr<Config> \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{7045         std::vector<std::string> reporters = config-\/>getReporterNames();}
\DoxyCodeLine{7046         \textcolor{keywordflow}{if}( reporters.empty() )}
\DoxyCodeLine{7047             reporters.push\_back( CATCH\_CONFIG\_DEFAULT\_REPORTER );}
\DoxyCodeLine{7048 }
\DoxyCodeLine{7049         Ptr<IStreamingReporter> reporter;}
\DoxyCodeLine{7050         \textcolor{keywordflow}{for}( std::vector<std::string>::const\_iterator it = reporters.begin(), itEnd = reporters.end();}
\DoxyCodeLine{7051                 it != itEnd;}
\DoxyCodeLine{7052                 ++it )}
\DoxyCodeLine{7053             reporter = addReporter( reporter, createReporter( *it, config ) );}
\DoxyCodeLine{7054         \textcolor{keywordflow}{return} reporter;}
\DoxyCodeLine{7055     \}}
\DoxyCodeLine{7056     Ptr<IStreamingReporter> addListeners( Ptr<IConfig const> \textcolor{keyword}{const}\& config, Ptr<IStreamingReporter> reporters ) \{}
\DoxyCodeLine{7057         IReporterRegistry::Listeners listeners = getRegistryHub().getReporterRegistry().getListeners();}
\DoxyCodeLine{7058         \textcolor{keywordflow}{for}( IReporterRegistry::Listeners::const\_iterator it = listeners.begin(), itEnd = listeners.end();}
\DoxyCodeLine{7059                 it != itEnd;}
\DoxyCodeLine{7060                 ++it )}
\DoxyCodeLine{7061             reporters = addReporter(reporters, (*it)-\/>create( ReporterConfig( config ) ) );}
\DoxyCodeLine{7062         \textcolor{keywordflow}{return} reporters;}
\DoxyCodeLine{7063     \}}
\DoxyCodeLine{7064 }
\DoxyCodeLine{7065     Totals runTests( Ptr<Config> \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{7066 }
\DoxyCodeLine{7067         Ptr<IConfig const> iconfig = config.get();}
\DoxyCodeLine{7068 }
\DoxyCodeLine{7069         Ptr<IStreamingReporter> reporter = makeReporter( config );}
\DoxyCodeLine{7070         reporter = addListeners( iconfig, reporter );}
\DoxyCodeLine{7071 }
\DoxyCodeLine{7072         RunContext context( iconfig, reporter );}
\DoxyCodeLine{7073 }
\DoxyCodeLine{7074         Totals totals;}
\DoxyCodeLine{7075 }
\DoxyCodeLine{7076         context.testGroupStarting( config-\/>name(), 1, 1 );}
\DoxyCodeLine{7077 }
\DoxyCodeLine{7078         TestSpec testSpec = config-\/>testSpec();}
\DoxyCodeLine{7079         \textcolor{keywordflow}{if}( !testSpec.hasFilters() )}
\DoxyCodeLine{7080             testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( \textcolor{stringliteral}{"{}\string~[.]"{}} ).testSpec(); \textcolor{comment}{// All not hidden tests}}
\DoxyCodeLine{7081 }
\DoxyCodeLine{7082         std::vector<TestCase> \textcolor{keyword}{const}\& allTestCases = getAllTestCasesSorted( *iconfig );}
\DoxyCodeLine{7083         \textcolor{keywordflow}{for}( std::vector<TestCase>::const\_iterator it = allTestCases.begin(), itEnd = allTestCases.end();}
\DoxyCodeLine{7084                 it != itEnd;}
\DoxyCodeLine{7085                 ++it ) \{}
\DoxyCodeLine{7086             \textcolor{keywordflow}{if}( !context.aborting() \&\& matchTest( *it, testSpec, *iconfig ) )}
\DoxyCodeLine{7087                 totals += context.runTest( *it );}
\DoxyCodeLine{7088             \textcolor{keywordflow}{else}}
\DoxyCodeLine{7089                 reporter-\/>skipTest( *it );}
\DoxyCodeLine{7090         \}}
\DoxyCodeLine{7091 }
\DoxyCodeLine{7092         context.testGroupEnded( iconfig-\/>name(), totals, 1, 1 );}
\DoxyCodeLine{7093         \textcolor{keywordflow}{return} totals;}
\DoxyCodeLine{7094     \}}
\DoxyCodeLine{7095 }
\DoxyCodeLine{7096     \textcolor{keywordtype}{void} applyFilenamesAsTags( IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{7097         std::vector<TestCase> \textcolor{keyword}{const}\& tests = getAllTestCasesSorted( config );}
\DoxyCodeLine{7098         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < tests.size(); ++i ) \{}
\DoxyCodeLine{7099             TestCase\& test = \textcolor{keyword}{const\_cast<}TestCase\&\textcolor{keyword}{>}( tests[i] );}
\DoxyCodeLine{7100             std::set<std::string> tags = test.tags;}
\DoxyCodeLine{7101 }
\DoxyCodeLine{7102             std::string filename = test.lineInfo.file;}
\DoxyCodeLine{7103             std::string::size\_type lastSlash = filename.find\_last\_of( \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)/"{}} );}
\DoxyCodeLine{7104             \textcolor{keywordflow}{if}( lastSlash != std::string::npos )}
\DoxyCodeLine{7105                 filename = filename.substr( lastSlash+1 );}
\DoxyCodeLine{7106 }
\DoxyCodeLine{7107             std::string::size\_type lastDot = filename.find\_last\_of( \textcolor{charliteral}{'.'} );}
\DoxyCodeLine{7108             \textcolor{keywordflow}{if}( lastDot != std::string::npos )}
\DoxyCodeLine{7109                 filename = filename.substr( 0, lastDot );}
\DoxyCodeLine{7110 }
\DoxyCodeLine{7111             tags.insert( \textcolor{charliteral}{'\#'} + filename );}
\DoxyCodeLine{7112             setTags( test, tags );}
\DoxyCodeLine{7113         \}}
\DoxyCodeLine{7114     \}}
\DoxyCodeLine{7115 }
\DoxyCodeLine{7116     \textcolor{keyword}{class }Session : NonCopyable \{}
\DoxyCodeLine{7117         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} alreadyInstantiated;}
\DoxyCodeLine{7118 }
\DoxyCodeLine{7119     \textcolor{keyword}{public}:}
\DoxyCodeLine{7120 }
\DoxyCodeLine{7121         \textcolor{keyword}{struct }OnUnusedOptions \{ \textcolor{keyword}{enum} DoWhat \{ Ignore, Fail \}; \};}
\DoxyCodeLine{7122 }
\DoxyCodeLine{7123         Session()}
\DoxyCodeLine{7124         : m\_cli( makeCommandLineParser() ) \{}
\DoxyCodeLine{7125             \textcolor{keywordflow}{if}( alreadyInstantiated ) \{}
\DoxyCodeLine{7126                 std::string msg = \textcolor{stringliteral}{"{}Only one instance of Catch::Session can ever be used"{}};}
\DoxyCodeLine{7127                 Catch::cerr() << msg << std::endl;}
\DoxyCodeLine{7128                 \textcolor{keywordflow}{throw} std::logic\_error( msg );}
\DoxyCodeLine{7129             \}}
\DoxyCodeLine{7130             alreadyInstantiated = \textcolor{keyword}{true};}
\DoxyCodeLine{7131         \}}
\DoxyCodeLine{7132         \string~Session() \{}
\DoxyCodeLine{7133             Catch::cleanUp();}
\DoxyCodeLine{7134         \}}
\DoxyCodeLine{7135 }
\DoxyCodeLine{7136         \textcolor{keywordtype}{void} showHelp( std::string \textcolor{keyword}{const}\& processName ) \{}
\DoxyCodeLine{7137             Catch::cout() << \textcolor{stringliteral}{"{}\(\backslash\)nCatch v"{}} << libraryVersion() << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{7138 }
\DoxyCodeLine{7139             m\_cli.usage( Catch::cout(), processName );}
\DoxyCodeLine{7140             Catch::cout() << \textcolor{stringliteral}{"{}For more detail usage please see the project docs\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{7141         \}}
\DoxyCodeLine{7142         \textcolor{keywordtype}{void} libIdentify() \{}
\DoxyCodeLine{7143             Catch::cout()}
\DoxyCodeLine{7144                     << std::left << std::setw(16) << \textcolor{stringliteral}{"{}description: "{}} << \textcolor{stringliteral}{"{}A Catch test executable\(\backslash\)n"{}}}
\DoxyCodeLine{7145                     << std::left << std::setw(16) << \textcolor{stringliteral}{"{}category: "{}} << \textcolor{stringliteral}{"{}testframework\(\backslash\)n"{}}}
\DoxyCodeLine{7146                     << std::left << std::setw(16) << \textcolor{stringliteral}{"{}framework: "{}} << \textcolor{stringliteral}{"{}Catch Test\(\backslash\)n"{}}}
\DoxyCodeLine{7147                     << std::left << std::setw(16) << \textcolor{stringliteral}{"{}version: "{}} << libraryVersion() << std::endl;}
\DoxyCodeLine{7148         \}}
\DoxyCodeLine{7149 }
\DoxyCodeLine{7150         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const}* \textcolor{keyword}{const} argv, OnUnusedOptions::DoWhat unusedOptionBehaviour = OnUnusedOptions::Fail ) \{}
\DoxyCodeLine{7151             \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{7152                 m\_cli.setThrowOnUnrecognisedTokens( unusedOptionBehaviour == OnUnusedOptions::Fail );}
\DoxyCodeLine{7153                 m\_unusedTokens = m\_cli.parseInto( Clara::argsToVector( argc, argv ), m\_configData );}
\DoxyCodeLine{7154                 \textcolor{keywordflow}{if}( m\_configData.showHelp )}
\DoxyCodeLine{7155                     showHelp( m\_configData.processName );}
\DoxyCodeLine{7156                 \textcolor{keywordflow}{if}( m\_configData.libIdentify )}
\DoxyCodeLine{7157                     libIdentify();}
\DoxyCodeLine{7158                 m\_config.reset();}
\DoxyCodeLine{7159             \}}
\DoxyCodeLine{7160             \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{7161                 \{}
\DoxyCodeLine{7162                     Colour colourGuard( Colour::Red );}
\DoxyCodeLine{7163                     Catch::cerr()}
\DoxyCodeLine{7164                         << \textcolor{stringliteral}{"{}\(\backslash\)nError(s) in input:\(\backslash\)n"{}}}
\DoxyCodeLine{7165                         << Text( ex.what(), TextAttributes().setIndent(2) )}
\DoxyCodeLine{7166                         << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{7167                 \}}
\DoxyCodeLine{7168                 m\_cli.usage( Catch::cout(), m\_configData.processName );}
\DoxyCodeLine{7169                 \textcolor{keywordflow}{return} (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{7170             \}}
\DoxyCodeLine{7171             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7172         \}}
\DoxyCodeLine{7173 }
\DoxyCodeLine{7174         \textcolor{keywordtype}{void} useConfigData( ConfigData \textcolor{keyword}{const}\& \_configData ) \{}
\DoxyCodeLine{7175             m\_configData = \_configData;}
\DoxyCodeLine{7176             m\_config.reset();}
\DoxyCodeLine{7177         \}}
\DoxyCodeLine{7178 }
\DoxyCodeLine{7179         \textcolor{keywordtype}{int} run( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const}* \textcolor{keyword}{const} argv ) \{}
\DoxyCodeLine{7180 }
\DoxyCodeLine{7181             \textcolor{keywordtype}{int} returnCode = applyCommandLine( argc, argv );}
\DoxyCodeLine{7182             \textcolor{keywordflow}{if}( returnCode == 0 )}
\DoxyCodeLine{7183                 returnCode = run();}
\DoxyCodeLine{7184             \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{7185         \}}
\DoxyCodeLine{7186 }
\DoxyCodeLine{7187 \textcolor{preprocessor}{    \#if defined(WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{7188         \textcolor{keywordtype}{int} run( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const}* \textcolor{keyword}{const}* \textcolor{keyword}{const} argv ) \{}
\DoxyCodeLine{7189 }
\DoxyCodeLine{7190             \textcolor{keywordtype}{char} **utf8Argv = \textcolor{keyword}{new} \textcolor{keywordtype}{char} *[ argc ];}
\DoxyCodeLine{7191 }
\DoxyCodeLine{7192             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i ) \{}
\DoxyCodeLine{7193                 \textcolor{keywordtype}{int} bufSize = WideCharToMultiByte( CP\_UTF8, 0, argv[i], -\/1, NULL, 0, NULL, NULL );}
\DoxyCodeLine{7194 }
\DoxyCodeLine{7195                 utf8Argv[ i ] = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[ bufSize ];}
\DoxyCodeLine{7196 }
\DoxyCodeLine{7197                 WideCharToMultiByte( CP\_UTF8, 0, argv[i], -\/1, utf8Argv[i], bufSize, NULL, NULL );}
\DoxyCodeLine{7198             \}}
\DoxyCodeLine{7199 }
\DoxyCodeLine{7200             \textcolor{keywordtype}{int} returnCode = applyCommandLine( argc, utf8Argv );}
\DoxyCodeLine{7201             \textcolor{keywordflow}{if}( returnCode == 0 )}
\DoxyCodeLine{7202                 returnCode = run();}
\DoxyCodeLine{7203 }
\DoxyCodeLine{7204             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i )}
\DoxyCodeLine{7205                 delete [] utf8Argv[ i ];}
\DoxyCodeLine{7206 }
\DoxyCodeLine{7207             \textcolor{keyword}{delete} [] utf8Argv;}
\DoxyCodeLine{7208 }
\DoxyCodeLine{7209             \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{7210         \}}
\DoxyCodeLine{7211 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7212 }
\DoxyCodeLine{7213         \textcolor{keywordtype}{int} run() \{}
\DoxyCodeLine{7214             \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeStart ) != 0 ) \{}
\DoxyCodeLine{7215                 Catch::cout() << \textcolor{stringliteral}{"{}...waiting for enter/ return before starting"{}} << std::endl;}
\DoxyCodeLine{7216                 \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(std::getchar());}
\DoxyCodeLine{7217             \}}
\DoxyCodeLine{7218             \textcolor{keywordtype}{int} exitCode = runInternal();}
\DoxyCodeLine{7219             \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeExit ) != 0 ) \{}
\DoxyCodeLine{7220                 Catch::cout() << \textcolor{stringliteral}{"{}...waiting for enter/ return before exiting, with code: "{}} << exitCode << std::endl;}
\DoxyCodeLine{7221                 \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(std::getchar());}
\DoxyCodeLine{7222             \}}
\DoxyCodeLine{7223             \textcolor{keywordflow}{return} exitCode;}
\DoxyCodeLine{7224         \}}
\DoxyCodeLine{7225 }
\DoxyCodeLine{7226         Clara::CommandLine<ConfigData> \textcolor{keyword}{const}\& cli()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7227             \textcolor{keywordflow}{return} m\_cli;}
\DoxyCodeLine{7228         \}}
\DoxyCodeLine{7229         std::vector<Clara::Parser::Token> \textcolor{keyword}{const}\& unusedTokens()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7230             \textcolor{keywordflow}{return} m\_unusedTokens;}
\DoxyCodeLine{7231         \}}
\DoxyCodeLine{7232         ConfigData\& configData() \{}
\DoxyCodeLine{7233             \textcolor{keywordflow}{return} m\_configData;}
\DoxyCodeLine{7234         \}}
\DoxyCodeLine{7235         Config\& config() \{}
\DoxyCodeLine{7236             \textcolor{keywordflow}{if}( !m\_config )}
\DoxyCodeLine{7237                 m\_config = \textcolor{keyword}{new} Config( m\_configData );}
\DoxyCodeLine{7238             \textcolor{keywordflow}{return} *m\_config;}
\DoxyCodeLine{7239         \}}
\DoxyCodeLine{7240     \textcolor{keyword}{private}:}
\DoxyCodeLine{7241 }
\DoxyCodeLine{7242         \textcolor{keywordtype}{int} runInternal() \{}
\DoxyCodeLine{7243             \textcolor{keywordflow}{if}( m\_configData.showHelp || m\_configData.libIdentify )}
\DoxyCodeLine{7244                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7245 }
\DoxyCodeLine{7246             \textcolor{keywordflow}{try}}
\DoxyCodeLine{7247             \{}
\DoxyCodeLine{7248                 config(); \textcolor{comment}{// Force config to be constructed}}
\DoxyCodeLine{7249 }
\DoxyCodeLine{7250                 seedRng( *m\_config );}
\DoxyCodeLine{7251 }
\DoxyCodeLine{7252                 \textcolor{keywordflow}{if}( m\_configData.filenamesAsTags )}
\DoxyCodeLine{7253                     applyFilenamesAsTags( *m\_config );}
\DoxyCodeLine{7254 }
\DoxyCodeLine{7255                 \textcolor{comment}{// Handle list request}}
\DoxyCodeLine{7256                 \textcolor{keywordflow}{if}( Option<std::size\_t> listed = list( config() ) )}
\DoxyCodeLine{7257                     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( *listed );}
\DoxyCodeLine{7258 }
\DoxyCodeLine{7259                 \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( runTests( m\_config ).assertions.failed );}
\DoxyCodeLine{7260             \}}
\DoxyCodeLine{7261             \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{7262                 Catch::cerr() << ex.what() << std::endl;}
\DoxyCodeLine{7263                 \textcolor{keywordflow}{return} (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{7264             \}}
\DoxyCodeLine{7265         \}}
\DoxyCodeLine{7266 }
\DoxyCodeLine{7267         Clara::CommandLine<ConfigData> m\_cli;}
\DoxyCodeLine{7268         std::vector<Clara::Parser::Token> m\_unusedTokens;}
\DoxyCodeLine{7269         ConfigData m\_configData;}
\DoxyCodeLine{7270         Ptr<Config> m\_config;}
\DoxyCodeLine{7271     \};}
\DoxyCodeLine{7272 }
\DoxyCodeLine{7273     \textcolor{keywordtype}{bool} Session::alreadyInstantiated = \textcolor{keyword}{false};}
\DoxyCodeLine{7274 }
\DoxyCodeLine{7275 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7276 }
\DoxyCodeLine{7277 \textcolor{comment}{// \#included from: catch\_registry\_hub.hpp}}
\DoxyCodeLine{7278 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REGISTRY\_HUB\_HPP\_INCLUDED}}
\DoxyCodeLine{7279 }
\DoxyCodeLine{7280 \textcolor{comment}{// \#included from: catch\_test\_case\_registry\_impl.hpp}}
\DoxyCodeLine{7281 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TEST\_CASE\_REGISTRY\_IMPL\_HPP\_INCLUDED}}
\DoxyCodeLine{7282 }
\DoxyCodeLine{7283 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7284 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{7285 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{7286 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7287 }
\DoxyCodeLine{7288 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7289 }
\DoxyCodeLine{7290     \textcolor{keyword}{struct }RandomNumberGenerator \{}
\DoxyCodeLine{7291         \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} result\_type;}
\DoxyCodeLine{7292 }
\DoxyCodeLine{7293         result\_type operator()( result\_type n )\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::rand() \% n; \}}
\DoxyCodeLine{7294 }
\DoxyCodeLine{7295 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_SHUFFLE}}
\DoxyCodeLine{7296         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} result\_type (min)() \{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{7297         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} result\_type (max)() \{ \textcolor{keywordflow}{return} 1000000; \}}
\DoxyCodeLine{7298         result\_type operator()()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::rand() \% (max)(); \}}
\DoxyCodeLine{7299 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7300         \textcolor{keyword}{template}<\textcolor{keyword}{typename} V>}
\DoxyCodeLine{7301         \textcolor{keyword}{static} \textcolor{keywordtype}{void} shuffle( V\& vector ) \{}
\DoxyCodeLine{7302             RandomNumberGenerator rng;}
\DoxyCodeLine{7303 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_SHUFFLE}}
\DoxyCodeLine{7304             std::shuffle( vector.begin(), vector.end(), rng );}
\DoxyCodeLine{7305 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{7306             std::random\_shuffle( vector.begin(), vector.end(), rng );}
\DoxyCodeLine{7307 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7308         \}}
\DoxyCodeLine{7309     \};}
\DoxyCodeLine{7310 }
\DoxyCodeLine{7311     \textcolor{keyword}{inline} std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases ) \{}
\DoxyCodeLine{7312 }
\DoxyCodeLine{7313         std::vector<TestCase> sorted = unsortedTestCases;}
\DoxyCodeLine{7314 }
\DoxyCodeLine{7315         \textcolor{keywordflow}{switch}( config.runOrder() ) \{}
\DoxyCodeLine{7316             \textcolor{keywordflow}{case} RunTests::InLexicographicalOrder:}
\DoxyCodeLine{7317                 std::sort( sorted.begin(), sorted.end() );}
\DoxyCodeLine{7318                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{7319             \textcolor{keywordflow}{case} RunTests::InRandomOrder:}
\DoxyCodeLine{7320                 \{}
\DoxyCodeLine{7321                     seedRng( config );}
\DoxyCodeLine{7322                     RandomNumberGenerator::shuffle( sorted );}
\DoxyCodeLine{7323                 \}}
\DoxyCodeLine{7324                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{7325             \textcolor{keywordflow}{case} RunTests::InDeclarationOrder:}
\DoxyCodeLine{7326                 \textcolor{comment}{// already in declaration order}}
\DoxyCodeLine{7327                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{7328         \}}
\DoxyCodeLine{7329         \textcolor{keywordflow}{return} sorted;}
\DoxyCodeLine{7330     \}}
\DoxyCodeLine{7331     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{7332         \textcolor{keywordflow}{return} testSpec.matches( testCase ) \&\& ( config.allowThrows() || !testCase.throws() );}
\DoxyCodeLine{7333     \}}
\DoxyCodeLine{7334 }
\DoxyCodeLine{7335     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions ) \{}
\DoxyCodeLine{7336         std::set<TestCase> seenFunctions;}
\DoxyCodeLine{7337         \textcolor{keywordflow}{for}( std::vector<TestCase>::const\_iterator it = functions.begin(), itEnd = functions.end();}
\DoxyCodeLine{7338             it != itEnd;}
\DoxyCodeLine{7339             ++it ) \{}
\DoxyCodeLine{7340             std::pair<std::set<TestCase>::const\_iterator, \textcolor{keywordtype}{bool}> prev = seenFunctions.insert( *it );}
\DoxyCodeLine{7341             \textcolor{keywordflow}{if}( !prev.second ) \{}
\DoxyCodeLine{7342                 std::ostringstream ss;}
\DoxyCodeLine{7343 }
\DoxyCodeLine{7344                 ss  << Colour( Colour::Red )}
\DoxyCodeLine{7345                     << \textcolor{stringliteral}{"{}error: TEST\_CASE( \(\backslash\)"{}"{}} << it-\/>name << \textcolor{stringliteral}{"{}\(\backslash\)"{} ) already defined.\(\backslash\)n"{}}}
\DoxyCodeLine{7346                     << \textcolor{stringliteral}{"{}\(\backslash\)tFirst seen at "{}} << prev.first-\/>getTestCaseInfo().lineInfo << \textcolor{charliteral}{'\(\backslash\)n'}}
\DoxyCodeLine{7347                     << \textcolor{stringliteral}{"{}\(\backslash\)tRedefined at "{}} << it-\/>getTestCaseInfo().lineInfo << std::endl;}
\DoxyCodeLine{7348 }
\DoxyCodeLine{7349                 \textcolor{keywordflow}{throw} std::runtime\_error(ss.str());}
\DoxyCodeLine{7350             \}}
\DoxyCodeLine{7351         \}}
\DoxyCodeLine{7352     \}}
\DoxyCodeLine{7353 }
\DoxyCodeLine{7354     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{7355         std::vector<TestCase> filtered;}
\DoxyCodeLine{7356         filtered.reserve( testCases.size() );}
\DoxyCodeLine{7357         \textcolor{keywordflow}{for}( std::vector<TestCase>::const\_iterator it = testCases.begin(), itEnd = testCases.end();}
\DoxyCodeLine{7358                 it != itEnd;}
\DoxyCodeLine{7359                 ++it )}
\DoxyCodeLine{7360             \textcolor{keywordflow}{if}( matchTest( *it, testSpec, config ) )}
\DoxyCodeLine{7361                 filtered.push\_back( *it );}
\DoxyCodeLine{7362         \textcolor{keywordflow}{return} filtered;}
\DoxyCodeLine{7363     \}}
\DoxyCodeLine{7364     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{7365         \textcolor{keywordflow}{return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );}
\DoxyCodeLine{7366     \}}
\DoxyCodeLine{7367 }
\DoxyCodeLine{7368     \textcolor{keyword}{class }TestRegistry : \textcolor{keyword}{public} ITestCaseRegistry \{}
\DoxyCodeLine{7369     \textcolor{keyword}{public}:}
\DoxyCodeLine{7370         TestRegistry()}
\DoxyCodeLine{7371         :   m\_currentSortOrder( RunTests::InDeclarationOrder ),}
\DoxyCodeLine{7372             m\_unnamedCount( 0 )}
\DoxyCodeLine{7373         \{\}}
\DoxyCodeLine{7374         \textcolor{keyword}{virtual} \string~TestRegistry();}
\DoxyCodeLine{7375 }
\DoxyCodeLine{7376         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testCase ) \{}
\DoxyCodeLine{7377             std::string name = testCase.getTestCaseInfo().name;}
\DoxyCodeLine{7378             \textcolor{keywordflow}{if}( name.empty() ) \{}
\DoxyCodeLine{7379                 std::ostringstream oss;}
\DoxyCodeLine{7380                 oss << \textcolor{stringliteral}{"{}Anonymous test case "{}} << ++m\_unnamedCount;}
\DoxyCodeLine{7381                 \textcolor{keywordflow}{return} registerTest( testCase.withName( oss.str() ) );}
\DoxyCodeLine{7382             \}}
\DoxyCodeLine{7383             m\_functions.push\_back( testCase );}
\DoxyCodeLine{7384         \}}
\DoxyCodeLine{7385 }
\DoxyCodeLine{7386         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7387             \textcolor{keywordflow}{return} m\_functions;}
\DoxyCodeLine{7388         \}}
\DoxyCodeLine{7389         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7390             \textcolor{keywordflow}{if}( m\_sortedFunctions.empty() )}
\DoxyCodeLine{7391                 enforceNoDuplicateTestCases( m\_functions );}
\DoxyCodeLine{7392 }
\DoxyCodeLine{7393             \textcolor{keywordflow}{if}(  m\_currentSortOrder != config.runOrder() || m\_sortedFunctions.empty() ) \{}
\DoxyCodeLine{7394                 m\_sortedFunctions = sortTests( config, m\_functions );}
\DoxyCodeLine{7395                 m\_currentSortOrder = config.runOrder();}
\DoxyCodeLine{7396             \}}
\DoxyCodeLine{7397             \textcolor{keywordflow}{return} m\_sortedFunctions;}
\DoxyCodeLine{7398         \}}
\DoxyCodeLine{7399 }
\DoxyCodeLine{7400     \textcolor{keyword}{private}:}
\DoxyCodeLine{7401         std::vector<TestCase> m\_functions;}
\DoxyCodeLine{7402         \textcolor{keyword}{mutable} RunTests::InWhatOrder m\_currentSortOrder;}
\DoxyCodeLine{7403         \textcolor{keyword}{mutable} std::vector<TestCase> m\_sortedFunctions;}
\DoxyCodeLine{7404         \textcolor{keywordtype}{size\_t} m\_unnamedCount;}
\DoxyCodeLine{7405         std::ios\_base::Init m\_ostreamInit; \textcolor{comment}{// Forces cout/ cerr to be initialised}}
\DoxyCodeLine{7406     \};}
\DoxyCodeLine{7407 }
\DoxyCodeLine{7409 }
\DoxyCodeLine{7410     \textcolor{keyword}{class }FreeFunctionTestCase : \textcolor{keyword}{public} SharedImpl<ITestCase> \{}
\DoxyCodeLine{7411     \textcolor{keyword}{public}:}
\DoxyCodeLine{7412 }
\DoxyCodeLine{7413         FreeFunctionTestCase( TestFunction fun ) : m\_fun( fun ) \{\}}
\DoxyCodeLine{7414 }
\DoxyCodeLine{7415         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7416             m\_fun();}
\DoxyCodeLine{7417         \}}
\DoxyCodeLine{7418 }
\DoxyCodeLine{7419     \textcolor{keyword}{private}:}
\DoxyCodeLine{7420         \textcolor{keyword}{virtual} \string~FreeFunctionTestCase();}
\DoxyCodeLine{7421 }
\DoxyCodeLine{7422         TestFunction m\_fun;}
\DoxyCodeLine{7423     \};}
\DoxyCodeLine{7424 }
\DoxyCodeLine{7425     \textcolor{keyword}{inline} std::string extractClassName( std::string \textcolor{keyword}{const}\& classOrQualifiedMethodName ) \{}
\DoxyCodeLine{7426         std::string className = classOrQualifiedMethodName;}
\DoxyCodeLine{7427         \textcolor{keywordflow}{if}( startsWith( className, \textcolor{charliteral}{'\&'} ) )}
\DoxyCodeLine{7428         \{}
\DoxyCodeLine{7429             std::size\_t lastColons = className.rfind( \textcolor{stringliteral}{"{}::"{}} );}
\DoxyCodeLine{7430             std::size\_t penultimateColons = className.rfind( \textcolor{stringliteral}{"{}::"{}}, lastColons-\/1 );}
\DoxyCodeLine{7431             \textcolor{keywordflow}{if}( penultimateColons == std::string::npos )}
\DoxyCodeLine{7432                 penultimateColons = 1;}
\DoxyCodeLine{7433             className = className.substr( penultimateColons, lastColons-\/penultimateColons );}
\DoxyCodeLine{7434         \}}
\DoxyCodeLine{7435         \textcolor{keywordflow}{return} className;}
\DoxyCodeLine{7436     \}}
\DoxyCodeLine{7437 }
\DoxyCodeLine{7438     \textcolor{keywordtype}{void} registerTestCase}
\DoxyCodeLine{7439         (   ITestCase* testCase,}
\DoxyCodeLine{7440             \textcolor{keywordtype}{char} \textcolor{keyword}{const}* classOrQualifiedMethodName,}
\DoxyCodeLine{7441             NameAndDesc \textcolor{keyword}{const}\& nameAndDesc,}
\DoxyCodeLine{7442             SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) \{}
\DoxyCodeLine{7443 }
\DoxyCodeLine{7444         getMutableRegistryHub().registerTest}
\DoxyCodeLine{7445             ( makeTestCase}
\DoxyCodeLine{7446                 (   testCase,}
\DoxyCodeLine{7447                     extractClassName( classOrQualifiedMethodName ),}
\DoxyCodeLine{7448                     nameAndDesc.name,}
\DoxyCodeLine{7449                     nameAndDesc.description,}
\DoxyCodeLine{7450                     lineInfo ) );}
\DoxyCodeLine{7451     \}}
\DoxyCodeLine{7452     \textcolor{keywordtype}{void} registerTestCaseFunction}
\DoxyCodeLine{7453         (   TestFunction function,}
\DoxyCodeLine{7454             SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{7455             NameAndDesc \textcolor{keyword}{const}\& nameAndDesc ) \{}
\DoxyCodeLine{7456         registerTestCase( \textcolor{keyword}{new} FreeFunctionTestCase( function ), \textcolor{stringliteral}{"{}"{}}, nameAndDesc, lineInfo );}
\DoxyCodeLine{7457     \}}
\DoxyCodeLine{7458 }
\DoxyCodeLine{7460 }
\DoxyCodeLine{7461     AutoReg::AutoReg}
\DoxyCodeLine{7462         (   TestFunction function,}
\DoxyCodeLine{7463             SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{7464             NameAndDesc \textcolor{keyword}{const}\& nameAndDesc ) \{}
\DoxyCodeLine{7465         registerTestCaseFunction( function, lineInfo, nameAndDesc );}
\DoxyCodeLine{7466     \}}
\DoxyCodeLine{7467 }
\DoxyCodeLine{7468     AutoReg::\string~AutoReg() \{\}}
\DoxyCodeLine{7469 }
\DoxyCodeLine{7470 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7471 }
\DoxyCodeLine{7472 \textcolor{comment}{// \#included from: catch\_reporter\_registry.hpp}}
\DoxyCodeLine{7473 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REPORTER\_REGISTRY\_HPP\_INCLUDED}}
\DoxyCodeLine{7474 }
\DoxyCodeLine{7475 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{7476 }
\DoxyCodeLine{7477 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7478 }
\DoxyCodeLine{7479     \textcolor{keyword}{class }ReporterRegistry : \textcolor{keyword}{public} IReporterRegistry \{}
\DoxyCodeLine{7480 }
\DoxyCodeLine{7481     \textcolor{keyword}{public}:}
\DoxyCodeLine{7482 }
\DoxyCodeLine{7483         \textcolor{keyword}{virtual} \string~ReporterRegistry() CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{7484 }
\DoxyCodeLine{7485         \textcolor{keyword}{virtual} IStreamingReporter* create( std::string \textcolor{keyword}{const}\& name, Ptr<IConfig const> \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} CATCH\_OVERRIDE \{}
\DoxyCodeLine{7486             FactoryMap::const\_iterator it =  m\_factories.find( name );}
\DoxyCodeLine{7487             \textcolor{keywordflow}{if}( it == m\_factories.end() )}
\DoxyCodeLine{7488                 \textcolor{keywordflow}{return} CATCH\_NULL;}
\DoxyCodeLine{7489             \textcolor{keywordflow}{return} it-\/>second-\/>create( ReporterConfig( config ) );}
\DoxyCodeLine{7490         \}}
\DoxyCodeLine{7491 }
\DoxyCodeLine{7492         \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, Ptr<IReporterFactory> \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{7493             m\_factories.insert( std::make\_pair( name, factory ) );}
\DoxyCodeLine{7494         \}}
\DoxyCodeLine{7495         \textcolor{keywordtype}{void} registerListener( Ptr<IReporterFactory> \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{7496             m\_listeners.push\_back( factory );}
\DoxyCodeLine{7497         \}}
\DoxyCodeLine{7498 }
\DoxyCodeLine{7499         \textcolor{keyword}{virtual} FactoryMap \textcolor{keyword}{const}\& getFactories() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{7500             \textcolor{keywordflow}{return} m\_factories;}
\DoxyCodeLine{7501         \}}
\DoxyCodeLine{7502         \textcolor{keyword}{virtual} Listeners \textcolor{keyword}{const}\& getListeners() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{7503             \textcolor{keywordflow}{return} m\_listeners;}
\DoxyCodeLine{7504         \}}
\DoxyCodeLine{7505 }
\DoxyCodeLine{7506     \textcolor{keyword}{private}:}
\DoxyCodeLine{7507         FactoryMap m\_factories;}
\DoxyCodeLine{7508         Listeners m\_listeners;}
\DoxyCodeLine{7509     \};}
\DoxyCodeLine{7510 \}}
\DoxyCodeLine{7511 }
\DoxyCodeLine{7512 \textcolor{comment}{// \#included from: catch\_exception\_translator\_registry.hpp}}
\DoxyCodeLine{7513 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_EXCEPTION\_TRANSLATOR\_REGISTRY\_HPP\_INCLUDED}}
\DoxyCodeLine{7514 }
\DoxyCodeLine{7515 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{7516 \textcolor{preprocessor}{\#import "{}Foundation/Foundation.h"{}}}
\DoxyCodeLine{7517 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7518 }
\DoxyCodeLine{7519 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7520 }
\DoxyCodeLine{7521     \textcolor{keyword}{class }ExceptionTranslatorRegistry : \textcolor{keyword}{public} IExceptionTranslatorRegistry \{}
\DoxyCodeLine{7522     \textcolor{keyword}{public}:}
\DoxyCodeLine{7523         \string~ExceptionTranslatorRegistry() \{}
\DoxyCodeLine{7524             deleteAll( m\_translators );}
\DoxyCodeLine{7525         \}}
\DoxyCodeLine{7526 }
\DoxyCodeLine{7527         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator ) \{}
\DoxyCodeLine{7528             m\_translators.push\_back( translator );}
\DoxyCodeLine{7529         \}}
\DoxyCodeLine{7530 }
\DoxyCodeLine{7531         \textcolor{keyword}{virtual} std::string translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7532             \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{7533 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{7534                 \textcolor{comment}{// In Objective-\/C try objective-\/c exceptions first}}
\DoxyCodeLine{7535                 \textcolor{keywordflow}{@try} \{}
\DoxyCodeLine{7536                     \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{7537                 \}}
\DoxyCodeLine{7538                 \textcolor{keywordflow}{@catch} (NSException *exception) \{}
\DoxyCodeLine{7539                     \textcolor{keywordflow}{return} Catch::toString( [exception description] );}
\DoxyCodeLine{7540                 \}}
\DoxyCodeLine{7541 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{7542                 \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{7543 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7544             \}}
\DoxyCodeLine{7545             \textcolor{keywordflow}{catch}( TestFailureException\& ) \{}
\DoxyCodeLine{7546                 \textcolor{keywordflow}{throw};}
\DoxyCodeLine{7547             \}}
\DoxyCodeLine{7548             \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{7549                 \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{7550             \}}
\DoxyCodeLine{7551             \textcolor{keywordflow}{catch}( std::string\& msg ) \{}
\DoxyCodeLine{7552                 \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{7553             \}}
\DoxyCodeLine{7554             \textcolor{keywordflow}{catch}( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg ) \{}
\DoxyCodeLine{7555                 \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{7556             \}}
\DoxyCodeLine{7557             \textcolor{keywordflow}{catch}(...) \{}
\DoxyCodeLine{7558                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Unknown exception"{}};}
\DoxyCodeLine{7559             \}}
\DoxyCodeLine{7560         \}}
\DoxyCodeLine{7561 }
\DoxyCodeLine{7562         std::string tryTranslators()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7563             \textcolor{keywordflow}{if}( m\_translators.empty() )}
\DoxyCodeLine{7564                 \textcolor{keywordflow}{throw};}
\DoxyCodeLine{7565             \textcolor{keywordflow}{else}}
\DoxyCodeLine{7566                 \textcolor{keywordflow}{return} m\_translators[0]-\/>translate( m\_translators.begin()+1, m\_translators.end() );}
\DoxyCodeLine{7567         \}}
\DoxyCodeLine{7568 }
\DoxyCodeLine{7569     \textcolor{keyword}{private}:}
\DoxyCodeLine{7570         std::vector<const IExceptionTranslator*> m\_translators;}
\DoxyCodeLine{7571     \};}
\DoxyCodeLine{7572 \}}
\DoxyCodeLine{7573 }
\DoxyCodeLine{7574 \textcolor{comment}{// \#included from: catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{7575 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TAG\_ALIAS\_REGISTRY\_H\_INCLUDED}}
\DoxyCodeLine{7576 }
\DoxyCodeLine{7577 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{7578 }
\DoxyCodeLine{7579 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7580 }
\DoxyCodeLine{7581     \textcolor{keyword}{class }TagAliasRegistry : \textcolor{keyword}{public} ITagAliasRegistry \{}
\DoxyCodeLine{7582     \textcolor{keyword}{public}:}
\DoxyCodeLine{7583         \textcolor{keyword}{virtual} \string~TagAliasRegistry();}
\DoxyCodeLine{7584         \textcolor{keyword}{virtual} Option<TagAlias> find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const};}
\DoxyCodeLine{7585         \textcolor{keyword}{virtual} std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const};}
\DoxyCodeLine{7586         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{7587 }
\DoxyCodeLine{7588     \textcolor{keyword}{private}:}
\DoxyCodeLine{7589         std::map<std::string, TagAlias> m\_registry;}
\DoxyCodeLine{7590     \};}
\DoxyCodeLine{7591 }
\DoxyCodeLine{7592 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7593 }
\DoxyCodeLine{7594 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7595 }
\DoxyCodeLine{7596     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7597 }
\DoxyCodeLine{7598         \textcolor{keyword}{class }RegistryHub : \textcolor{keyword}{public} IRegistryHub, \textcolor{keyword}{public} IMutableRegistryHub \{}
\DoxyCodeLine{7599 }
\DoxyCodeLine{7600             RegistryHub( RegistryHub \textcolor{keyword}{const}\& );}
\DoxyCodeLine{7601             \textcolor{keywordtype}{void} operator=( RegistryHub \textcolor{keyword}{const}\& );}
\DoxyCodeLine{7602 }
\DoxyCodeLine{7603         \textcolor{keyword}{public}: \textcolor{comment}{// IRegistryHub}}
\DoxyCodeLine{7604             RegistryHub() \{}
\DoxyCodeLine{7605             \}}
\DoxyCodeLine{7606             \textcolor{keyword}{virtual} IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{7607                 \textcolor{keywordflow}{return} m\_reporterRegistry;}
\DoxyCodeLine{7608             \}}
\DoxyCodeLine{7609             \textcolor{keyword}{virtual} ITestCaseRegistry \textcolor{keyword}{const}\& getTestCaseRegistry() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{7610                 \textcolor{keywordflow}{return} m\_testCaseRegistry;}
\DoxyCodeLine{7611             \}}
\DoxyCodeLine{7612             \textcolor{keyword}{virtual} IExceptionTranslatorRegistry\& getExceptionTranslatorRegistry() CATCH\_OVERRIDE \{}
\DoxyCodeLine{7613                 \textcolor{keywordflow}{return} m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{7614             \}}
\DoxyCodeLine{7615             \textcolor{keyword}{virtual} ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{7616                 \textcolor{keywordflow}{return} m\_tagAliasRegistry;}
\DoxyCodeLine{7617             \}}
\DoxyCodeLine{7618 }
\DoxyCodeLine{7619         \textcolor{keyword}{public}: \textcolor{comment}{// IMutableRegistryHub}}
\DoxyCodeLine{7620             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, Ptr<IReporterFactory> \textcolor{keyword}{const}\& factory ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{7621                 m\_reporterRegistry.registerReporter( name, factory );}
\DoxyCodeLine{7622             \}}
\DoxyCodeLine{7623             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerListener( Ptr<IReporterFactory> \textcolor{keyword}{const}\& factory ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{7624                 m\_reporterRegistry.registerListener( factory );}
\DoxyCodeLine{7625             \}}
\DoxyCodeLine{7626             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{7627                 m\_testCaseRegistry.registerTest( testInfo );}
\DoxyCodeLine{7628             \}}
\DoxyCodeLine{7629             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{7630                 m\_exceptionTranslatorRegistry.registerTranslator( translator );}
\DoxyCodeLine{7631             \}}
\DoxyCodeLine{7632             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{7633                 m\_tagAliasRegistry.add( alias, tag, lineInfo );}
\DoxyCodeLine{7634             \}}
\DoxyCodeLine{7635 }
\DoxyCodeLine{7636         \textcolor{keyword}{private}:}
\DoxyCodeLine{7637             TestRegistry m\_testCaseRegistry;}
\DoxyCodeLine{7638             ReporterRegistry m\_reporterRegistry;}
\DoxyCodeLine{7639             ExceptionTranslatorRegistry m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{7640             TagAliasRegistry m\_tagAliasRegistry;}
\DoxyCodeLine{7641         \};}
\DoxyCodeLine{7642 }
\DoxyCodeLine{7643         \textcolor{comment}{// Single, global, instance}}
\DoxyCodeLine{7644         \textcolor{keyword}{inline} RegistryHub*\& getTheRegistryHub() \{}
\DoxyCodeLine{7645             \textcolor{keyword}{static} RegistryHub* theRegistryHub = CATCH\_NULL;}
\DoxyCodeLine{7646             \textcolor{keywordflow}{if}( !theRegistryHub )}
\DoxyCodeLine{7647                 theRegistryHub = \textcolor{keyword}{new} RegistryHub();}
\DoxyCodeLine{7648             \textcolor{keywordflow}{return} theRegistryHub;}
\DoxyCodeLine{7649         \}}
\DoxyCodeLine{7650     \}}
\DoxyCodeLine{7651 }
\DoxyCodeLine{7652     IRegistryHub\& getRegistryHub() \{}
\DoxyCodeLine{7653         \textcolor{keywordflow}{return} *getTheRegistryHub();}
\DoxyCodeLine{7654     \}}
\DoxyCodeLine{7655     IMutableRegistryHub\& getMutableRegistryHub() \{}
\DoxyCodeLine{7656         \textcolor{keywordflow}{return} *getTheRegistryHub();}
\DoxyCodeLine{7657     \}}
\DoxyCodeLine{7658     \textcolor{keywordtype}{void} cleanUp() \{}
\DoxyCodeLine{7659         \textcolor{keyword}{delete} getTheRegistryHub();}
\DoxyCodeLine{7660         getTheRegistryHub() = CATCH\_NULL;}
\DoxyCodeLine{7661         cleanUpContext();}
\DoxyCodeLine{7662     \}}
\DoxyCodeLine{7663     std::string translateActiveException() \{}
\DoxyCodeLine{7664         \textcolor{keywordflow}{return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();}
\DoxyCodeLine{7665     \}}
\DoxyCodeLine{7666 }
\DoxyCodeLine{7667 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7668 }
\DoxyCodeLine{7669 \textcolor{comment}{// \#included from: catch\_notimplemented\_exception.hpp}}
\DoxyCodeLine{7670 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_NOTIMPLEMENTED\_EXCEPTION\_HPP\_INCLUDED}}
\DoxyCodeLine{7671 }
\DoxyCodeLine{7672 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{7673 }
\DoxyCodeLine{7674 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7675 }
\DoxyCodeLine{7676     NotImplementedException::NotImplementedException( SourceLineInfo \textcolor{keyword}{const}\& lineInfo )}
\DoxyCodeLine{7677     :   m\_lineInfo( lineInfo ) \{}
\DoxyCodeLine{7678         std::ostringstream oss;}
\DoxyCodeLine{7679         oss << lineInfo << \textcolor{stringliteral}{"{}: function "{}};}
\DoxyCodeLine{7680         oss << \textcolor{stringliteral}{"{}not implemented"{}};}
\DoxyCodeLine{7681         m\_what = oss.str();}
\DoxyCodeLine{7682     \}}
\DoxyCodeLine{7683 }
\DoxyCodeLine{7684     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NotImplementedException::what() const CATCH\_NOEXCEPT \{}
\DoxyCodeLine{7685         \textcolor{keywordflow}{return} m\_what.c\_str();}
\DoxyCodeLine{7686     \}}
\DoxyCodeLine{7687 }
\DoxyCodeLine{7688 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7689 }
\DoxyCodeLine{7690 \textcolor{comment}{// \#included from: catch\_context\_impl.hpp}}
\DoxyCodeLine{7691 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_CONTEXT\_IMPL\_HPP\_INCLUDED}}
\DoxyCodeLine{7692 }
\DoxyCodeLine{7693 \textcolor{comment}{// \#included from: catch\_stream.hpp}}
\DoxyCodeLine{7694 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_STREAM\_HPP\_INCLUDED}}
\DoxyCodeLine{7695 }
\DoxyCodeLine{7696 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{7697 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{7698 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{7699 }
\DoxyCodeLine{7700 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7701 }
\DoxyCodeLine{7702     \textcolor{keyword}{template}<\textcolor{keyword}{typename} WriterF, \textcolor{keywordtype}{size\_t} bufferSize=256>}
\DoxyCodeLine{7703     \textcolor{keyword}{class }StreamBufImpl : \textcolor{keyword}{public} StreamBufBase \{}
\DoxyCodeLine{7704         \textcolor{keywordtype}{char} data[bufferSize];}
\DoxyCodeLine{7705         WriterF m\_writer;}
\DoxyCodeLine{7706 }
\DoxyCodeLine{7707     \textcolor{keyword}{public}:}
\DoxyCodeLine{7708         StreamBufImpl() \{}
\DoxyCodeLine{7709             setp( data, data + \textcolor{keyword}{sizeof}(data) );}
\DoxyCodeLine{7710         \}}
\DoxyCodeLine{7711 }
\DoxyCodeLine{7712         \string~StreamBufImpl() CATCH\_NOEXCEPT \{}
\DoxyCodeLine{7713             sync();}
\DoxyCodeLine{7714         \}}
\DoxyCodeLine{7715 }
\DoxyCodeLine{7716     \textcolor{keyword}{private}:}
\DoxyCodeLine{7717         \textcolor{keywordtype}{int} overflow( \textcolor{keywordtype}{int} c ) \{}
\DoxyCodeLine{7718             sync();}
\DoxyCodeLine{7719 }
\DoxyCodeLine{7720             \textcolor{keywordflow}{if}( c != EOF ) \{}
\DoxyCodeLine{7721                 \textcolor{keywordflow}{if}( pbase() == epptr() )}
\DoxyCodeLine{7722                     m\_writer( std::string( 1, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( c ) ) );}
\DoxyCodeLine{7723                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{7724                     sputc( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( c ) );}
\DoxyCodeLine{7725             \}}
\DoxyCodeLine{7726             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7727         \}}
\DoxyCodeLine{7728 }
\DoxyCodeLine{7729         \textcolor{keywordtype}{int} sync() \{}
\DoxyCodeLine{7730             \textcolor{keywordflow}{if}( pbase() != pptr() ) \{}
\DoxyCodeLine{7731                 m\_writer( std::string( pbase(), \textcolor{keyword}{static\_cast<}std::string::size\_type\textcolor{keyword}{>}( pptr() -\/ pbase() ) ) );}
\DoxyCodeLine{7732                 setp( pbase(), epptr() );}
\DoxyCodeLine{7733             \}}
\DoxyCodeLine{7734             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7735         \}}
\DoxyCodeLine{7736     \};}
\DoxyCodeLine{7737 }
\DoxyCodeLine{7739 }
\DoxyCodeLine{7740     FileStream::FileStream( std::string \textcolor{keyword}{const}\& filename ) \{}
\DoxyCodeLine{7741         m\_ofs.open( filename.c\_str() );}
\DoxyCodeLine{7742         \textcolor{keywordflow}{if}( m\_ofs.fail() ) \{}
\DoxyCodeLine{7743             std::ostringstream oss;}
\DoxyCodeLine{7744             oss << \textcolor{stringliteral}{"{}Unable to open file: '"{}} << filename << \textcolor{charliteral}{'\(\backslash\)''};}
\DoxyCodeLine{7745             \textcolor{keywordflow}{throw} std::domain\_error( oss.str() );}
\DoxyCodeLine{7746         \}}
\DoxyCodeLine{7747     \}}
\DoxyCodeLine{7748 }
\DoxyCodeLine{7749     std::ostream\& FileStream::stream()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7750         \textcolor{keywordflow}{return} m\_ofs;}
\DoxyCodeLine{7751     \}}
\DoxyCodeLine{7752 }
\DoxyCodeLine{7753     \textcolor{keyword}{struct }OutputDebugWriter \{}
\DoxyCodeLine{7754 }
\DoxyCodeLine{7755         \textcolor{keywordtype}{void} operator()( std::string \textcolor{keyword}{const}\&str ) \{}
\DoxyCodeLine{7756             writeToDebugConsole( str );}
\DoxyCodeLine{7757         \}}
\DoxyCodeLine{7758     \};}
\DoxyCodeLine{7759 }
\DoxyCodeLine{7760     DebugOutStream::DebugOutStream()}
\DoxyCodeLine{7761     :   m\_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),}
\DoxyCodeLine{7762         m\_os( m\_streamBuf.get() )}
\DoxyCodeLine{7763     \{\}}
\DoxyCodeLine{7764 }
\DoxyCodeLine{7765     std::ostream\& DebugOutStream::stream()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7766         \textcolor{keywordflow}{return} m\_os;}
\DoxyCodeLine{7767     \}}
\DoxyCodeLine{7768 }
\DoxyCodeLine{7769     \textcolor{comment}{// Store the streambuf from cout up-\/front because}}
\DoxyCodeLine{7770     \textcolor{comment}{// cout may get redirected when running tests}}
\DoxyCodeLine{7771     CoutStream::CoutStream()}
\DoxyCodeLine{7772     :   m\_os( Catch::cout().rdbuf() )}
\DoxyCodeLine{7773     \{\}}
\DoxyCodeLine{7774 }
\DoxyCodeLine{7775     std::ostream\& CoutStream::stream()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7776         \textcolor{keywordflow}{return} m\_os;}
\DoxyCodeLine{7777     \}}
\DoxyCodeLine{7778 }
\DoxyCodeLine{7779 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_NOSTDOUT }\textcolor{comment}{// If you \#define this you must implement these functions}}
\DoxyCodeLine{7780     std::ostream\& cout() \{}
\DoxyCodeLine{7781         \textcolor{keywordflow}{return} std::cout;}
\DoxyCodeLine{7782     \}}
\DoxyCodeLine{7783     std::ostream\& cerr() \{}
\DoxyCodeLine{7784         \textcolor{keywordflow}{return} std::cerr;}
\DoxyCodeLine{7785     \}}
\DoxyCodeLine{7786     std::ostream\& clog() \{}
\DoxyCodeLine{7787         \textcolor{keywordflow}{return} std::clog;}
\DoxyCodeLine{7788     \}}
\DoxyCodeLine{7789 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7790 \}}
\DoxyCodeLine{7791 }
\DoxyCodeLine{7792 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7793 }
\DoxyCodeLine{7794     \textcolor{keyword}{class }Context : \textcolor{keyword}{public} IMutableContext \{}
\DoxyCodeLine{7795 }
\DoxyCodeLine{7796         Context() : m\_config( CATCH\_NULL ), m\_runner( CATCH\_NULL ), m\_resultCapture( CATCH\_NULL ) \{\}}
\DoxyCodeLine{7797         Context( Context \textcolor{keyword}{const}\& );}
\DoxyCodeLine{7798         \textcolor{keywordtype}{void} operator=( Context \textcolor{keyword}{const}\& );}
\DoxyCodeLine{7799 }
\DoxyCodeLine{7800     \textcolor{keyword}{public}:}
\DoxyCodeLine{7801         \textcolor{keyword}{virtual} \string~Context() \{}
\DoxyCodeLine{7802             deleteAllValues( m\_generatorsByTestName );}
\DoxyCodeLine{7803         \}}
\DoxyCodeLine{7804 }
\DoxyCodeLine{7805     \textcolor{keyword}{public}: \textcolor{comment}{// IContext}}
\DoxyCodeLine{7806         \textcolor{keyword}{virtual} IResultCapture* getResultCapture() \{}
\DoxyCodeLine{7807             \textcolor{keywordflow}{return} m\_resultCapture;}
\DoxyCodeLine{7808         \}}
\DoxyCodeLine{7809         \textcolor{keyword}{virtual} IRunner* getRunner() \{}
\DoxyCodeLine{7810             \textcolor{keywordflow}{return} m\_runner;}
\DoxyCodeLine{7811         \}}
\DoxyCodeLine{7812         \textcolor{keyword}{virtual} \textcolor{keywordtype}{size\_t} getGeneratorIndex( std::string \textcolor{keyword}{const}\& fileInfo, \textcolor{keywordtype}{size\_t} totalSize ) \{}
\DoxyCodeLine{7813             \textcolor{keywordflow}{return} getGeneratorsForCurrentTest()}
\DoxyCodeLine{7814             .getGeneratorInfo( fileInfo, totalSize )}
\DoxyCodeLine{7815             .getCurrentIndex();}
\DoxyCodeLine{7816         \}}
\DoxyCodeLine{7817         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} advanceGeneratorsForCurrentTest() \{}
\DoxyCodeLine{7818             IGeneratorsForTest* generators = findGeneratorsForCurrentTest();}
\DoxyCodeLine{7819             \textcolor{keywordflow}{return} generators \&\& generators-\/>moveNext();}
\DoxyCodeLine{7820         \}}
\DoxyCodeLine{7821 }
\DoxyCodeLine{7822         \textcolor{keyword}{virtual} Ptr<IConfig const> getConfig()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7823             \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{7824         \}}
\DoxyCodeLine{7825 }
\DoxyCodeLine{7826     \textcolor{keyword}{public}: \textcolor{comment}{// IMutableContext}}
\DoxyCodeLine{7827         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setResultCapture( IResultCapture* resultCapture ) \{}
\DoxyCodeLine{7828             m\_resultCapture = resultCapture;}
\DoxyCodeLine{7829         \}}
\DoxyCodeLine{7830         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setRunner( IRunner* runner ) \{}
\DoxyCodeLine{7831             m\_runner = runner;}
\DoxyCodeLine{7832         \}}
\DoxyCodeLine{7833         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setConfig( Ptr<IConfig const> \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{7834             m\_config = config;}
\DoxyCodeLine{7835         \}}
\DoxyCodeLine{7836 }
\DoxyCodeLine{7837         \textcolor{keyword}{friend} IMutableContext\& getCurrentMutableContext();}
\DoxyCodeLine{7838 }
\DoxyCodeLine{7839     \textcolor{keyword}{private}:}
\DoxyCodeLine{7840         IGeneratorsForTest* findGeneratorsForCurrentTest() \{}
\DoxyCodeLine{7841             std::string testName = getResultCapture()-\/>getCurrentTestName();}
\DoxyCodeLine{7842 }
\DoxyCodeLine{7843             std::map<std::string, IGeneratorsForTest*>::const\_iterator it =}
\DoxyCodeLine{7844                 m\_generatorsByTestName.find( testName );}
\DoxyCodeLine{7845             \textcolor{keywordflow}{return} it != m\_generatorsByTestName.end()}
\DoxyCodeLine{7846                 ? it-\/>second}
\DoxyCodeLine{7847                 : CATCH\_NULL;}
\DoxyCodeLine{7848         \}}
\DoxyCodeLine{7849 }
\DoxyCodeLine{7850         IGeneratorsForTest\& getGeneratorsForCurrentTest() \{}
\DoxyCodeLine{7851             IGeneratorsForTest* generators = findGeneratorsForCurrentTest();}
\DoxyCodeLine{7852             \textcolor{keywordflow}{if}( !generators ) \{}
\DoxyCodeLine{7853                 std::string testName = getResultCapture()-\/>getCurrentTestName();}
\DoxyCodeLine{7854                 generators = createGeneratorsForTest();}
\DoxyCodeLine{7855                 m\_generatorsByTestName.insert( std::make\_pair( testName, generators ) );}
\DoxyCodeLine{7856             \}}
\DoxyCodeLine{7857             \textcolor{keywordflow}{return} *generators;}
\DoxyCodeLine{7858         \}}
\DoxyCodeLine{7859 }
\DoxyCodeLine{7860     \textcolor{keyword}{private}:}
\DoxyCodeLine{7861         Ptr<IConfig const> m\_config;}
\DoxyCodeLine{7862         IRunner* m\_runner;}
\DoxyCodeLine{7863         IResultCapture* m\_resultCapture;}
\DoxyCodeLine{7864         std::map<std::string, IGeneratorsForTest*> m\_generatorsByTestName;}
\DoxyCodeLine{7865     \};}
\DoxyCodeLine{7866 }
\DoxyCodeLine{7867     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7868         Context* currentContext = CATCH\_NULL;}
\DoxyCodeLine{7869     \}}
\DoxyCodeLine{7870     IMutableContext\& getCurrentMutableContext() \{}
\DoxyCodeLine{7871         \textcolor{keywordflow}{if}( !currentContext )}
\DoxyCodeLine{7872             currentContext = \textcolor{keyword}{new} Context();}
\DoxyCodeLine{7873         \textcolor{keywordflow}{return} *currentContext;}
\DoxyCodeLine{7874     \}}
\DoxyCodeLine{7875     IContext\& getCurrentContext() \{}
\DoxyCodeLine{7876         \textcolor{keywordflow}{return} getCurrentMutableContext();}
\DoxyCodeLine{7877     \}}
\DoxyCodeLine{7878 }
\DoxyCodeLine{7879     \textcolor{keywordtype}{void} cleanUpContext() \{}
\DoxyCodeLine{7880         \textcolor{keyword}{delete} currentContext;}
\DoxyCodeLine{7881         currentContext = CATCH\_NULL;}
\DoxyCodeLine{7882     \}}
\DoxyCodeLine{7883 \}}
\DoxyCodeLine{7884 }
\DoxyCodeLine{7885 \textcolor{comment}{// \#included from: catch\_console\_colour\_impl.hpp}}
\DoxyCodeLine{7886 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_CONSOLE\_COLOUR\_IMPL\_HPP\_INCLUDED}}
\DoxyCodeLine{7887 }
\DoxyCodeLine{7888 \textcolor{comment}{// \#included from: catch\_errno\_guard.hpp}}
\DoxyCodeLine{7889 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_ERRNO\_GUARD\_HPP\_INCLUDED}}
\DoxyCodeLine{7890 }
\DoxyCodeLine{7891 \textcolor{preprocessor}{\#include <cerrno>}}
\DoxyCodeLine{7892 }
\DoxyCodeLine{7893 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7894 }
\DoxyCodeLine{7895     \textcolor{keyword}{class }ErrnoGuard \{}
\DoxyCodeLine{7896     \textcolor{keyword}{public}:}
\DoxyCodeLine{7897         ErrnoGuard():m\_oldErrno(errno)\{\}}
\DoxyCodeLine{7898         \string~ErrnoGuard() \{ errno = m\_oldErrno; \}}
\DoxyCodeLine{7899     \textcolor{keyword}{private}:}
\DoxyCodeLine{7900         \textcolor{keywordtype}{int} m\_oldErrno;}
\DoxyCodeLine{7901     \};}
\DoxyCodeLine{7902 }
\DoxyCodeLine{7903 \}}
\DoxyCodeLine{7904 }
\DoxyCodeLine{7905 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7906     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7907 }
\DoxyCodeLine{7908         \textcolor{keyword}{struct }IColourImpl \{}
\DoxyCodeLine{7909             \textcolor{keyword}{virtual} \string~IColourImpl() \{\}}
\DoxyCodeLine{7910             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode ) = 0;}
\DoxyCodeLine{7911         \};}
\DoxyCodeLine{7912 }
\DoxyCodeLine{7913         \textcolor{keyword}{struct }NoColourImpl : IColourImpl \{}
\DoxyCodeLine{7914             \textcolor{keywordtype}{void} use( Colour::Code ) \{\}}
\DoxyCodeLine{7915 }
\DoxyCodeLine{7916             \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{7917                 \textcolor{keyword}{static} NoColourImpl s\_instance;}
\DoxyCodeLine{7918                 \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{7919             \}}
\DoxyCodeLine{7920         \};}
\DoxyCodeLine{7921 }
\DoxyCodeLine{7922     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{7923 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7924 }
\DoxyCodeLine{7925 \textcolor{preprocessor}{\#if !defined( CATCH\_CONFIG\_COLOUR\_NONE ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_WINDOWS ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_ANSI )}}
\DoxyCodeLine{7926 \textcolor{preprocessor}{\#   ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{7927 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_WINDOWS}}
\DoxyCodeLine{7928 \textcolor{preprocessor}{\#   else}}
\DoxyCodeLine{7929 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_ANSI}}
\DoxyCodeLine{7930 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{7931 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7932 }
\DoxyCodeLine{7933 \textcolor{preprocessor}{\#if defined ( CATCH\_CONFIG\_COLOUR\_WINDOWS ) }}
\DoxyCodeLine{7934 }
\DoxyCodeLine{7935 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7936 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7937 }
\DoxyCodeLine{7938     \textcolor{keyword}{class }Win32ColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{7939     \textcolor{keyword}{public}:}
\DoxyCodeLine{7940         Win32ColourImpl() : stdoutHandle( GetStdHandle(STD\_OUTPUT\_HANDLE) )}
\DoxyCodeLine{7941         \{}
\DoxyCodeLine{7942             CONSOLE\_SCREEN\_BUFFER\_INFO csbiInfo;}
\DoxyCodeLine{7943             GetConsoleScreenBufferInfo( stdoutHandle, \&csbiInfo );}
\DoxyCodeLine{7944             originalForegroundAttributes = csbiInfo.wAttributes \& \string~( BACKGROUND\_GREEN | BACKGROUND\_RED | BACKGROUND\_BLUE | BACKGROUND\_INTENSITY );}
\DoxyCodeLine{7945             originalBackgroundAttributes = csbiInfo.wAttributes \& \string~( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE | FOREGROUND\_INTENSITY );}
\DoxyCodeLine{7946         \}}
\DoxyCodeLine{7947 }
\DoxyCodeLine{7948         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode ) \{}
\DoxyCodeLine{7949             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{7950                 \textcolor{keywordflow}{case} Colour::None:      \textcolor{keywordflow}{return} setTextAttribute( originalForegroundAttributes );}
\DoxyCodeLine{7951                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{7952                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED );}
\DoxyCodeLine{7953                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN );}
\DoxyCodeLine{7954                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE );}
\DoxyCodeLine{7955                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE | FOREGROUND\_GREEN );}
\DoxyCodeLine{7956                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{7957                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setTextAttribute( 0 );}
\DoxyCodeLine{7958 }
\DoxyCodeLine{7959                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY );}
\DoxyCodeLine{7960                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED );}
\DoxyCodeLine{7961                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN );}
\DoxyCodeLine{7962                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{7963 }
\DoxyCodeLine{7964                 \textcolor{keywordflow}{case} Colour::Bright: \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}not a colour"{}} );}
\DoxyCodeLine{7965             \}}
\DoxyCodeLine{7966         \}}
\DoxyCodeLine{7967 }
\DoxyCodeLine{7968     \textcolor{keyword}{private}:}
\DoxyCodeLine{7969         \textcolor{keywordtype}{void} setTextAttribute( WORD \_textAttribute ) \{}
\DoxyCodeLine{7970             SetConsoleTextAttribute( stdoutHandle, \_textAttribute | originalBackgroundAttributes );}
\DoxyCodeLine{7971         \}}
\DoxyCodeLine{7972         HANDLE stdoutHandle;}
\DoxyCodeLine{7973         WORD originalForegroundAttributes;}
\DoxyCodeLine{7974         WORD originalBackgroundAttributes;}
\DoxyCodeLine{7975     \};}
\DoxyCodeLine{7976 }
\DoxyCodeLine{7977     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{7978         \textcolor{keyword}{static} Win32ColourImpl s\_instance;}
\DoxyCodeLine{7979 }
\DoxyCodeLine{7980         Ptr<IConfig const> config = getCurrentContext().getConfig();}
\DoxyCodeLine{7981         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{7982             ? config-\/>useColour()}
\DoxyCodeLine{7983             : UseColour::Auto;}
\DoxyCodeLine{7984         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{7985             colourMode = !isDebuggerActive()}
\DoxyCodeLine{7986                 ? UseColour::Yes}
\DoxyCodeLine{7987                 : UseColour::No;}
\DoxyCodeLine{7988         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{7989             ? \&s\_instance}
\DoxyCodeLine{7990             : NoColourImpl::instance();}
\DoxyCodeLine{7991     \}}
\DoxyCodeLine{7992 }
\DoxyCodeLine{7993 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{7994 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7995 }
\DoxyCodeLine{7996 \textcolor{preprocessor}{\#elif defined( CATCH\_CONFIG\_COLOUR\_ANSI ) }}
\DoxyCodeLine{7997 }
\DoxyCodeLine{7998 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{7999 }
\DoxyCodeLine{8000 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8001 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{8002 }
\DoxyCodeLine{8003     \textcolor{comment}{// use POSIX/ ANSI console terminal codes}}
\DoxyCodeLine{8004     \textcolor{comment}{// Thanks to Adam Strzelecki for original contribution}}
\DoxyCodeLine{8005     \textcolor{comment}{// (http://github.com/nanoant)}}
\DoxyCodeLine{8006     \textcolor{comment}{// https://github.com/philsquared/Catch/pull/131}}
\DoxyCodeLine{8007     \textcolor{keyword}{class }PosixColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{8008     \textcolor{keyword}{public}:}
\DoxyCodeLine{8009         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode ) \{}
\DoxyCodeLine{8010             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{8011                 \textcolor{keywordflow}{case} Colour::None:}
\DoxyCodeLine{8012                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0m"{}} );}
\DoxyCodeLine{8013                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;31m"{}} );}
\DoxyCodeLine{8014                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;32m"{}} );}
\DoxyCodeLine{8015                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;34m"{}} );}
\DoxyCodeLine{8016                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;36m"{}} );}
\DoxyCodeLine{8017                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;33m"{}} );}
\DoxyCodeLine{8018                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;30m"{}} );}
\DoxyCodeLine{8019 }
\DoxyCodeLine{8020                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;37m"{}} );}
\DoxyCodeLine{8021                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;31m"{}} );}
\DoxyCodeLine{8022                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;32m"{}} );}
\DoxyCodeLine{8023                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;37m"{}} );}
\DoxyCodeLine{8024 }
\DoxyCodeLine{8025                 \textcolor{keywordflow}{case} Colour::Bright: \textcolor{keywordflow}{throw} std::logic\_error( \textcolor{stringliteral}{"{}not a colour"{}} );}
\DoxyCodeLine{8026             \}}
\DoxyCodeLine{8027         \}}
\DoxyCodeLine{8028         \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{8029             \textcolor{keyword}{static} PosixColourImpl s\_instance;}
\DoxyCodeLine{8030             \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{8031         \}}
\DoxyCodeLine{8032 }
\DoxyCodeLine{8033     \textcolor{keyword}{private}:}
\DoxyCodeLine{8034         \textcolor{keywordtype}{void} setColour( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \_escapeCode ) \{}
\DoxyCodeLine{8035             Catch::cout() << \textcolor{charliteral}{'\(\backslash\)033'} << \_escapeCode;}
\DoxyCodeLine{8036         \}}
\DoxyCodeLine{8037     \};}
\DoxyCodeLine{8038 }
\DoxyCodeLine{8039     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{8040         ErrnoGuard guard;}
\DoxyCodeLine{8041         Ptr<IConfig const> config = getCurrentContext().getConfig();}
\DoxyCodeLine{8042         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{8043             ? config-\/>useColour()}
\DoxyCodeLine{8044             : UseColour::Auto;}
\DoxyCodeLine{8045         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{8046             colourMode = (!isDebuggerActive() \&\& isatty(STDOUT\_FILENO) )}
\DoxyCodeLine{8047                 ? UseColour::Yes}
\DoxyCodeLine{8048                 : UseColour::No;}
\DoxyCodeLine{8049         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{8050             ? PosixColourImpl::instance()}
\DoxyCodeLine{8051             : NoColourImpl::instance();}
\DoxyCodeLine{8052     \}}
\DoxyCodeLine{8053 }
\DoxyCodeLine{8054 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{8055 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8056 }
\DoxyCodeLine{8057 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// not Windows or ANSI ///////////////////////////////////////////////}}
\DoxyCodeLine{8058 }
\DoxyCodeLine{8059 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8060 }
\DoxyCodeLine{8061     \textcolor{keyword}{static} IColourImpl* platformColourInstance() \{ \textcolor{keywordflow}{return} NoColourImpl::instance(); \}}
\DoxyCodeLine{8062 }
\DoxyCodeLine{8063 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8064 }
\DoxyCodeLine{8065 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Windows/ ANSI/ None}}
\DoxyCodeLine{8066 }
\DoxyCodeLine{8067 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8068 }
\DoxyCodeLine{8069     Colour::Colour( Code \_colourCode ) : m\_moved( false ) \{ use( \_colourCode ); \}}
\DoxyCodeLine{8070     Colour::Colour( Colour \textcolor{keyword}{const}\& \_other ) : m\_moved( false ) \{ \textcolor{keyword}{const\_cast<}Colour\&\textcolor{keyword}{>}( \_other ).m\_moved = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{8071     Colour::\string~Colour()\{ \textcolor{keywordflow}{if}( !m\_moved ) use( None ); \}}
\DoxyCodeLine{8072 }
\DoxyCodeLine{8073     \textcolor{keywordtype}{void} Colour::use( Code \_colourCode ) \{}
\DoxyCodeLine{8074         \textcolor{keyword}{static} IColourImpl* impl = platformColourInstance();}
\DoxyCodeLine{8075         impl-\/>use( \_colourCode );}
\DoxyCodeLine{8076     \}}
\DoxyCodeLine{8077 }
\DoxyCodeLine{8078 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8079 }
\DoxyCodeLine{8080 \textcolor{comment}{// \#included from: catch\_generators\_impl.hpp}}
\DoxyCodeLine{8081 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_GENERATORS\_IMPL\_HPP\_INCLUDED}}
\DoxyCodeLine{8082 }
\DoxyCodeLine{8083 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{8084 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{8085 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{8086 }
\DoxyCodeLine{8087 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8088 }
\DoxyCodeLine{8089     \textcolor{keyword}{struct }GeneratorInfo : IGeneratorInfo \{}
\DoxyCodeLine{8090 }
\DoxyCodeLine{8091         GeneratorInfo( std::size\_t size )}
\DoxyCodeLine{8092         :   m\_size( size ),}
\DoxyCodeLine{8093             m\_currentIndex( 0 )}
\DoxyCodeLine{8094         \{\}}
\DoxyCodeLine{8095 }
\DoxyCodeLine{8096         \textcolor{keywordtype}{bool} moveNext() \{}
\DoxyCodeLine{8097             \textcolor{keywordflow}{if}( ++m\_currentIndex == m\_size ) \{}
\DoxyCodeLine{8098                 m\_currentIndex = 0;}
\DoxyCodeLine{8099                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{8100             \}}
\DoxyCodeLine{8101             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{8102         \}}
\DoxyCodeLine{8103 }
\DoxyCodeLine{8104         std::size\_t getCurrentIndex()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8105             \textcolor{keywordflow}{return} m\_currentIndex;}
\DoxyCodeLine{8106         \}}
\DoxyCodeLine{8107 }
\DoxyCodeLine{8108         std::size\_t m\_size;}
\DoxyCodeLine{8109         std::size\_t m\_currentIndex;}
\DoxyCodeLine{8110     \};}
\DoxyCodeLine{8111 }
\DoxyCodeLine{8113 }
\DoxyCodeLine{8114     \textcolor{keyword}{class }GeneratorsForTest : \textcolor{keyword}{public} IGeneratorsForTest \{}
\DoxyCodeLine{8115 }
\DoxyCodeLine{8116     \textcolor{keyword}{public}:}
\DoxyCodeLine{8117         \string~GeneratorsForTest() \{}
\DoxyCodeLine{8118             deleteAll( m\_generatorsInOrder );}
\DoxyCodeLine{8119         \}}
\DoxyCodeLine{8120 }
\DoxyCodeLine{8121         IGeneratorInfo\& getGeneratorInfo( std::string \textcolor{keyword}{const}\& fileInfo, std::size\_t size ) \{}
\DoxyCodeLine{8122             std::map<std::string, IGeneratorInfo*>::const\_iterator it = m\_generatorsByName.find( fileInfo );}
\DoxyCodeLine{8123             \textcolor{keywordflow}{if}( it == m\_generatorsByName.end() ) \{}
\DoxyCodeLine{8124                 IGeneratorInfo* info = \textcolor{keyword}{new} GeneratorInfo( size );}
\DoxyCodeLine{8125                 m\_generatorsByName.insert( std::make\_pair( fileInfo, info ) );}
\DoxyCodeLine{8126                 m\_generatorsInOrder.push\_back( info );}
\DoxyCodeLine{8127                 \textcolor{keywordflow}{return} *info;}
\DoxyCodeLine{8128             \}}
\DoxyCodeLine{8129             \textcolor{keywordflow}{return} *it-\/>second;}
\DoxyCodeLine{8130         \}}
\DoxyCodeLine{8131 }
\DoxyCodeLine{8132         \textcolor{keywordtype}{bool} moveNext() \{}
\DoxyCodeLine{8133             std::vector<IGeneratorInfo*>::const\_iterator it = m\_generatorsInOrder.begin();}
\DoxyCodeLine{8134             std::vector<IGeneratorInfo*>::const\_iterator itEnd = m\_generatorsInOrder.end();}
\DoxyCodeLine{8135             \textcolor{keywordflow}{for}(; it != itEnd; ++it ) \{}
\DoxyCodeLine{8136                 \textcolor{keywordflow}{if}( (*it)-\/>moveNext() )}
\DoxyCodeLine{8137                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{8138             \}}
\DoxyCodeLine{8139             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{8140         \}}
\DoxyCodeLine{8141 }
\DoxyCodeLine{8142     \textcolor{keyword}{private}:}
\DoxyCodeLine{8143         std::map<std::string, IGeneratorInfo*> m\_generatorsByName;}
\DoxyCodeLine{8144         std::vector<IGeneratorInfo*> m\_generatorsInOrder;}
\DoxyCodeLine{8145     \};}
\DoxyCodeLine{8146 }
\DoxyCodeLine{8147     IGeneratorsForTest* createGeneratorsForTest()}
\DoxyCodeLine{8148     \{}
\DoxyCodeLine{8149         \textcolor{keywordflow}{return} \textcolor{keyword}{new} GeneratorsForTest();}
\DoxyCodeLine{8150     \}}
\DoxyCodeLine{8151 }
\DoxyCodeLine{8152 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8153 }
\DoxyCodeLine{8154 \textcolor{comment}{// \#included from: catch\_assertionresult.hpp}}
\DoxyCodeLine{8155 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_ASSERTIONRESULT\_HPP\_INCLUDED}}
\DoxyCodeLine{8156 }
\DoxyCodeLine{8157 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8158 }
\DoxyCodeLine{8159     AssertionInfo::AssertionInfo():macroName(\textcolor{stringliteral}{"{}"{}}), capturedExpression(\textcolor{stringliteral}{"{}"{}}), resultDisposition(ResultDisposition::Normal), secondArg(\textcolor{stringliteral}{"{}"{}})\{\}}
\DoxyCodeLine{8160 }
\DoxyCodeLine{8161     AssertionInfo::AssertionInfo(   \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \_macroName,}
\DoxyCodeLine{8162                                     SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{8163                                     \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \_capturedExpression,}
\DoxyCodeLine{8164                                     ResultDisposition::Flags \_resultDisposition,}
\DoxyCodeLine{8165                                     \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \_secondArg)}
\DoxyCodeLine{8166     :   macroName( \_macroName ),}
\DoxyCodeLine{8167         lineInfo( \_lineInfo ),}
\DoxyCodeLine{8168         capturedExpression( \_capturedExpression ),}
\DoxyCodeLine{8169         resultDisposition( \_resultDisposition ),}
\DoxyCodeLine{8170         secondArg( \_secondArg )}
\DoxyCodeLine{8171     \{\}}
\DoxyCodeLine{8172 }
\DoxyCodeLine{8173     AssertionResult::AssertionResult() \{\}}
\DoxyCodeLine{8174 }
\DoxyCodeLine{8175     AssertionResult::AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{8176     :   m\_info( info ),}
\DoxyCodeLine{8177         m\_resultData( data )}
\DoxyCodeLine{8178     \{\}}
\DoxyCodeLine{8179 }
\DoxyCodeLine{8180     AssertionResult::\string~AssertionResult() \{\}}
\DoxyCodeLine{8181 }
\DoxyCodeLine{8182     \textcolor{comment}{// Result was a success}}
\DoxyCodeLine{8183     \textcolor{keywordtype}{bool} AssertionResult::succeeded()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8184         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType );}
\DoxyCodeLine{8185     \}}
\DoxyCodeLine{8186 }
\DoxyCodeLine{8187     \textcolor{comment}{// Result was a success, or failure is suppressed}}
\DoxyCodeLine{8188     \textcolor{keywordtype}{bool} AssertionResult::isOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8189         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType ) || shouldSuppressFailure( m\_info.resultDisposition );}
\DoxyCodeLine{8190     \}}
\DoxyCodeLine{8191 }
\DoxyCodeLine{8192     ResultWas::OfType AssertionResult::getResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8193         \textcolor{keywordflow}{return} m\_resultData.resultType;}
\DoxyCodeLine{8194     \}}
\DoxyCodeLine{8195 }
\DoxyCodeLine{8196     \textcolor{keywordtype}{bool} AssertionResult::hasExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8197         \textcolor{keywordflow}{return} m\_info.capturedExpression[0] != 0;}
\DoxyCodeLine{8198     \}}
\DoxyCodeLine{8199 }
\DoxyCodeLine{8200     \textcolor{keywordtype}{bool} AssertionResult::hasMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8201         \textcolor{keywordflow}{return} !m\_resultData.message.empty();}
\DoxyCodeLine{8202     \}}
\DoxyCodeLine{8203 }
\DoxyCodeLine{8204     std::string capturedExpressionWithSecondArgument( \textcolor{keywordtype}{char} \textcolor{keyword}{const} * capturedExpression, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * secondArg ) \{}
\DoxyCodeLine{8205         \textcolor{keywordflow}{return} (secondArg[0] == 0 || secondArg[0] == \textcolor{charliteral}{'"{}'} \&\& secondArg[1] == \textcolor{charliteral}{'"{}'})}
\DoxyCodeLine{8206             ? capturedExpression}
\DoxyCodeLine{8207             : std::string(capturedExpression) + "{}, "{} + secondArg;}
\DoxyCodeLine{8208     \}}
\DoxyCodeLine{8209 }
\DoxyCodeLine{8210     std::string AssertionResult::getExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8211         \textcolor{keywordflow}{if}( isFalseTest( m\_info.resultDisposition ) )}
\DoxyCodeLine{8212             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}!("{}} + capturedExpressionWithSecondArgument(m\_info.capturedExpression, m\_info.secondArg) + "{})"{};}
\DoxyCodeLine{8213         \textcolor{keywordflow}{else}}
\DoxyCodeLine{8214             \textcolor{keywordflow}{return} capturedExpressionWithSecondArgument(m\_info.capturedExpression, m\_info.secondArg);}
\DoxyCodeLine{8215     \}}
\DoxyCodeLine{8216     std::string AssertionResult::getExpressionInMacro()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8217         \textcolor{keywordflow}{if}( m\_info.macroName[0] == 0 )}
\DoxyCodeLine{8218             \textcolor{keywordflow}{return} capturedExpressionWithSecondArgument(m\_info.capturedExpression, m\_info.secondArg);}
\DoxyCodeLine{8219         \textcolor{keywordflow}{else}}
\DoxyCodeLine{8220             \textcolor{keywordflow}{return} std::string(m\_info.macroName) + "{}( "{} + capturedExpressionWithSecondArgument(m\_info.capturedExpression, m\_info.secondArg) + "{} )"{};}
\DoxyCodeLine{8221     \}}
\DoxyCodeLine{8222 }
\DoxyCodeLine{8223     \textcolor{keywordtype}{bool} AssertionResult::hasExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8224         \textcolor{keywordflow}{return} hasExpression() \&\& getExpandedExpression() != getExpression();}
\DoxyCodeLine{8225     \}}
\DoxyCodeLine{8226 }
\DoxyCodeLine{8227     std::string AssertionResult::getExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8228         \textcolor{keywordflow}{return} m\_resultData.reconstructExpression();}
\DoxyCodeLine{8229     \}}
\DoxyCodeLine{8230 }
\DoxyCodeLine{8231     std::string AssertionResult::getMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8232         \textcolor{keywordflow}{return} m\_resultData.message;}
\DoxyCodeLine{8233     \}}
\DoxyCodeLine{8234     SourceLineInfo AssertionResult::getSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8235         \textcolor{keywordflow}{return} m\_info.lineInfo;}
\DoxyCodeLine{8236     \}}
\DoxyCodeLine{8237 }
\DoxyCodeLine{8238     std::string AssertionResult::getTestMacroName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8239         \textcolor{keywordflow}{return} m\_info.macroName;}
\DoxyCodeLine{8240     \}}
\DoxyCodeLine{8241 }
\DoxyCodeLine{8242     \textcolor{keywordtype}{void} AssertionResult::discardDecomposedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8243         m\_resultData.decomposedExpression = CATCH\_NULL;}
\DoxyCodeLine{8244     \}}
\DoxyCodeLine{8245 }
\DoxyCodeLine{8246     \textcolor{keywordtype}{void} AssertionResult::expandDecomposedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8247         m\_resultData.reconstructExpression();}
\DoxyCodeLine{8248     \}}
\DoxyCodeLine{8249 }
\DoxyCodeLine{8250 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8251 }
\DoxyCodeLine{8252 \textcolor{comment}{// \#included from: catch\_test\_case\_info.hpp}}
\DoxyCodeLine{8253 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TEST\_CASE\_INFO\_HPP\_INCLUDED}}
\DoxyCodeLine{8254 }
\DoxyCodeLine{8255 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{8256 }
\DoxyCodeLine{8257 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8258 }
\DoxyCodeLine{8259     \textcolor{keyword}{inline} TestCaseInfo::SpecialProperties parseSpecialTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{8260         \textcolor{keywordflow}{if}( startsWith( tag, \textcolor{charliteral}{'.'} ) ||}
\DoxyCodeLine{8261             tag == \textcolor{stringliteral}{"{}hide"{}} ||}
\DoxyCodeLine{8262             tag == \textcolor{stringliteral}{"{}!hide"{}} )}
\DoxyCodeLine{8263             \textcolor{keywordflow}{return} TestCaseInfo::IsHidden;}
\DoxyCodeLine{8264         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!throws"{}} )}
\DoxyCodeLine{8265             \textcolor{keywordflow}{return} TestCaseInfo::Throws;}
\DoxyCodeLine{8266         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!shouldfail"{}} )}
\DoxyCodeLine{8267             \textcolor{keywordflow}{return} TestCaseInfo::ShouldFail;}
\DoxyCodeLine{8268         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!mayfail"{}} )}
\DoxyCodeLine{8269             \textcolor{keywordflow}{return} TestCaseInfo::MayFail;}
\DoxyCodeLine{8270         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!nonportable"{}} )}
\DoxyCodeLine{8271             \textcolor{keywordflow}{return} TestCaseInfo::NonPortable;}
\DoxyCodeLine{8272         \textcolor{keywordflow}{else}}
\DoxyCodeLine{8273             \textcolor{keywordflow}{return} TestCaseInfo::None;}
\DoxyCodeLine{8274     \}}
\DoxyCodeLine{8275     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isReservedTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{8276         \textcolor{keywordflow}{return} parseSpecialTag( tag ) == TestCaseInfo::None \&\& tag.size() > 0 \&\& !std::isalnum( tag[0] );}
\DoxyCodeLine{8277     \}}
\DoxyCodeLine{8278     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} enforceNotReservedTag( std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo ) \{}
\DoxyCodeLine{8279         \textcolor{keywordflow}{if}( isReservedTag( tag ) ) \{}
\DoxyCodeLine{8280             std::ostringstream ss;}
\DoxyCodeLine{8281             ss << Colour(Colour::Red)}
\DoxyCodeLine{8282                << \textcolor{stringliteral}{"{}Tag name ["{}} << tag << \textcolor{stringliteral}{"{}] not allowed.\(\backslash\)n"{}}}
\DoxyCodeLine{8283                << \textcolor{stringliteral}{"{}Tag names starting with non alpha-\/numeric characters are reserved\(\backslash\)n"{}}}
\DoxyCodeLine{8284                << Colour(Colour::FileName)}
\DoxyCodeLine{8285                << \_lineInfo << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{8286             \textcolor{keywordflow}{throw} std::runtime\_error(ss.str());}
\DoxyCodeLine{8287         \}}
\DoxyCodeLine{8288     \}}
\DoxyCodeLine{8289 }
\DoxyCodeLine{8290     TestCase makeTestCase(  ITestCase* \_testCase,}
\DoxyCodeLine{8291                             std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{8292                             std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{8293                             std::string \textcolor{keyword}{const}\& \_descOrTags,}
\DoxyCodeLine{8294                             SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{8295     \{}
\DoxyCodeLine{8296         \textcolor{keywordtype}{bool} isHidden( startsWith( \_name, \textcolor{stringliteral}{"{}./"{}} ) ); \textcolor{comment}{// Legacy support}}
\DoxyCodeLine{8297 }
\DoxyCodeLine{8298         \textcolor{comment}{// Parse out tags}}
\DoxyCodeLine{8299         std::set<std::string> tags;}
\DoxyCodeLine{8300         std::string desc, tag;}
\DoxyCodeLine{8301         \textcolor{keywordtype}{bool} inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{8302         \textcolor{keywordflow}{for}( std::size\_t i = 0; i < \_descOrTags.size(); ++i ) \{}
\DoxyCodeLine{8303             \textcolor{keywordtype}{char} c = \_descOrTags[i];}
\DoxyCodeLine{8304             \textcolor{keywordflow}{if}( !inTag ) \{}
\DoxyCodeLine{8305                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} )}
\DoxyCodeLine{8306                     inTag = \textcolor{keyword}{true};}
\DoxyCodeLine{8307                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{8308                     desc += c;}
\DoxyCodeLine{8309             \}}
\DoxyCodeLine{8310             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8311                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{']'} ) \{}
\DoxyCodeLine{8312                     TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );}
\DoxyCodeLine{8313                     \textcolor{keywordflow}{if}( prop == TestCaseInfo::IsHidden )}
\DoxyCodeLine{8314                         isHidden = \textcolor{keyword}{true};}
\DoxyCodeLine{8315                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( prop == TestCaseInfo::None )}
\DoxyCodeLine{8316                         enforceNotReservedTag( tag, \_lineInfo );}
\DoxyCodeLine{8317 }
\DoxyCodeLine{8318                     tags.insert( tag );}
\DoxyCodeLine{8319                     tag.clear();}
\DoxyCodeLine{8320                     inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{8321                 \}}
\DoxyCodeLine{8322                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{8323                     tag += c;}
\DoxyCodeLine{8324             \}}
\DoxyCodeLine{8325         \}}
\DoxyCodeLine{8326         \textcolor{keywordflow}{if}( isHidden ) \{}
\DoxyCodeLine{8327             tags.insert( \textcolor{stringliteral}{"{}hide"{}} );}
\DoxyCodeLine{8328             tags.insert( \textcolor{stringliteral}{"{}."{}} );}
\DoxyCodeLine{8329         \}}
\DoxyCodeLine{8330 }
\DoxyCodeLine{8331         TestCaseInfo info( \_name, \_className, desc, tags, \_lineInfo );}
\DoxyCodeLine{8332         \textcolor{keywordflow}{return} TestCase( \_testCase, info );}
\DoxyCodeLine{8333     \}}
\DoxyCodeLine{8334 }
\DoxyCodeLine{8335     \textcolor{keywordtype}{void} setTags( TestCaseInfo\& testCaseInfo, std::set<std::string> \textcolor{keyword}{const}\& tags )}
\DoxyCodeLine{8336     \{}
\DoxyCodeLine{8337         testCaseInfo.tags = tags;}
\DoxyCodeLine{8338         testCaseInfo.lcaseTags.clear();}
\DoxyCodeLine{8339 }
\DoxyCodeLine{8340         std::ostringstream oss;}
\DoxyCodeLine{8341         \textcolor{keywordflow}{for}( std::set<std::string>::const\_iterator it = tags.begin(), itEnd = tags.end(); it != itEnd; ++it ) \{}
\DoxyCodeLine{8342             oss << \textcolor{charliteral}{'['} << *it << \textcolor{charliteral}{']'};}
\DoxyCodeLine{8343             std::string lcaseTag = toLower( *it );}
\DoxyCodeLine{8344             testCaseInfo.properties = \textcolor{keyword}{static\_cast<}TestCaseInfo::SpecialProperties\textcolor{keyword}{>}( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );}
\DoxyCodeLine{8345             testCaseInfo.lcaseTags.insert( lcaseTag );}
\DoxyCodeLine{8346         \}}
\DoxyCodeLine{8347         testCaseInfo.tagsAsString = oss.str();}
\DoxyCodeLine{8348     \}}
\DoxyCodeLine{8349 }
\DoxyCodeLine{8350     TestCaseInfo::TestCaseInfo( std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{8351                                 std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{8352                                 std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{8353                                 std::set<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{8354                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{8355     :   name( \_name ),}
\DoxyCodeLine{8356         className( \_className ),}
\DoxyCodeLine{8357         description( \_description ),}
\DoxyCodeLine{8358         lineInfo( \_lineInfo ),}
\DoxyCodeLine{8359         properties( \mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}} )}
\DoxyCodeLine{8360     \{}
\DoxyCodeLine{8361         setTags( *\textcolor{keyword}{this}, \_tags );}
\DoxyCodeLine{8362     \}}
\DoxyCodeLine{8363 }
\DoxyCodeLine{8364     TestCaseInfo::TestCaseInfo( TestCaseInfo \textcolor{keyword}{const}\& other )}
\DoxyCodeLine{8365     :   name( other.name ),}
\DoxyCodeLine{8366         className( other.className ),}
\DoxyCodeLine{8367         description( other.description ),}
\DoxyCodeLine{8368         tags( other.tags ),}
\DoxyCodeLine{8369         lcaseTags( other.lcaseTags ),}
\DoxyCodeLine{8370         tagsAsString( other.tagsAsString ),}
\DoxyCodeLine{8371         lineInfo( other.lineInfo ),}
\DoxyCodeLine{8372         properties( other.properties )}
\DoxyCodeLine{8373     \{\}}
\DoxyCodeLine{8374 }
\DoxyCodeLine{8375     \textcolor{keywordtype}{bool} TestCaseInfo::isHidden()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8376         \textcolor{keywordflow}{return} ( properties \& IsHidden ) != 0;}
\DoxyCodeLine{8377     \}}
\DoxyCodeLine{8378     \textcolor{keywordtype}{bool} TestCaseInfo::throws()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8379         \textcolor{keywordflow}{return} ( properties \& Throws ) != 0;}
\DoxyCodeLine{8380     \}}
\DoxyCodeLine{8381     \textcolor{keywordtype}{bool} TestCaseInfo::okToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8382         \textcolor{keywordflow}{return} ( properties \& (ShouldFail | MayFail ) ) != 0;}
\DoxyCodeLine{8383     \}}
\DoxyCodeLine{8384     \textcolor{keywordtype}{bool} TestCaseInfo::expectedToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8385         \textcolor{keywordflow}{return} ( properties \& (ShouldFail ) ) != 0;}
\DoxyCodeLine{8386     \}}
\DoxyCodeLine{8387 }
\DoxyCodeLine{8388     TestCase::TestCase( ITestCase* testCase, TestCaseInfo \textcolor{keyword}{const}\& info ) : TestCaseInfo( info ), test( testCase ) \{\}}
\DoxyCodeLine{8389 }
\DoxyCodeLine{8390     TestCase::TestCase( TestCase \textcolor{keyword}{const}\& other )}
\DoxyCodeLine{8391     :   TestCaseInfo( other ),}
\DoxyCodeLine{8392         test( other.test )}
\DoxyCodeLine{8393     \{\}}
\DoxyCodeLine{8394 }
\DoxyCodeLine{8395     TestCase TestCase::withName( std::string \textcolor{keyword}{const}\& \_newName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8396         TestCase other( *\textcolor{keyword}{this} );}
\DoxyCodeLine{8397         other.name = \_newName;}
\DoxyCodeLine{8398         \textcolor{keywordflow}{return} other;}
\DoxyCodeLine{8399     \}}
\DoxyCodeLine{8400 }
\DoxyCodeLine{8401     \textcolor{keywordtype}{void} TestCase::swap( TestCase\& other ) \{}
\DoxyCodeLine{8402         test.swap( other.test );}
\DoxyCodeLine{8403         name.swap( other.name );}
\DoxyCodeLine{8404         className.swap( other.className );}
\DoxyCodeLine{8405         description.swap( other.description );}
\DoxyCodeLine{8406         tags.swap( other.tags );}
\DoxyCodeLine{8407         lcaseTags.swap( other.lcaseTags );}
\DoxyCodeLine{8408         tagsAsString.swap( other.tagsAsString );}
\DoxyCodeLine{8409         std::swap( TestCaseInfo::properties, \textcolor{keyword}{static\_cast<}TestCaseInfo\&\textcolor{keyword}{>}( other ).properties );}
\DoxyCodeLine{8410         std::swap( lineInfo, other.lineInfo );}
\DoxyCodeLine{8411     \}}
\DoxyCodeLine{8412 }
\DoxyCodeLine{8413     \textcolor{keywordtype}{void} TestCase::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8414         test-\/>invoke();}
\DoxyCodeLine{8415     \}}
\DoxyCodeLine{8416 }
\DoxyCodeLine{8417     \textcolor{keywordtype}{bool} TestCase::operator == ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8418         \textcolor{keywordflow}{return}  test.get() == other.test.get() \&\&}
\DoxyCodeLine{8419                 name == other.name \&\&}
\DoxyCodeLine{8420                 className == other.className;}
\DoxyCodeLine{8421     \}}
\DoxyCodeLine{8422 }
\DoxyCodeLine{8423     \textcolor{keywordtype}{bool} TestCase::operator < ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8424         \textcolor{keywordflow}{return} name < other.name;}
\DoxyCodeLine{8425     \}}
\DoxyCodeLine{8426     TestCase\& TestCase::operator = ( TestCase \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{8427         TestCase temp( other );}
\DoxyCodeLine{8428         swap( temp );}
\DoxyCodeLine{8429         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8430     \}}
\DoxyCodeLine{8431 }
\DoxyCodeLine{8432     TestCaseInfo \textcolor{keyword}{const}\& TestCase::getTestCaseInfo()\textcolor{keyword}{ const}}
\DoxyCodeLine{8433 \textcolor{keyword}{    }\{}
\DoxyCodeLine{8434         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8435     \}}
\DoxyCodeLine{8436 }
\DoxyCodeLine{8437 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8438 }
\DoxyCodeLine{8439 \textcolor{comment}{// \#included from: catch\_version.hpp}}
\DoxyCodeLine{8440 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_VERSION\_HPP\_INCLUDED}}
\DoxyCodeLine{8441 }
\DoxyCodeLine{8442 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8443 }
\DoxyCodeLine{8444     Version::Version}
\DoxyCodeLine{8445         (   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{8446             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{8447             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{8448             \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{8449             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber )}
\DoxyCodeLine{8450     :   majorVersion( \_majorVersion ),}
\DoxyCodeLine{8451         minorVersion( \_minorVersion ),}
\DoxyCodeLine{8452         patchNumber( \_patchNumber ),}
\DoxyCodeLine{8453         branchName( \_branchName ),}
\DoxyCodeLine{8454         buildNumber( \_buildNumber )}
\DoxyCodeLine{8455     \{\}}
\DoxyCodeLine{8456 }
\DoxyCodeLine{8457     std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version ) \{}
\DoxyCodeLine{8458         os  << version.majorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{8459             << version.minorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{8460             << version.patchNumber;}
\DoxyCodeLine{8461         \textcolor{comment}{// branchName is never null -\/> 0th char is \(\backslash\)0 if it is empty}}
\DoxyCodeLine{8462         \textcolor{keywordflow}{if} (version.branchName[0]) \{}
\DoxyCodeLine{8463             os << \textcolor{charliteral}{'-\/'} << version.branchName}
\DoxyCodeLine{8464                << \textcolor{charliteral}{'.'} << version.buildNumber;}
\DoxyCodeLine{8465         \}}
\DoxyCodeLine{8466         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8467     \}}
\DoxyCodeLine{8468 }
\DoxyCodeLine{8469     \textcolor{keyword}{inline} Version libraryVersion() \{}
\DoxyCodeLine{8470         \textcolor{keyword}{static} Version version( 1, 12, 2, \textcolor{stringliteral}{"{}"{}}, 0 );}
\DoxyCodeLine{8471         \textcolor{keywordflow}{return} version;}
\DoxyCodeLine{8472     \}}
\DoxyCodeLine{8473 }
\DoxyCodeLine{8474 \}}
\DoxyCodeLine{8475 }
\DoxyCodeLine{8476 \textcolor{comment}{// \#included from: catch\_message.hpp}}
\DoxyCodeLine{8477 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_MESSAGE\_HPP\_INCLUDED}}
\DoxyCodeLine{8478 }
\DoxyCodeLine{8479 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8480 }
\DoxyCodeLine{8481     MessageInfo::MessageInfo(   std::string \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{8482                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{8483                                 ResultWas::OfType \_type )}
\DoxyCodeLine{8484     :   macroName( \_macroName ),}
\DoxyCodeLine{8485         lineInfo( \_lineInfo ),}
\DoxyCodeLine{8486         type( \_type ),}
\DoxyCodeLine{8487         sequence( ++globalCount )}
\DoxyCodeLine{8488     \{\}}
\DoxyCodeLine{8489 }
\DoxyCodeLine{8490     \textcolor{comment}{// This may need protecting if threading support is added}}
\DoxyCodeLine{8491     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} MessageInfo::globalCount = 0;}
\DoxyCodeLine{8492 }
\DoxyCodeLine{8494 }
\DoxyCodeLine{8495     ScopedMessage::ScopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder )}
\DoxyCodeLine{8496     : m\_info( builder.m\_info )}
\DoxyCodeLine{8497     \{}
\DoxyCodeLine{8498         m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{8499         getResultCapture().pushScopedMessage( m\_info );}
\DoxyCodeLine{8500     \}}
\DoxyCodeLine{8501     ScopedMessage::ScopedMessage( ScopedMessage \textcolor{keyword}{const}\& other )}
\DoxyCodeLine{8502     : m\_info( other.m\_info )}
\DoxyCodeLine{8503     \{\}}
\DoxyCodeLine{8504 }
\DoxyCodeLine{8505 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{8506 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{8507 \textcolor{preprocessor}{\#pragma warning(disable:4996) }\textcolor{comment}{// std::uncaught\_exception is deprecated in C++17}}
\DoxyCodeLine{8508 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8509     ScopedMessage::\string~ScopedMessage() \{}
\DoxyCodeLine{8510         \textcolor{keywordflow}{if} ( !std::uncaught\_exception() )\{}
\DoxyCodeLine{8511             getResultCapture().popScopedMessage(m\_info);}
\DoxyCodeLine{8512         \}}
\DoxyCodeLine{8513     \}}
\DoxyCodeLine{8514 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{8515 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{8516 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8517 }
\DoxyCodeLine{8518 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8519 }
\DoxyCodeLine{8520 \textcolor{comment}{// \#included from: catch\_legacy\_reporter\_adapter.hpp}}
\DoxyCodeLine{8521 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_LEGACY\_REPORTER\_ADAPTER\_HPP\_INCLUDED}}
\DoxyCodeLine{8522 }
\DoxyCodeLine{8523 \textcolor{comment}{// \#included from: catch\_legacy\_reporter\_adapter.h}}
\DoxyCodeLine{8524 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_LEGACY\_REPORTER\_ADAPTER\_H\_INCLUDED}}
\DoxyCodeLine{8525 }
\DoxyCodeLine{8526 \textcolor{keyword}{namespace }Catch}
\DoxyCodeLine{8527 \{}
\DoxyCodeLine{8528     \textcolor{comment}{// Deprecated}}
\DoxyCodeLine{8529     \textcolor{keyword}{struct }IReporter : IShared \{}
\DoxyCodeLine{8530         \textcolor{keyword}{virtual} \string~IReporter();}
\DoxyCodeLine{8531 }
\DoxyCodeLine{8532         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} shouldRedirectStdout() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{8533 }
\DoxyCodeLine{8534         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} StartTesting() = 0;}
\DoxyCodeLine{8535         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} EndTesting( Totals \textcolor{keyword}{const}\& totals ) = 0;}
\DoxyCodeLine{8536         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} StartGroup( std::string \textcolor{keyword}{const}\& groupName ) = 0;}
\DoxyCodeLine{8537         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} EndGroup( std::string \textcolor{keyword}{const}\& groupName, Totals \textcolor{keyword}{const}\& totals ) = 0;}
\DoxyCodeLine{8538         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} StartTestCase( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{8539         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} EndTestCase( TestCaseInfo \textcolor{keyword}{const}\& testInfo, Totals \textcolor{keyword}{const}\& totals, std::string \textcolor{keyword}{const}\& stdOut, std::string \textcolor{keyword}{const}\& stdErr ) = 0;}
\DoxyCodeLine{8540         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} StartSection( std::string \textcolor{keyword}{const}\& sectionName, std::string \textcolor{keyword}{const}\& description ) = 0;}
\DoxyCodeLine{8541         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} EndSection( std::string \textcolor{keyword}{const}\& sectionName, Counts \textcolor{keyword}{const}\& assertions ) = 0;}
\DoxyCodeLine{8542         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} NoAssertionsInSection( std::string \textcolor{keyword}{const}\& sectionName ) = 0;}
\DoxyCodeLine{8543         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} NoAssertionsInTestCase( std::string \textcolor{keyword}{const}\& testName ) = 0;}
\DoxyCodeLine{8544         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Aborted() = 0;}
\DoxyCodeLine{8545         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Result( AssertionResult \textcolor{keyword}{const}\& result ) = 0;}
\DoxyCodeLine{8546     \};}
\DoxyCodeLine{8547 }
\DoxyCodeLine{8548     \textcolor{keyword}{class }LegacyReporterAdapter : \textcolor{keyword}{public} SharedImpl<IStreamingReporter>}
\DoxyCodeLine{8549     \{}
\DoxyCodeLine{8550     \textcolor{keyword}{public}:}
\DoxyCodeLine{8551         LegacyReporterAdapter( Ptr<IReporter> \textcolor{keyword}{const}\& legacyReporter );}
\DoxyCodeLine{8552         \textcolor{keyword}{virtual} \string~LegacyReporterAdapter();}
\DoxyCodeLine{8553 }
\DoxyCodeLine{8554         \textcolor{keyword}{virtual} ReporterPreferences getPreferences() \textcolor{keyword}{const};}
\DoxyCodeLine{8555         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& );}
\DoxyCodeLine{8556         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& );}
\DoxyCodeLine{8557         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo );}
\DoxyCodeLine{8558         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo );}
\DoxyCodeLine{8559         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo );}
\DoxyCodeLine{8560         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& );}
\DoxyCodeLine{8561         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats );}
\DoxyCodeLine{8562         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats );}
\DoxyCodeLine{8563         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats );}
\DoxyCodeLine{8564         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats );}
\DoxyCodeLine{8565         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats );}
\DoxyCodeLine{8566         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& );}
\DoxyCodeLine{8567 }
\DoxyCodeLine{8568     \textcolor{keyword}{private}:}
\DoxyCodeLine{8569         Ptr<IReporter> m\_legacyReporter;}
\DoxyCodeLine{8570     \};}
\DoxyCodeLine{8571 \}}
\DoxyCodeLine{8572 }
\DoxyCodeLine{8573 \textcolor{keyword}{namespace }Catch}
\DoxyCodeLine{8574 \{}
\DoxyCodeLine{8575     LegacyReporterAdapter::LegacyReporterAdapter( Ptr<IReporter> \textcolor{keyword}{const}\& legacyReporter )}
\DoxyCodeLine{8576     :   m\_legacyReporter( legacyReporter )}
\DoxyCodeLine{8577     \{\}}
\DoxyCodeLine{8578     LegacyReporterAdapter::\string~LegacyReporterAdapter() \{\}}
\DoxyCodeLine{8579 }
\DoxyCodeLine{8580     ReporterPreferences LegacyReporterAdapter::getPreferences()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8581         ReporterPreferences prefs;}
\DoxyCodeLine{8582         prefs.shouldRedirectStdOut = m\_legacyReporter-\/>shouldRedirectStdout();}
\DoxyCodeLine{8583         \textcolor{keywordflow}{return} prefs;}
\DoxyCodeLine{8584     \}}
\DoxyCodeLine{8585 }
\DoxyCodeLine{8586     \textcolor{keywordtype}{void} LegacyReporterAdapter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{8587     \textcolor{keywordtype}{void} LegacyReporterAdapter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{8588         m\_legacyReporter-\/>StartTesting();}
\DoxyCodeLine{8589     \}}
\DoxyCodeLine{8590     \textcolor{keywordtype}{void} LegacyReporterAdapter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{8591         m\_legacyReporter-\/>StartGroup( groupInfo.name );}
\DoxyCodeLine{8592     \}}
\DoxyCodeLine{8593     \textcolor{keywordtype}{void} LegacyReporterAdapter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{8594         m\_legacyReporter-\/>StartTestCase( testInfo );}
\DoxyCodeLine{8595     \}}
\DoxyCodeLine{8596     \textcolor{keywordtype}{void} LegacyReporterAdapter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{8597         m\_legacyReporter-\/>StartSection( sectionInfo.name, sectionInfo.description );}
\DoxyCodeLine{8598     \}}
\DoxyCodeLine{8599     \textcolor{keywordtype}{void} LegacyReporterAdapter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{8600         \textcolor{comment}{// Not on legacy interface}}
\DoxyCodeLine{8601     \}}
\DoxyCodeLine{8602 }
\DoxyCodeLine{8603     \textcolor{keywordtype}{bool} LegacyReporterAdapter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{8604         \textcolor{keywordflow}{if}( assertionStats.assertionResult.getResultType() != ResultWas::Ok ) \{}
\DoxyCodeLine{8605             \textcolor{keywordflow}{for}( std::vector<MessageInfo>::const\_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();}
\DoxyCodeLine{8606                     it != itEnd;}
\DoxyCodeLine{8607                     ++it ) \{}
\DoxyCodeLine{8608                 \textcolor{keywordflow}{if}( it-\/>type == ResultWas::Info ) \{}
\DoxyCodeLine{8609                     ResultBuilder rb( it-\/>macroName.c\_str(), it-\/>lineInfo, \textcolor{stringliteral}{"{}"{}}, ResultDisposition::Normal );}
\DoxyCodeLine{8610                     rb << it-\/>message;}
\DoxyCodeLine{8611                     rb.setResultType( ResultWas::Info );}
\DoxyCodeLine{8612                     AssertionResult result = rb.build();}
\DoxyCodeLine{8613                     m\_legacyReporter-\/>Result( result );}
\DoxyCodeLine{8614                 \}}
\DoxyCodeLine{8615             \}}
\DoxyCodeLine{8616         \}}
\DoxyCodeLine{8617         m\_legacyReporter-\/>Result( assertionStats.assertionResult );}
\DoxyCodeLine{8618         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{8619     \}}
\DoxyCodeLine{8620     \textcolor{keywordtype}{void} LegacyReporterAdapter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{8621         \textcolor{keywordflow}{if}( sectionStats.missingAssertions )}
\DoxyCodeLine{8622             m\_legacyReporter-\/>NoAssertionsInSection( sectionStats.sectionInfo.name );}
\DoxyCodeLine{8623         m\_legacyReporter-\/>EndSection( sectionStats.sectionInfo.name, sectionStats.assertions );}
\DoxyCodeLine{8624     \}}
\DoxyCodeLine{8625     \textcolor{keywordtype}{void} LegacyReporterAdapter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{8626         m\_legacyReporter-\/>EndTestCase}
\DoxyCodeLine{8627             (   testCaseStats.testInfo,}
\DoxyCodeLine{8628                 testCaseStats.totals,}
\DoxyCodeLine{8629                 testCaseStats.stdOut,}
\DoxyCodeLine{8630                 testCaseStats.stdErr );}
\DoxyCodeLine{8631     \}}
\DoxyCodeLine{8632     \textcolor{keywordtype}{void} LegacyReporterAdapter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{8633         \textcolor{keywordflow}{if}( testGroupStats.aborting )}
\DoxyCodeLine{8634             m\_legacyReporter-\/>Aborted();}
\DoxyCodeLine{8635         m\_legacyReporter-\/>EndGroup( testGroupStats.groupInfo.name, testGroupStats.totals );}
\DoxyCodeLine{8636     \}}
\DoxyCodeLine{8637     \textcolor{keywordtype}{void} LegacyReporterAdapter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{8638         m\_legacyReporter-\/>EndTesting( testRunStats.totals );}
\DoxyCodeLine{8639     \}}
\DoxyCodeLine{8640     \textcolor{keywordtype}{void} LegacyReporterAdapter::skipTest( TestCaseInfo \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{8641     \}}
\DoxyCodeLine{8642 \}}
\DoxyCodeLine{8643 }
\DoxyCodeLine{8644 \textcolor{comment}{// \#included from: catch\_timer.hpp}}
\DoxyCodeLine{8645 }
\DoxyCodeLine{8646 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{8647 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{8648 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wc++11-\/long-\/long"{}}}
\DoxyCodeLine{8649 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8650 }
\DoxyCodeLine{8651 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8652 }
\DoxyCodeLine{8653 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8654 }
\DoxyCodeLine{8655 \textcolor{preprocessor}{\#include <sys/time.h>}}
\DoxyCodeLine{8656 }
\DoxyCodeLine{8657 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8658 }
\DoxyCodeLine{8659 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8660 }
\DoxyCodeLine{8661     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{8662 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8663         UInt64 getCurrentTicks() \{}
\DoxyCodeLine{8664             \textcolor{keyword}{static} UInt64 hz=0, hzo=0;}
\DoxyCodeLine{8665             \textcolor{keywordflow}{if} (!hz) \{}
\DoxyCodeLine{8666                 QueryPerformanceFrequency( \textcolor{keyword}{reinterpret\_cast<}LARGE\_INTEGER*\textcolor{keyword}{>}( \&hz ) );}
\DoxyCodeLine{8667                 QueryPerformanceCounter( \textcolor{keyword}{reinterpret\_cast<}LARGE\_INTEGER*\textcolor{keyword}{>}( \&hzo ) );}
\DoxyCodeLine{8668             \}}
\DoxyCodeLine{8669             UInt64 t;}
\DoxyCodeLine{8670             QueryPerformanceCounter( \textcolor{keyword}{reinterpret\_cast<}LARGE\_INTEGER*\textcolor{keyword}{>}( \&t ) );}
\DoxyCodeLine{8671             \textcolor{keywordflow}{return} ((t-\/hzo)*1000000)/hz;}
\DoxyCodeLine{8672         \}}
\DoxyCodeLine{8673 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8674         UInt64 getCurrentTicks() \{}
\DoxyCodeLine{8675             timeval t;}
\DoxyCodeLine{8676             gettimeofday(\&t,CATCH\_NULL);}
\DoxyCodeLine{8677             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}UInt64\textcolor{keyword}{>}( t.tv\_sec ) * 1000000ull + \textcolor{keyword}{static\_cast<}UInt64\textcolor{keyword}{>}( t.tv\_usec );}
\DoxyCodeLine{8678         \}}
\DoxyCodeLine{8679 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8680     \}}
\DoxyCodeLine{8681 }
\DoxyCodeLine{8682     \textcolor{keywordtype}{void} Timer::start() \{}
\DoxyCodeLine{8683         m\_ticks = getCurrentTicks();}
\DoxyCodeLine{8684     \}}
\DoxyCodeLine{8685     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Timer::getElapsedMicroseconds()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8686         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(getCurrentTicks() -\/ m\_ticks);}
\DoxyCodeLine{8687     \}}
\DoxyCodeLine{8688     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Timer::getElapsedMilliseconds()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8689         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(getElapsedMicroseconds()/1000);}
\DoxyCodeLine{8690     \}}
\DoxyCodeLine{8691     \textcolor{keywordtype}{double} Timer::getElapsedSeconds()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8692         \textcolor{keywordflow}{return} getElapsedMicroseconds()/1000000.0;}
\DoxyCodeLine{8693     \}}
\DoxyCodeLine{8694 }
\DoxyCodeLine{8695 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8696 }
\DoxyCodeLine{8697 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{8698 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{8699 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8700 \textcolor{comment}{// \#included from: catch\_common.hpp}}
\DoxyCodeLine{8701 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_COMMON\_HPP\_INCLUDED}}
\DoxyCodeLine{8702 }
\DoxyCodeLine{8703 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{8704 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{8705 }
\DoxyCodeLine{8706 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8707 }
\DoxyCodeLine{8708     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix ) \{}
\DoxyCodeLine{8709         \textcolor{keywordflow}{return} s.size() >= prefix.size() \&\& std::equal(prefix.begin(), prefix.end(), s.begin());}
\DoxyCodeLine{8710     \}}
\DoxyCodeLine{8711     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix ) \{}
\DoxyCodeLine{8712         \textcolor{keywordflow}{return} !s.empty() \&\& s[0] == prefix;}
\DoxyCodeLine{8713     \}}
\DoxyCodeLine{8714     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix ) \{}
\DoxyCodeLine{8715         \textcolor{keywordflow}{return} s.size() >= suffix.size() \&\& std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());}
\DoxyCodeLine{8716     \}}
\DoxyCodeLine{8717     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix ) \{}
\DoxyCodeLine{8718         \textcolor{keywordflow}{return} !s.empty() \&\& s[s.size()-\/1] == suffix;}
\DoxyCodeLine{8719     \}}
\DoxyCodeLine{8720     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix ) \{}
\DoxyCodeLine{8721         \textcolor{keywordflow}{return} s.find( infix ) != std::string::npos;}
\DoxyCodeLine{8722     \}}
\DoxyCodeLine{8723     \textcolor{keywordtype}{char} toLowerCh(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{8724         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( std::tolower( c ) );}
\DoxyCodeLine{8725     \}}
\DoxyCodeLine{8726     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s ) \{}
\DoxyCodeLine{8727         std::transform( s.begin(), s.end(), s.begin(), toLowerCh );}
\DoxyCodeLine{8728     \}}
\DoxyCodeLine{8729     std::string toLower( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{8730         std::string lc = s;}
\DoxyCodeLine{8731         toLowerInPlace( lc );}
\DoxyCodeLine{8732         \textcolor{keywordflow}{return} lc;}
\DoxyCodeLine{8733     \}}
\DoxyCodeLine{8734     std::string trim( std::string \textcolor{keyword}{const}\& str ) \{}
\DoxyCodeLine{8735         \textcolor{keyword}{static} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* whitespaceChars = \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)r\(\backslash\)t "{}};}
\DoxyCodeLine{8736         std::string::size\_type start = str.find\_first\_not\_of( whitespaceChars );}
\DoxyCodeLine{8737         std::string::size\_type end = str.find\_last\_not\_of( whitespaceChars );}
\DoxyCodeLine{8738 }
\DoxyCodeLine{8739         \textcolor{keywordflow}{return} start != std::string::npos ? str.substr( start, 1+end-\/start ) : std::string();}
\DoxyCodeLine{8740     \}}
\DoxyCodeLine{8741 }
\DoxyCodeLine{8742     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis ) \{}
\DoxyCodeLine{8743         \textcolor{keywordtype}{bool} replaced = \textcolor{keyword}{false};}
\DoxyCodeLine{8744         std::size\_t i = str.find( replaceThis );}
\DoxyCodeLine{8745         \textcolor{keywordflow}{while}( i != std::string::npos ) \{}
\DoxyCodeLine{8746             replaced = \textcolor{keyword}{true};}
\DoxyCodeLine{8747             str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );}
\DoxyCodeLine{8748             \textcolor{keywordflow}{if}( i < str.size()-\/withThis.size() )}
\DoxyCodeLine{8749                 i = str.find( replaceThis, i+withThis.size() );}
\DoxyCodeLine{8750             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8751                 i = std::string::npos;}
\DoxyCodeLine{8752         \}}
\DoxyCodeLine{8753         \textcolor{keywordflow}{return} replaced;}
\DoxyCodeLine{8754     \}}
\DoxyCodeLine{8755 }
\DoxyCodeLine{8756     pluralise::pluralise( std::size\_t count, std::string \textcolor{keyword}{const}\& label )}
\DoxyCodeLine{8757     :   m\_count( count ),}
\DoxyCodeLine{8758         m\_label( label )}
\DoxyCodeLine{8759     \{\}}
\DoxyCodeLine{8760 }
\DoxyCodeLine{8761     std::ostream\& operator << ( std::ostream\& os, pluralise \textcolor{keyword}{const}\& pluraliser ) \{}
\DoxyCodeLine{8762         os << pluraliser.m\_count << \textcolor{charliteral}{' '} << pluraliser.m\_label;}
\DoxyCodeLine{8763         \textcolor{keywordflow}{if}( pluraliser.m\_count != 1 )}
\DoxyCodeLine{8764             os << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{8765         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8766     \}}
\DoxyCodeLine{8767 }
\DoxyCodeLine{8768     SourceLineInfo::SourceLineInfo() : file(\textcolor{stringliteral}{"{}"{}}), line( 0 )\{\}}
\DoxyCodeLine{8769     SourceLineInfo::SourceLineInfo( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \_file, std::size\_t \_line )}
\DoxyCodeLine{8770     :   file( \_file ),}
\DoxyCodeLine{8771         line( \_line )}
\DoxyCodeLine{8772     \{\}}
\DoxyCodeLine{8773     \textcolor{keywordtype}{bool} SourceLineInfo::empty()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8774         \textcolor{keywordflow}{return} file[0] == \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{8775     \}}
\DoxyCodeLine{8776     \textcolor{keywordtype}{bool} SourceLineInfo::operator == ( SourceLineInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8777         \textcolor{keywordflow}{return} line == other.line \&\& (file == other.file || std::strcmp(file, other.file) == 0);}
\DoxyCodeLine{8778     \}}
\DoxyCodeLine{8779     \textcolor{keywordtype}{bool} SourceLineInfo::operator < ( SourceLineInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8780         \textcolor{keywordflow}{return} line < other.line || ( line == other.line \&\& (std::strcmp(file, other.file) < 0));}
\DoxyCodeLine{8781     \}}
\DoxyCodeLine{8782 }
\DoxyCodeLine{8783     \textcolor{keywordtype}{void} seedRng( IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{8784         \textcolor{keywordflow}{if}( config.rngSeed() != 0 )}
\DoxyCodeLine{8785             std::srand( config.rngSeed() );}
\DoxyCodeLine{8786     \}}
\DoxyCodeLine{8787     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \{}
\DoxyCodeLine{8788         \textcolor{keywordflow}{return} getCurrentContext().getConfig()-\/>rngSeed();}
\DoxyCodeLine{8789     \}}
\DoxyCodeLine{8790 }
\DoxyCodeLine{8791     std::ostream\& operator << ( std::ostream\& os, SourceLineInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{8792 \textcolor{preprocessor}{\#ifndef \_\_GNUG\_\_}}
\DoxyCodeLine{8793         os << info.file << \textcolor{charliteral}{'('} << info.line << \textcolor{charliteral}{')'};}
\DoxyCodeLine{8794 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8795         os << info.file << \textcolor{charliteral}{':'} << info.line;}
\DoxyCodeLine{8796 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8797         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8798     \}}
\DoxyCodeLine{8799 }
\DoxyCodeLine{8800     \textcolor{keywordtype}{void} throwLogicError( std::string \textcolor{keyword}{const}\& message, SourceLineInfo \textcolor{keyword}{const}\& locationInfo ) \{}
\DoxyCodeLine{8801         std::ostringstream oss;}
\DoxyCodeLine{8802         oss << locationInfo << \textcolor{stringliteral}{"{}: Internal Catch error: '"{}} << message << \textcolor{charliteral}{'\(\backslash\)''};}
\DoxyCodeLine{8803         \textcolor{keywordflow}{if}( alwaysTrue() )}
\DoxyCodeLine{8804             \textcolor{keywordflow}{throw} std::logic\_error( oss.str() );}
\DoxyCodeLine{8805     \}}
\DoxyCodeLine{8806 \}}
\DoxyCodeLine{8807 }
\DoxyCodeLine{8808 \textcolor{comment}{// \#included from: catch\_section.hpp}}
\DoxyCodeLine{8809 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_SECTION\_HPP\_INCLUDED}}
\DoxyCodeLine{8810 }
\DoxyCodeLine{8811 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8812 }
\DoxyCodeLine{8813     SectionInfo::SectionInfo}
\DoxyCodeLine{8814         (   SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{8815             std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{8816             std::string \textcolor{keyword}{const}\& \_description )}
\DoxyCodeLine{8817     :   name( \_name ),}
\DoxyCodeLine{8818         description( \_description ),}
\DoxyCodeLine{8819         lineInfo( \_lineInfo )}
\DoxyCodeLine{8820     \{\}}
\DoxyCodeLine{8821 }
\DoxyCodeLine{8822     Section::Section( SectionInfo \textcolor{keyword}{const}\& info )}
\DoxyCodeLine{8823     :   m\_info( info ),}
\DoxyCodeLine{8824         m\_sectionIncluded( getResultCapture().sectionStarted( m\_info, m\_assertions ) )}
\DoxyCodeLine{8825     \{}
\DoxyCodeLine{8826         m\_timer.start();}
\DoxyCodeLine{8827     \}}
\DoxyCodeLine{8828 }
\DoxyCodeLine{8829 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{8830 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{8831 \textcolor{preprocessor}{\#pragma warning(disable:4996) }\textcolor{comment}{// std::uncaught\_exception is deprecated in C++17}}
\DoxyCodeLine{8832 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8833     Section::\string~Section() \{}
\DoxyCodeLine{8834         \textcolor{keywordflow}{if}( m\_sectionIncluded ) \{}
\DoxyCodeLine{8835             SectionEndInfo endInfo( m\_info, m\_assertions, m\_timer.getElapsedSeconds() );}
\DoxyCodeLine{8836             \textcolor{keywordflow}{if}( std::uncaught\_exception() )}
\DoxyCodeLine{8837                 getResultCapture().sectionEndedEarly( endInfo );}
\DoxyCodeLine{8838             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8839                 getResultCapture().sectionEnded( endInfo );}
\DoxyCodeLine{8840         \}}
\DoxyCodeLine{8841     \}}
\DoxyCodeLine{8842 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{8843 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{8844 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8845 }
\DoxyCodeLine{8846     \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{8847     Section::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8848         \textcolor{keywordflow}{return} m\_sectionIncluded;}
\DoxyCodeLine{8849     \}}
\DoxyCodeLine{8850 }
\DoxyCodeLine{8851 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8852 }
\DoxyCodeLine{8853 \textcolor{comment}{// \#included from: catch\_debugger.hpp}}
\DoxyCodeLine{8854 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_DEBUGGER\_HPP\_INCLUDED}}
\DoxyCodeLine{8855 }
\DoxyCodeLine{8856 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{8857 }
\DoxyCodeLine{8858 \textcolor{preprocessor}{    \#include <assert.h>}}
\DoxyCodeLine{8859 \textcolor{preprocessor}{    \#include <stdbool.h>}}
\DoxyCodeLine{8860 \textcolor{preprocessor}{    \#include <sys/types.h>}}
\DoxyCodeLine{8861 \textcolor{preprocessor}{    \#include <unistd.h>}}
\DoxyCodeLine{8862 \textcolor{preprocessor}{    \#include <sys/sysctl.h>}}
\DoxyCodeLine{8863 }
\DoxyCodeLine{8864     \textcolor{keyword}{namespace }Catch\{}
\DoxyCodeLine{8865 }
\DoxyCodeLine{8866         \textcolor{comment}{// The following function is taken directly from the following technical note:}}
\DoxyCodeLine{8867         \textcolor{comment}{// http://developer.apple.com/library/mac/\#qa/qa2004/qa1361.html}}
\DoxyCodeLine{8868 }
\DoxyCodeLine{8869         \textcolor{comment}{// Returns true if the current process is being debugged (either}}
\DoxyCodeLine{8870         \textcolor{comment}{// running under the debugger or has a debugger attached post facto).}}
\DoxyCodeLine{8871         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{8872 }
\DoxyCodeLine{8873             \textcolor{keywordtype}{int}                 mib[4];}
\DoxyCodeLine{8874             \textcolor{keyword}{struct }kinfo\_proc   info;}
\DoxyCodeLine{8875             \textcolor{keywordtype}{size\_t}              size;}
\DoxyCodeLine{8876 }
\DoxyCodeLine{8877             \textcolor{comment}{// Initialize the flags so that, if sysctl fails for some bizarre}}
\DoxyCodeLine{8878             \textcolor{comment}{// reason, we get a predictable result.}}
\DoxyCodeLine{8879 }
\DoxyCodeLine{8880             info.kp\_proc.p\_flag = 0;}
\DoxyCodeLine{8881 }
\DoxyCodeLine{8882             \textcolor{comment}{// Initialize mib, which tells sysctl the info we want, in this case}}
\DoxyCodeLine{8883             \textcolor{comment}{// we're looking for information about a specific process ID.}}
\DoxyCodeLine{8884 }
\DoxyCodeLine{8885             mib[0] = CTL\_KERN;}
\DoxyCodeLine{8886             mib[1] = KERN\_PROC;}
\DoxyCodeLine{8887             mib[2] = KERN\_PROC\_PID;}
\DoxyCodeLine{8888             mib[3] = getpid();}
\DoxyCodeLine{8889 }
\DoxyCodeLine{8890             \textcolor{comment}{// Call sysctl.}}
\DoxyCodeLine{8891 }
\DoxyCodeLine{8892             size = \textcolor{keyword}{sizeof}(info);}
\DoxyCodeLine{8893             \textcolor{keywordflow}{if}( sysctl(mib, \textcolor{keyword}{sizeof}(mib) / \textcolor{keyword}{sizeof}(*mib), \&info, \&size, CATCH\_NULL, 0) != 0 ) \{}
\DoxyCodeLine{8894                 Catch::cerr() << \textcolor{stringliteral}{"{}\(\backslash\)n** Call to sysctl failed -\/ unable to determine if debugger is active **\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{8895                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{8896             \}}
\DoxyCodeLine{8897 }
\DoxyCodeLine{8898             \textcolor{comment}{// We're being debugged if the P\_TRACED flag is set.}}
\DoxyCodeLine{8899 }
\DoxyCodeLine{8900             \textcolor{keywordflow}{return} ( (info.kp\_proc.p\_flag \& P\_TRACED) != 0 );}
\DoxyCodeLine{8901         \}}
\DoxyCodeLine{8902     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8903 }
\DoxyCodeLine{8904 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{8905 \textcolor{preprocessor}{    \#include <fstream>}}
\DoxyCodeLine{8906 \textcolor{preprocessor}{    \#include <string>}}
\DoxyCodeLine{8907 }
\DoxyCodeLine{8908     \textcolor{keyword}{namespace }Catch\{}
\DoxyCodeLine{8909         \textcolor{comment}{// The standard POSIX way of detecting a debugger is to attempt to}}
\DoxyCodeLine{8910         \textcolor{comment}{// ptrace() the process, but this needs to be done from a child and not}}
\DoxyCodeLine{8911         \textcolor{comment}{// this process itself to still allow attaching to this process later}}
\DoxyCodeLine{8912         \textcolor{comment}{// if wanted, so is rather heavy. Under Linux we have the PID of the}}
\DoxyCodeLine{8913         \textcolor{comment}{// "{}debugger"{} (which doesn't need to be gdb, of course, it could also}}
\DoxyCodeLine{8914         \textcolor{comment}{// be strace, for example) in /proc/\$PID/status, so just get it from}}
\DoxyCodeLine{8915         \textcolor{comment}{// there instead.}}
\DoxyCodeLine{8916         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{8917             \textcolor{comment}{// Libstdc++ has a bug, where std::ifstream sets errno to 0}}
\DoxyCodeLine{8918             \textcolor{comment}{// This way our users can properly assert over errno values}}
\DoxyCodeLine{8919             ErrnoGuard guard;}
\DoxyCodeLine{8920             std::ifstream in(\textcolor{stringliteral}{"{}/proc/self/status"{}});}
\DoxyCodeLine{8921             \textcolor{keywordflow}{for}( std::string line; std::getline(in, line); ) \{}
\DoxyCodeLine{8922                 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PREFIX\_LEN = 11;}
\DoxyCodeLine{8923                 \textcolor{keywordflow}{if}( line.compare(0, PREFIX\_LEN, \textcolor{stringliteral}{"{}TracerPid:\(\backslash\)t"{}}) == 0 ) \{}
\DoxyCodeLine{8924                     \textcolor{comment}{// We're traced if the PID is not 0 and no other PID starts}}
\DoxyCodeLine{8925                     \textcolor{comment}{// with 0 digit, so it's enough to check for just a single}}
\DoxyCodeLine{8926                     \textcolor{comment}{// character.}}
\DoxyCodeLine{8927                     \textcolor{keywordflow}{return} line.length() > PREFIX\_LEN \&\& line[PREFIX\_LEN] != \textcolor{charliteral}{'0'};}
\DoxyCodeLine{8928                 \}}
\DoxyCodeLine{8929             \}}
\DoxyCodeLine{8930 }
\DoxyCodeLine{8931             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{8932         \}}
\DoxyCodeLine{8933     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8934 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{8935     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{8936     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8937         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{8938             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{8939         \}}
\DoxyCodeLine{8940     \}}
\DoxyCodeLine{8941 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{8942     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{8943     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8944         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{8945             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{8946         \}}
\DoxyCodeLine{8947     \}}
\DoxyCodeLine{8948 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8949     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8950        \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isDebuggerActive() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{8951     \}}
\DoxyCodeLine{8952 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Platform}}
\DoxyCodeLine{8953 }
\DoxyCodeLine{8954 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8955 }
\DoxyCodeLine{8956     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8957         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{8958             ::OutputDebugStringA( text.c\_str() );}
\DoxyCodeLine{8959         \}}
\DoxyCodeLine{8960     \}}
\DoxyCodeLine{8961 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8962     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8963         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{8964             \textcolor{comment}{// !TBD: Need a version for Mac/ XCode and other IDEs}}
\DoxyCodeLine{8965             Catch::cout() << text;}
\DoxyCodeLine{8966         \}}
\DoxyCodeLine{8967     \}}
\DoxyCodeLine{8968 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Platform}}
\DoxyCodeLine{8969 }
\DoxyCodeLine{8970 \textcolor{comment}{// \#included from: catch\_tostring.hpp}}
\DoxyCodeLine{8971 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TOSTRING\_HPP\_INCLUDED}}
\DoxyCodeLine{8972 }
\DoxyCodeLine{8973 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8974 }
\DoxyCodeLine{8975 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{8976 }
\DoxyCodeLine{8977     \textcolor{keyword}{const} std::string unprintableString = \textcolor{stringliteral}{"{}\{?\}"{}};}
\DoxyCodeLine{8978 }
\DoxyCodeLine{8979     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{8980         \textcolor{keyword}{const} \textcolor{keywordtype}{int} hexThreshold = 255;}
\DoxyCodeLine{8981 }
\DoxyCodeLine{8982         \textcolor{keyword}{struct }Endianness \{}
\DoxyCodeLine{8983             \textcolor{keyword}{enum} Arch \{ Big, Little \};}
\DoxyCodeLine{8984 }
\DoxyCodeLine{8985             \textcolor{keyword}{static} Arch which() \{}
\DoxyCodeLine{8986                 \textcolor{keyword}{union }\_\{}
\DoxyCodeLine{8987                     \textcolor{keywordtype}{int} asInt;}
\DoxyCodeLine{8988                     \textcolor{keywordtype}{char} asChar[sizeof (int)];}
\DoxyCodeLine{8989                 \} u;}
\DoxyCodeLine{8990 }
\DoxyCodeLine{8991                 u.asInt = 1;}
\DoxyCodeLine{8992                 \textcolor{keywordflow}{return} ( u.asChar[\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})-\/1] == 1 ) ? Big : Little;}
\DoxyCodeLine{8993             \}}
\DoxyCodeLine{8994         \};}
\DoxyCodeLine{8995     \}}
\DoxyCodeLine{8996 }
\DoxyCodeLine{8997     std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size )}
\DoxyCodeLine{8998     \{}
\DoxyCodeLine{8999         \textcolor{comment}{// Reverse order for little endian architectures}}
\DoxyCodeLine{9000         \textcolor{keywordtype}{int} i = 0, end = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( size ), inc = 1;}
\DoxyCodeLine{9001         \textcolor{keywordflow}{if}( Endianness::which() == Endianness::Little ) \{}
\DoxyCodeLine{9002             i = end-\/1;}
\DoxyCodeLine{9003             end = inc = -\/1;}
\DoxyCodeLine{9004         \}}
\DoxyCodeLine{9005 }
\DoxyCodeLine{9006         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const} *bytes = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(object);}
\DoxyCodeLine{9007         std::ostringstream os;}
\DoxyCodeLine{9008         os << \textcolor{stringliteral}{"{}0x"{}} << std::setfill(\textcolor{charliteral}{'0'}) << std::hex;}
\DoxyCodeLine{9009         \textcolor{keywordflow}{for}( ; i != end; i += inc )}
\DoxyCodeLine{9010              os << std::setw(2) << static\_cast<unsigned>(bytes[i]);}
\DoxyCodeLine{9011        \textcolor{keywordflow}{return} os.str();}
\DoxyCodeLine{9012     \}}
\DoxyCodeLine{9013 \}}
\DoxyCodeLine{9014 }
\DoxyCodeLine{9015 std::string toString( std::string \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{9016     std::string s = value;}
\DoxyCodeLine{9017     \textcolor{keywordflow}{if}( getCurrentContext().getConfig()-\/>showInvisibles() ) \{}
\DoxyCodeLine{9018         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < s.size(); ++i ) \{}
\DoxyCodeLine{9019             std::string subs;}
\DoxyCodeLine{9020             \textcolor{keywordflow}{switch}( s[i] ) \{}
\DoxyCodeLine{9021             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}: subs = \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)n"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{9022             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)t'}: subs = \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)t"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{9023             \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};}
\DoxyCodeLine{9024             \}}
\DoxyCodeLine{9025             \textcolor{keywordflow}{if}( !subs.empty() ) \{}
\DoxyCodeLine{9026                 s = s.substr( 0, i ) + subs + s.substr( i+1 );}
\DoxyCodeLine{9027                 ++i;}
\DoxyCodeLine{9028             \}}
\DoxyCodeLine{9029         \}}
\DoxyCodeLine{9030     \}}
\DoxyCodeLine{9031     \textcolor{keywordflow}{return} \textcolor{charliteral}{'"{}'} + s + '"{}';}
\DoxyCodeLine{9032 \}}
\DoxyCodeLine{9033 std::string toString( std::wstring \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{9034 }
\DoxyCodeLine{9035     std::string s;}
\DoxyCodeLine{9036     s.reserve( value.size() );}
\DoxyCodeLine{9037     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < value.size(); ++i )}
\DoxyCodeLine{9038         s += value[i] <= 0xff ? static\_cast<char>( value[i] ) : '?';}
\DoxyCodeLine{9039     \textcolor{keywordflow}{return} Catch::toString( s );}
\DoxyCodeLine{9040 \}}
\DoxyCodeLine{9041 }
\DoxyCodeLine{9042 std::string toString( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{keyword}{const} value ) \{}
\DoxyCodeLine{9043     \textcolor{keywordflow}{return} value ? Catch::toString( std::string( value ) ) : std::string( \textcolor{stringliteral}{"{}\{null string\}"{}} );}
\DoxyCodeLine{9044 \}}
\DoxyCodeLine{9045 }
\DoxyCodeLine{9046 std::string toString( \textcolor{keywordtype}{char}* \textcolor{keyword}{const} value ) \{}
\DoxyCodeLine{9047     \textcolor{keywordflow}{return} Catch::toString( \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}( value ) );}
\DoxyCodeLine{9048 \}}
\DoxyCodeLine{9049 }
\DoxyCodeLine{9050 std::string toString( \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* \textcolor{keyword}{const} value )}
\DoxyCodeLine{9051 \{}
\DoxyCodeLine{9052     \textcolor{keywordflow}{return} value ? Catch::toString( std::wstring(value) ) : std::string( \textcolor{stringliteral}{"{}\{null string\}"{}} );}
\DoxyCodeLine{9053 \}}
\DoxyCodeLine{9054 }
\DoxyCodeLine{9055 std::string toString( \textcolor{keywordtype}{wchar\_t}* \textcolor{keyword}{const} value )}
\DoxyCodeLine{9056 \{}
\DoxyCodeLine{9057     \textcolor{keywordflow}{return} Catch::toString( \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{wchar\_t}*\textcolor{keyword}{>}( value ) );}
\DoxyCodeLine{9058 \}}
\DoxyCodeLine{9059 }
\DoxyCodeLine{9060 std::string toString( \textcolor{keywordtype}{int} value ) \{}
\DoxyCodeLine{9061     std::ostringstream oss;}
\DoxyCodeLine{9062     oss << value;}
\DoxyCodeLine{9063     \textcolor{keywordflow}{if}( value > Detail::hexThreshold )}
\DoxyCodeLine{9064         oss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{9065     \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{9066 \}}
\DoxyCodeLine{9067 }
\DoxyCodeLine{9068 std::string toString( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value ) \{}
\DoxyCodeLine{9069     std::ostringstream oss;}
\DoxyCodeLine{9070     oss << value;}
\DoxyCodeLine{9071     \textcolor{keywordflow}{if}( value > Detail::hexThreshold )}
\DoxyCodeLine{9072         oss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{9073     \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{9074 \}}
\DoxyCodeLine{9075 }
\DoxyCodeLine{9076 std::string toString( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value ) \{}
\DoxyCodeLine{9077     \textcolor{keywordflow}{return} Catch::toString( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}( value ) );}
\DoxyCodeLine{9078 \}}
\DoxyCodeLine{9079 }
\DoxyCodeLine{9080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9081 std::string fpToString( T value, \textcolor{keywordtype}{int} precision ) \{}
\DoxyCodeLine{9082     std::ostringstream oss;}
\DoxyCodeLine{9083     oss << std::setprecision( precision )}
\DoxyCodeLine{9084         << std::fixed}
\DoxyCodeLine{9085         << value;}
\DoxyCodeLine{9086     std::string d = oss.str();}
\DoxyCodeLine{9087     std::size\_t i = d.find\_last\_not\_of( \textcolor{charliteral}{'0'} );}
\DoxyCodeLine{9088     \textcolor{keywordflow}{if}( i != std::string::npos \&\& i != d.size()-\/1 ) \{}
\DoxyCodeLine{9089         \textcolor{keywordflow}{if}( d[i] == \textcolor{charliteral}{'.'} )}
\DoxyCodeLine{9090             i++;}
\DoxyCodeLine{9091         d = d.substr( 0, i+1 );}
\DoxyCodeLine{9092     \}}
\DoxyCodeLine{9093     \textcolor{keywordflow}{return} d;}
\DoxyCodeLine{9094 \}}
\DoxyCodeLine{9095 }
\DoxyCodeLine{9096 std::string toString( \textcolor{keyword}{const} \textcolor{keywordtype}{double} value ) \{}
\DoxyCodeLine{9097     \textcolor{keywordflow}{return} fpToString( value, 10 );}
\DoxyCodeLine{9098 \}}
\DoxyCodeLine{9099 std::string toString( \textcolor{keyword}{const} \textcolor{keywordtype}{float} value ) \{}
\DoxyCodeLine{9100     \textcolor{keywordflow}{return} fpToString( value, 5 ) + 'f';}
\DoxyCodeLine{9101 \}}
\DoxyCodeLine{9102 }
\DoxyCodeLine{9103 std::string toString( \textcolor{keywordtype}{bool} value ) \{}
\DoxyCodeLine{9104     \textcolor{keywordflow}{return} value ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}};}
\DoxyCodeLine{9105 \}}
\DoxyCodeLine{9106 }
\DoxyCodeLine{9107 std::string toString( \textcolor{keywordtype}{char} value ) \{}
\DoxyCodeLine{9108     \textcolor{keywordflow}{if} ( value == \textcolor{charliteral}{'\(\backslash\)r'} )}
\DoxyCodeLine{9109         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)r'"{}};}
\DoxyCodeLine{9110     \textcolor{keywordflow}{if} ( value == \textcolor{charliteral}{'\(\backslash\)f'} )}
\DoxyCodeLine{9111         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)f'"{}};}
\DoxyCodeLine{9112     \textcolor{keywordflow}{if} ( value == \textcolor{charliteral}{'\(\backslash\)n'} )}
\DoxyCodeLine{9113         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)n'"{}};}
\DoxyCodeLine{9114     \textcolor{keywordflow}{if} ( value == \textcolor{charliteral}{'\(\backslash\)t'} )}
\DoxyCodeLine{9115         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)t'"{}};}
\DoxyCodeLine{9116     \textcolor{keywordflow}{if} ( \textcolor{charliteral}{'\(\backslash\)0'} <= value \&\& value < \textcolor{charliteral}{' '} )}
\DoxyCodeLine{9117         \textcolor{keywordflow}{return} toString( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( value ) );}
\DoxyCodeLine{9118     \textcolor{keywordtype}{char} chstr[] = \textcolor{stringliteral}{"{}' '"{}};}
\DoxyCodeLine{9119     chstr[1] = value;}
\DoxyCodeLine{9120     \textcolor{keywordflow}{return} chstr;}
\DoxyCodeLine{9121 \}}
\DoxyCodeLine{9122 }
\DoxyCodeLine{9123 std::string toString( \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} value ) \{}
\DoxyCodeLine{9124     \textcolor{keywordflow}{return} toString( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( value ) );}
\DoxyCodeLine{9125 \}}
\DoxyCodeLine{9126 }
\DoxyCodeLine{9127 std::string toString( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} value ) \{}
\DoxyCodeLine{9128     \textcolor{keywordflow}{return} toString( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( value ) );}
\DoxyCodeLine{9129 \}}
\DoxyCodeLine{9130 }
\DoxyCodeLine{9131 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_LONG\_LONG}}
\DoxyCodeLine{9132 std::string toString( \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value ) \{}
\DoxyCodeLine{9133     std::ostringstream oss;}
\DoxyCodeLine{9134     oss << value;}
\DoxyCodeLine{9135     \textcolor{keywordflow}{if}( value > Detail::hexThreshold )}
\DoxyCodeLine{9136         oss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{9137     \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{9138 \}}
\DoxyCodeLine{9139 std::string toString( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value ) \{}
\DoxyCodeLine{9140     std::ostringstream oss;}
\DoxyCodeLine{9141     oss << value;}
\DoxyCodeLine{9142     \textcolor{keywordflow}{if}( value > Detail::hexThreshold )}
\DoxyCodeLine{9143         oss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{9144     \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{9145 \}}
\DoxyCodeLine{9146 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9147 }
\DoxyCodeLine{9148 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP11\_NULLPTR}}
\DoxyCodeLine{9149 std::string toString( std::nullptr\_t ) \{}
\DoxyCodeLine{9150     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{9151 \}}
\DoxyCodeLine{9152 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9153 }
\DoxyCodeLine{9154 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{9155     std::string toString( NSString \textcolor{keyword}{const} * \textcolor{keyword}{const}\& nsstring ) \{}
\DoxyCodeLine{9156         \textcolor{keywordflow}{if}( !nsstring )}
\DoxyCodeLine{9157             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nil"{}};}
\DoxyCodeLine{9158         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}@"{}} + toString([nsstring UTF8String]);}
\DoxyCodeLine{9159     \}}
\DoxyCodeLine{9160     std::string toString( NSString * CATCH\_ARC\_STRONG \& nsstring ) \{}
\DoxyCodeLine{9161         \textcolor{keywordflow}{if}( !nsstring )}
\DoxyCodeLine{9162             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nil"{}};}
\DoxyCodeLine{9163         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}@"{}} + toString([nsstring UTF8String]);}
\DoxyCodeLine{9164     \}}
\DoxyCodeLine{9165     std::string toString( NSObject* \textcolor{keyword}{const}\& nsObject ) \{}
\DoxyCodeLine{9166         \textcolor{keywordflow}{return} toString( [nsObject description] );}
\DoxyCodeLine{9167     \}}
\DoxyCodeLine{9168 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9169 }
\DoxyCodeLine{9170 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9171 }
\DoxyCodeLine{9172 \textcolor{comment}{// \#included from: catch\_result\_builder.hpp}}
\DoxyCodeLine{9173 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_RESULT\_BUILDER\_HPP\_INCLUDED}}
\DoxyCodeLine{9174 }
\DoxyCodeLine{9175 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{9176 }
\DoxyCodeLine{9177 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9178 }
\DoxyCodeLine{9179     ResultBuilder::ResultBuilder(   \textcolor{keywordtype}{char} \textcolor{keyword}{const}* macroName,}
\DoxyCodeLine{9180                                     SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{9181                                     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* capturedExpression,}
\DoxyCodeLine{9182                                     ResultDisposition::Flags resultDisposition,}
\DoxyCodeLine{9183                                     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* secondArg )}
\DoxyCodeLine{9184     :   m\_assertionInfo( macroName, lineInfo, capturedExpression, resultDisposition, secondArg ),}
\DoxyCodeLine{9185         m\_shouldDebugBreak( false ),}
\DoxyCodeLine{9186         m\_shouldThrow( false ),}
\DoxyCodeLine{9187         m\_guardException( false ),}
\DoxyCodeLine{9188         m\_usedStream( false )}
\DoxyCodeLine{9189     \{\}}
\DoxyCodeLine{9190 }
\DoxyCodeLine{9191     ResultBuilder::\string~ResultBuilder() \{}
\DoxyCodeLine{9192 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE)}}
\DoxyCodeLine{9193         \textcolor{keywordflow}{if} ( m\_guardException ) \{}
\DoxyCodeLine{9194             stream().oss << \textcolor{stringliteral}{"{}Exception translation was disabled by CATCH\_CONFIG\_FAST\_COMPILE"{}};}
\DoxyCodeLine{9195             captureResult( ResultWas::ThrewException );}
\DoxyCodeLine{9196             getCurrentContext().getResultCapture()-\/>exceptionEarlyReported();}
\DoxyCodeLine{9197         \}}
\DoxyCodeLine{9198 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9199     \}}
\DoxyCodeLine{9200 }
\DoxyCodeLine{9201     ResultBuilder\& ResultBuilder::setResultType( ResultWas::OfType result ) \{}
\DoxyCodeLine{9202         m\_data.resultType = result;}
\DoxyCodeLine{9203         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9204     \}}
\DoxyCodeLine{9205     ResultBuilder\& ResultBuilder::setResultType( \textcolor{keywordtype}{bool} result ) \{}
\DoxyCodeLine{9206         m\_data.resultType = result ? ResultWas::Ok : ResultWas::ExpressionFailed;}
\DoxyCodeLine{9207         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9208     \}}
\DoxyCodeLine{9209 }
\DoxyCodeLine{9210     \textcolor{keywordtype}{void} ResultBuilder::endExpression( DecomposedExpression \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{9211         \textcolor{comment}{// Flip bool results if FalseTest flag is set}}
\DoxyCodeLine{9212         \textcolor{keywordflow}{if}( isFalseTest( m\_assertionInfo.resultDisposition ) ) \{}
\DoxyCodeLine{9213             m\_data.negate( expr.isBinaryExpression() );}
\DoxyCodeLine{9214         \}}
\DoxyCodeLine{9215 }
\DoxyCodeLine{9216         getResultCapture().assertionRun();}
\DoxyCodeLine{9217 }
\DoxyCodeLine{9218         \textcolor{keywordflow}{if}(getCurrentContext().getConfig()-\/>includeSuccessfulResults() || m\_data.resultType != ResultWas::Ok)}
\DoxyCodeLine{9219         \{}
\DoxyCodeLine{9220             AssertionResult result = build( expr );}
\DoxyCodeLine{9221             handleResult( result );}
\DoxyCodeLine{9222         \}}
\DoxyCodeLine{9223         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9224             getResultCapture().assertionPassed();}
\DoxyCodeLine{9225     \}}
\DoxyCodeLine{9226 }
\DoxyCodeLine{9227     \textcolor{keywordtype}{void} ResultBuilder::useActiveException( ResultDisposition::Flags resultDisposition ) \{}
\DoxyCodeLine{9228         m\_assertionInfo.resultDisposition = resultDisposition;}
\DoxyCodeLine{9229         stream().oss << Catch::translateActiveException();}
\DoxyCodeLine{9230         captureResult( ResultWas::ThrewException );}
\DoxyCodeLine{9231     \}}
\DoxyCodeLine{9232 }
\DoxyCodeLine{9233     \textcolor{keywordtype}{void} ResultBuilder::captureResult( ResultWas::OfType resultType ) \{}
\DoxyCodeLine{9234         setResultType( resultType );}
\DoxyCodeLine{9235         captureExpression();}
\DoxyCodeLine{9236     \}}
\DoxyCodeLine{9237 }
\DoxyCodeLine{9238     \textcolor{keywordtype}{void} ResultBuilder::captureExpectedException( std::string \textcolor{keyword}{const}\& expectedMessage ) \{}
\DoxyCodeLine{9239         \textcolor{keywordflow}{if}( expectedMessage.empty() )}
\DoxyCodeLine{9240             captureExpectedException( Matchers::Impl::MatchAllOf<std::string>() );}
\DoxyCodeLine{9241         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9242             captureExpectedException( Matchers::Equals( expectedMessage ) );}
\DoxyCodeLine{9243     \}}
\DoxyCodeLine{9244 }
\DoxyCodeLine{9245     \textcolor{keywordtype}{void} ResultBuilder::captureExpectedException( Matchers::Impl::MatcherBase<std::string> \textcolor{keyword}{const}\& matcher ) \{}
\DoxyCodeLine{9246 }
\DoxyCodeLine{9247         assert( !isFalseTest( m\_assertionInfo.resultDisposition ) );}
\DoxyCodeLine{9248         AssertionResultData data = m\_data;}
\DoxyCodeLine{9249         data.resultType = ResultWas::Ok;}
\DoxyCodeLine{9250         data.reconstructedExpression = capturedExpressionWithSecondArgument(m\_assertionInfo.capturedExpression, m\_assertionInfo.secondArg);}
\DoxyCodeLine{9251 }
\DoxyCodeLine{9252         std::string actualMessage = Catch::translateActiveException();}
\DoxyCodeLine{9253         \textcolor{keywordflow}{if}( !matcher.match( actualMessage ) ) \{}
\DoxyCodeLine{9254             data.resultType = ResultWas::ExpressionFailed;}
\DoxyCodeLine{9255             data.reconstructedExpression = actualMessage;}
\DoxyCodeLine{9256         \}}
\DoxyCodeLine{9257         AssertionResult result( m\_assertionInfo, data );}
\DoxyCodeLine{9258         handleResult( result );}
\DoxyCodeLine{9259     \}}
\DoxyCodeLine{9260 }
\DoxyCodeLine{9261     \textcolor{keywordtype}{void} ResultBuilder::captureExpression() \{}
\DoxyCodeLine{9262         AssertionResult result = build();}
\DoxyCodeLine{9263         handleResult( result );}
\DoxyCodeLine{9264     \}}
\DoxyCodeLine{9265 }
\DoxyCodeLine{9266     \textcolor{keywordtype}{void} ResultBuilder::handleResult( AssertionResult \textcolor{keyword}{const}\& result )}
\DoxyCodeLine{9267     \{}
\DoxyCodeLine{9268         getResultCapture().assertionEnded( result );}
\DoxyCodeLine{9269 }
\DoxyCodeLine{9270         \textcolor{keywordflow}{if}( !result.isOk() ) \{}
\DoxyCodeLine{9271             \textcolor{keywordflow}{if}( getCurrentContext().getConfig()-\/>shouldDebugBreak() )}
\DoxyCodeLine{9272                 m\_shouldDebugBreak = \textcolor{keyword}{true};}
\DoxyCodeLine{9273             \textcolor{keywordflow}{if}( getCurrentContext().getRunner()-\/>aborting() || (m\_assertionInfo.resultDisposition \& ResultDisposition::Normal) )}
\DoxyCodeLine{9274                 m\_shouldThrow = \textcolor{keyword}{true};}
\DoxyCodeLine{9275         \}}
\DoxyCodeLine{9276     \}}
\DoxyCodeLine{9277 }
\DoxyCodeLine{9278     \textcolor{keywordtype}{void} ResultBuilder::react() \{}
\DoxyCodeLine{9279 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE)}}
\DoxyCodeLine{9280         \textcolor{keywordflow}{if} (m\_shouldDebugBreak) \{}
\DoxyCodeLine{9282             \textcolor{comment}{// To inspect the state during test, you need to go one level up the callstack}}
\DoxyCodeLine{9283             \textcolor{comment}{// To go back to the test and change execution, jump over the throw statement}}
\DoxyCodeLine{9285 \textcolor{comment}{}            CATCH\_BREAK\_INTO\_DEBUGGER();}
\DoxyCodeLine{9286         \}}
\DoxyCodeLine{9287 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9288         \textcolor{keywordflow}{if}( m\_shouldThrow )}
\DoxyCodeLine{9289             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structCatch_1_1TestFailureException}{Catch::TestFailureException}}();}
\DoxyCodeLine{9290     \}}
\DoxyCodeLine{9291 }
\DoxyCodeLine{9292     \textcolor{keywordtype}{bool} ResultBuilder::shouldDebugBreak()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_shouldDebugBreak; \}}
\DoxyCodeLine{9293     \textcolor{keywordtype}{bool} ResultBuilder::allowThrows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} getCurrentContext().getConfig()-\/>allowThrows(); \}}
\DoxyCodeLine{9294 }
\DoxyCodeLine{9295     AssertionResult ResultBuilder::build()\textcolor{keyword}{ const}}
\DoxyCodeLine{9296 \textcolor{keyword}{    }\{}
\DoxyCodeLine{9297         \textcolor{keywordflow}{return} build( *\textcolor{keyword}{this} );}
\DoxyCodeLine{9298     \}}
\DoxyCodeLine{9299 }
\DoxyCodeLine{9300     \textcolor{comment}{// CAVEAT: The returned AssertionResult stores a pointer to the argument expr,}}
\DoxyCodeLine{9301     \textcolor{comment}{//         a temporary DecomposedExpression, which in turn holds references to}}
\DoxyCodeLine{9302     \textcolor{comment}{//         operands, possibly temporary as well.}}
\DoxyCodeLine{9303     \textcolor{comment}{//         It should immediately be passed to handleResult; if the expression}}
\DoxyCodeLine{9304     \textcolor{comment}{//         needs to be reported, its string expansion must be composed before}}
\DoxyCodeLine{9305     \textcolor{comment}{//         the temporaries are destroyed.}}
\DoxyCodeLine{9306     AssertionResult ResultBuilder::build( DecomposedExpression \textcolor{keyword}{const}\& expr )\textcolor{keyword}{ const}}
\DoxyCodeLine{9307 \textcolor{keyword}{    }\{}
\DoxyCodeLine{9308         assert( m\_data.resultType != ResultWas::Unknown );}
\DoxyCodeLine{9309         AssertionResultData data = m\_data;}
\DoxyCodeLine{9310 }
\DoxyCodeLine{9311         \textcolor{keywordflow}{if}(m\_usedStream)}
\DoxyCodeLine{9312             data.message = m\_stream().oss.str();}
\DoxyCodeLine{9313         data.decomposedExpression = \&expr; \textcolor{comment}{// for lazy reconstruction}}
\DoxyCodeLine{9314         \textcolor{keywordflow}{return} AssertionResult( m\_assertionInfo, data );}
\DoxyCodeLine{9315     \}}
\DoxyCodeLine{9316 }
\DoxyCodeLine{9317     \textcolor{keywordtype}{void} ResultBuilder::reconstructExpression( std::string\& dest )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9318         dest = capturedExpressionWithSecondArgument(m\_assertionInfo.capturedExpression, m\_assertionInfo.secondArg);}
\DoxyCodeLine{9319     \}}
\DoxyCodeLine{9320 }
\DoxyCodeLine{9321     \textcolor{keywordtype}{void} ResultBuilder::setExceptionGuard() \{}
\DoxyCodeLine{9322         m\_guardException = \textcolor{keyword}{true};}
\DoxyCodeLine{9323     \}}
\DoxyCodeLine{9324     \textcolor{keywordtype}{void} ResultBuilder::unsetExceptionGuard() \{}
\DoxyCodeLine{9325         m\_guardException = \textcolor{keyword}{false};}
\DoxyCodeLine{9326     \}}
\DoxyCodeLine{9327 }
\DoxyCodeLine{9328 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9329 }
\DoxyCodeLine{9330 \textcolor{comment}{// \#included from: catch\_tag\_alias\_registry.hpp}}
\DoxyCodeLine{9331 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_TAG\_ALIAS\_REGISTRY\_HPP\_INCLUDED}}
\DoxyCodeLine{9332 }
\DoxyCodeLine{9333 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9334 }
\DoxyCodeLine{9335     TagAliasRegistry::\string~TagAliasRegistry() \{\}}
\DoxyCodeLine{9336 }
\DoxyCodeLine{9337     Option<TagAlias> TagAliasRegistry::find( std::string \textcolor{keyword}{const}\& alias )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9338         std::map<std::string, TagAlias>::const\_iterator it = m\_registry.find( alias );}
\DoxyCodeLine{9339         \textcolor{keywordflow}{if}( it != m\_registry.end() )}
\DoxyCodeLine{9340             \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{9341         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9342             \textcolor{keywordflow}{return} Option<TagAlias>();}
\DoxyCodeLine{9343     \}}
\DoxyCodeLine{9344 }
\DoxyCodeLine{9345     std::string TagAliasRegistry::expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9346         std::string expandedTestSpec = unexpandedTestSpec;}
\DoxyCodeLine{9347         \textcolor{keywordflow}{for}( std::map<std::string, TagAlias>::const\_iterator it = m\_registry.begin(), itEnd = m\_registry.end();}
\DoxyCodeLine{9348                 it != itEnd;}
\DoxyCodeLine{9349                 ++it ) \{}
\DoxyCodeLine{9350             std::size\_t pos = expandedTestSpec.find( it-\/>first );}
\DoxyCodeLine{9351             \textcolor{keywordflow}{if}( pos != std::string::npos ) \{}
\DoxyCodeLine{9352                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +}
\DoxyCodeLine{9353                                     it-\/>second.tag +}
\DoxyCodeLine{9354                                     expandedTestSpec.substr( pos + it-\/>first.size() );}
\DoxyCodeLine{9355             \}}
\DoxyCodeLine{9356         \}}
\DoxyCodeLine{9357         \textcolor{keywordflow}{return} expandedTestSpec;}
\DoxyCodeLine{9358     \}}
\DoxyCodeLine{9359 }
\DoxyCodeLine{9360     \textcolor{keywordtype}{void} TagAliasRegistry::add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) \{}
\DoxyCodeLine{9361 }
\DoxyCodeLine{9362         \textcolor{keywordflow}{if}( !startsWith( alias, \textcolor{stringliteral}{"{}[@"{}} ) || !endsWith( alias, \textcolor{charliteral}{']'} ) ) \{}
\DoxyCodeLine{9363             std::ostringstream oss;}
\DoxyCodeLine{9364             oss << Colour( Colour::Red )}
\DoxyCodeLine{9365                 << \textcolor{stringliteral}{"{}error: tag alias, \(\backslash\)"{}"{}} << alias << \textcolor{stringliteral}{"{}\(\backslash\)"{} is not of the form [@alias name].\(\backslash\)n"{}}}
\DoxyCodeLine{9366                 << Colour( Colour::FileName )}
\DoxyCodeLine{9367                 << lineInfo << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{9368             \textcolor{keywordflow}{throw} std::domain\_error( oss.str().c\_str() );}
\DoxyCodeLine{9369         \}}
\DoxyCodeLine{9370         \textcolor{keywordflow}{if}( !m\_registry.insert( std::make\_pair( alias, TagAlias( tag, lineInfo ) ) ).second ) \{}
\DoxyCodeLine{9371             std::ostringstream oss;}
\DoxyCodeLine{9372             oss << Colour( Colour::Red )}
\DoxyCodeLine{9373                 << \textcolor{stringliteral}{"{}error: tag alias, \(\backslash\)"{}"{}} << alias << \textcolor{stringliteral}{"{}\(\backslash\)"{} already registered.\(\backslash\)n"{}}}
\DoxyCodeLine{9374                 << \textcolor{stringliteral}{"{}\(\backslash\)tFirst seen at "{}}}
\DoxyCodeLine{9375                 << Colour( Colour::Red ) << find(alias)-\/>lineInfo << \textcolor{charliteral}{'\(\backslash\)n'}}
\DoxyCodeLine{9376                 << Colour( Colour::Red ) << \textcolor{stringliteral}{"{}\(\backslash\)tRedefined at "{}}}
\DoxyCodeLine{9377                 << Colour( Colour::FileName) << lineInfo << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{9378             \textcolor{keywordflow}{throw} std::domain\_error( oss.str().c\_str() );}
\DoxyCodeLine{9379         \}}
\DoxyCodeLine{9380     \}}
\DoxyCodeLine{9381 }
\DoxyCodeLine{9382     ITagAliasRegistry::\string~ITagAliasRegistry() \{\}}
\DoxyCodeLine{9383 }
\DoxyCodeLine{9384     ITagAliasRegistry \textcolor{keyword}{const}\& ITagAliasRegistry::get() \{}
\DoxyCodeLine{9385         \textcolor{keywordflow}{return} getRegistryHub().getTagAliasRegistry();}
\DoxyCodeLine{9386     \}}
\DoxyCodeLine{9387 }
\DoxyCodeLine{9388     RegistrarForTagAliases::RegistrarForTagAliases( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) \{}
\DoxyCodeLine{9389         getMutableRegistryHub().registerTagAlias( alias, tag, lineInfo );}
\DoxyCodeLine{9390     \}}
\DoxyCodeLine{9391 }
\DoxyCodeLine{9392 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9393 }
\DoxyCodeLine{9394 \textcolor{comment}{// \#included from: catch\_matchers\_string.hpp}}
\DoxyCodeLine{9395 }
\DoxyCodeLine{9396 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9397 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{9398 }
\DoxyCodeLine{9399     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{9400 }
\DoxyCodeLine{9401         CasedString::CasedString( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{9402         :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{9403             m\_str( adjustString( str ) )}
\DoxyCodeLine{9404         \{\}}
\DoxyCodeLine{9405         std::string CasedString::adjustString( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9406             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{9407                    ? toLower( str )}
\DoxyCodeLine{9408                    : str;}
\DoxyCodeLine{9409         \}}
\DoxyCodeLine{9410         std::string CasedString::caseSensitivitySuffix()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9411             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{9412                    ? \textcolor{stringliteral}{"{} (case insensitive)"{}}}
\DoxyCodeLine{9413                    : std::string();}
\DoxyCodeLine{9414         \}}
\DoxyCodeLine{9415 }
\DoxyCodeLine{9416         StringMatcherBase::StringMatcherBase( std::string \textcolor{keyword}{const}\& operation, CasedString \textcolor{keyword}{const}\& comparator )}
\DoxyCodeLine{9417         : m\_comparator( comparator ),}
\DoxyCodeLine{9418           m\_operation( operation ) \{}
\DoxyCodeLine{9419         \}}
\DoxyCodeLine{9420 }
\DoxyCodeLine{9421         std::string StringMatcherBase::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9422             std::string description;}
\DoxyCodeLine{9423             description.reserve(5 + m\_operation.size() + m\_comparator.m\_str.size() +}
\DoxyCodeLine{9424                                         m\_comparator.caseSensitivitySuffix().size());}
\DoxyCodeLine{9425             description += m\_operation;}
\DoxyCodeLine{9426             description += "{}: \(\backslash\)"{}"{};}
\DoxyCodeLine{9427             description += m\_comparator.m\_str;}
\DoxyCodeLine{9428             description += "{}\(\backslash\)"{}"{};}
\DoxyCodeLine{9429             description += m\_comparator.caseSensitivitySuffix();}
\DoxyCodeLine{9430             \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{9431         \}}
\DoxyCodeLine{9432 }
\DoxyCodeLine{9433         EqualsMatcher::EqualsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}equals"{}}, comparator ) \{\}}
\DoxyCodeLine{9434 }
\DoxyCodeLine{9435         \textcolor{keywordtype}{bool} EqualsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9436             \textcolor{keywordflow}{return} m\_comparator.adjustString( source ) == m\_comparator.m\_str;}
\DoxyCodeLine{9437         \}}
\DoxyCodeLine{9438 }
\DoxyCodeLine{9439         ContainsMatcher::ContainsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}contains"{}}, comparator ) \{\}}
\DoxyCodeLine{9440 }
\DoxyCodeLine{9441         \textcolor{keywordtype}{bool} ContainsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9442             \textcolor{keywordflow}{return} contains( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{9443         \}}
\DoxyCodeLine{9444 }
\DoxyCodeLine{9445         StartsWithMatcher::StartsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}starts with"{}}, comparator ) \{\}}
\DoxyCodeLine{9446 }
\DoxyCodeLine{9447         \textcolor{keywordtype}{bool} StartsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9448             \textcolor{keywordflow}{return} startsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{9449         \}}
\DoxyCodeLine{9450 }
\DoxyCodeLine{9451         EndsWithMatcher::EndsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}ends with"{}}, comparator ) \{\}}
\DoxyCodeLine{9452 }
\DoxyCodeLine{9453         \textcolor{keywordtype}{bool} EndsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9454             \textcolor{keywordflow}{return} endsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{9455         \}}
\DoxyCodeLine{9456 }
\DoxyCodeLine{9457     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{9458 }
\DoxyCodeLine{9459     StdString::EqualsMatcher Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{9460         \textcolor{keywordflow}{return} StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{9461     \}}
\DoxyCodeLine{9462     StdString::ContainsMatcher Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{9463         \textcolor{keywordflow}{return} StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{9464     \}}
\DoxyCodeLine{9465     StdString::EndsWithMatcher EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{9466         \textcolor{keywordflow}{return} StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{9467     \}}
\DoxyCodeLine{9468     StdString::StartsWithMatcher StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{9469         \textcolor{keywordflow}{return} StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{9470     \}}
\DoxyCodeLine{9471 }
\DoxyCodeLine{9472 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{9473 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{9474 \textcolor{comment}{// \#included from: ../reporters/catch\_reporter\_multi.hpp}}
\DoxyCodeLine{9475 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REPORTER\_MULTI\_HPP\_INCLUDED}}
\DoxyCodeLine{9476 }
\DoxyCodeLine{9477 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9478 }
\DoxyCodeLine{9479 \textcolor{keyword}{class }MultipleReporters : \textcolor{keyword}{public} SharedImpl<IStreamingReporter> \{}
\DoxyCodeLine{9480     \textcolor{keyword}{typedef} std::vector<Ptr<IStreamingReporter> > Reporters;}
\DoxyCodeLine{9481     Reporters m\_reporters;}
\DoxyCodeLine{9482 }
\DoxyCodeLine{9483 \textcolor{keyword}{public}:}
\DoxyCodeLine{9484     \textcolor{keywordtype}{void} add( Ptr<IStreamingReporter> \textcolor{keyword}{const}\& reporter ) \{}
\DoxyCodeLine{9485         m\_reporters.push\_back( reporter );}
\DoxyCodeLine{9486     \}}
\DoxyCodeLine{9487 }
\DoxyCodeLine{9488 \textcolor{keyword}{public}: \textcolor{comment}{// IStreamingReporter}}
\DoxyCodeLine{9489 }
\DoxyCodeLine{9490     \textcolor{keyword}{virtual} ReporterPreferences getPreferences() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{9491         \textcolor{keywordflow}{return} m\_reporters[0]-\/>getPreferences();}
\DoxyCodeLine{9492     \}}
\DoxyCodeLine{9493 }
\DoxyCodeLine{9494     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9495         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9496                 it != itEnd;}
\DoxyCodeLine{9497                 ++it )}
\DoxyCodeLine{9498             (*it)-\/>noMatchingTestCases( spec );}
\DoxyCodeLine{9499     \}}
\DoxyCodeLine{9500 }
\DoxyCodeLine{9501     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9502         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9503                 it != itEnd;}
\DoxyCodeLine{9504                 ++it )}
\DoxyCodeLine{9505             (*it)-\/>testRunStarting( testRunInfo );}
\DoxyCodeLine{9506     \}}
\DoxyCodeLine{9507 }
\DoxyCodeLine{9508     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9509         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9510                 it != itEnd;}
\DoxyCodeLine{9511                 ++it )}
\DoxyCodeLine{9512             (*it)-\/>testGroupStarting( groupInfo );}
\DoxyCodeLine{9513     \}}
\DoxyCodeLine{9514 }
\DoxyCodeLine{9515     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9516         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9517                 it != itEnd;}
\DoxyCodeLine{9518                 ++it )}
\DoxyCodeLine{9519             (*it)-\/>testCaseStarting( testInfo );}
\DoxyCodeLine{9520     \}}
\DoxyCodeLine{9521 }
\DoxyCodeLine{9522     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9523         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9524                 it != itEnd;}
\DoxyCodeLine{9525                 ++it )}
\DoxyCodeLine{9526             (*it)-\/>sectionStarting( sectionInfo );}
\DoxyCodeLine{9527     \}}
\DoxyCodeLine{9528 }
\DoxyCodeLine{9529     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9530         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9531                 it != itEnd;}
\DoxyCodeLine{9532                 ++it )}
\DoxyCodeLine{9533             (*it)-\/>assertionStarting( assertionInfo );}
\DoxyCodeLine{9534     \}}
\DoxyCodeLine{9535 }
\DoxyCodeLine{9536     \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{9537     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9538         \textcolor{keywordtype}{bool} clearBuffer = \textcolor{keyword}{false};}
\DoxyCodeLine{9539         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9540                 it != itEnd;}
\DoxyCodeLine{9541                 ++it )}
\DoxyCodeLine{9542             clearBuffer |= (*it)-\/>assertionEnded( assertionStats );}
\DoxyCodeLine{9543         \textcolor{keywordflow}{return} clearBuffer;}
\DoxyCodeLine{9544     \}}
\DoxyCodeLine{9545 }
\DoxyCodeLine{9546     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9547         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9548                 it != itEnd;}
\DoxyCodeLine{9549                 ++it )}
\DoxyCodeLine{9550             (*it)-\/>sectionEnded( sectionStats );}
\DoxyCodeLine{9551     \}}
\DoxyCodeLine{9552 }
\DoxyCodeLine{9553     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9554         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9555                 it != itEnd;}
\DoxyCodeLine{9556                 ++it )}
\DoxyCodeLine{9557             (*it)-\/>testCaseEnded( testCaseStats );}
\DoxyCodeLine{9558     \}}
\DoxyCodeLine{9559 }
\DoxyCodeLine{9560     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9561         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9562                 it != itEnd;}
\DoxyCodeLine{9563                 ++it )}
\DoxyCodeLine{9564             (*it)-\/>testGroupEnded( testGroupStats );}
\DoxyCodeLine{9565     \}}
\DoxyCodeLine{9566 }
\DoxyCodeLine{9567     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9568         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9569                 it != itEnd;}
\DoxyCodeLine{9570                 ++it )}
\DoxyCodeLine{9571             (*it)-\/>testRunEnded( testRunStats );}
\DoxyCodeLine{9572     \}}
\DoxyCodeLine{9573 }
\DoxyCodeLine{9574     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9575         \textcolor{keywordflow}{for}( Reporters::const\_iterator it = m\_reporters.begin(), itEnd = m\_reporters.end();}
\DoxyCodeLine{9576                 it != itEnd;}
\DoxyCodeLine{9577                 ++it )}
\DoxyCodeLine{9578             (*it)-\/>skipTest( testInfo );}
\DoxyCodeLine{9579     \}}
\DoxyCodeLine{9580 }
\DoxyCodeLine{9581     \textcolor{keyword}{virtual} MultipleReporters* tryAsMulti() CATCH\_OVERRIDE \{}
\DoxyCodeLine{9582         \textcolor{keywordflow}{return} \textcolor{keyword}{this};}
\DoxyCodeLine{9583     \}}
\DoxyCodeLine{9584 }
\DoxyCodeLine{9585 \};}
\DoxyCodeLine{9586 }
\DoxyCodeLine{9587 Ptr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> \textcolor{keyword}{const}\& existingReporter, Ptr<IStreamingReporter> \textcolor{keyword}{const}\& additionalReporter ) \{}
\DoxyCodeLine{9588     Ptr<IStreamingReporter> resultingReporter;}
\DoxyCodeLine{9589 }
\DoxyCodeLine{9590     \textcolor{keywordflow}{if}( existingReporter ) \{}
\DoxyCodeLine{9591         MultipleReporters* multi = existingReporter-\/>tryAsMulti();}
\DoxyCodeLine{9592         \textcolor{keywordflow}{if}( !multi ) \{}
\DoxyCodeLine{9593             multi = \textcolor{keyword}{new} MultipleReporters;}
\DoxyCodeLine{9594             resultingReporter = Ptr<IStreamingReporter>( multi );}
\DoxyCodeLine{9595             \textcolor{keywordflow}{if}( existingReporter )}
\DoxyCodeLine{9596                 multi-\/>add( existingReporter );}
\DoxyCodeLine{9597         \}}
\DoxyCodeLine{9598         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9599             resultingReporter = existingReporter;}
\DoxyCodeLine{9600         multi-\/>add( additionalReporter );}
\DoxyCodeLine{9601     \}}
\DoxyCodeLine{9602     \textcolor{keywordflow}{else}}
\DoxyCodeLine{9603         resultingReporter = additionalReporter;}
\DoxyCodeLine{9604 }
\DoxyCodeLine{9605     \textcolor{keywordflow}{return} resultingReporter;}
\DoxyCodeLine{9606 \}}
\DoxyCodeLine{9607 }
\DoxyCodeLine{9608 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9609 }
\DoxyCodeLine{9610 \textcolor{comment}{// \#included from: ../reporters/catch\_reporter\_xml.hpp}}
\DoxyCodeLine{9611 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REPORTER\_XML\_HPP\_INCLUDED}}
\DoxyCodeLine{9612 }
\DoxyCodeLine{9613 \textcolor{comment}{// \#included from: catch\_reporter\_bases.hpp}}
\DoxyCodeLine{9614 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REPORTER\_BASES\_HPP\_INCLUDED}}
\DoxyCodeLine{9615 }
\DoxyCodeLine{9616 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{9617 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{9618 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{9619 \textcolor{preprocessor}{\#include <assert.h>}}
\DoxyCodeLine{9620 }
\DoxyCodeLine{9621 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9622 }
\DoxyCodeLine{9623     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{9624         \textcolor{comment}{// Because formatting using c++ streams is stateful, drop down to C is required}}
\DoxyCodeLine{9625         \textcolor{comment}{// Alternatively we could use stringstream, but its performance is... not good.}}
\DoxyCodeLine{9626         std::string getFormattedDuration( \textcolor{keywordtype}{double} duration ) \{}
\DoxyCodeLine{9627             \textcolor{comment}{// Max exponent + 1 is required to represent the whole part}}
\DoxyCodeLine{9628             \textcolor{comment}{// + 1 for decimal point}}
\DoxyCodeLine{9629             \textcolor{comment}{// + 3 for the 3 decimal places}}
\DoxyCodeLine{9630             \textcolor{comment}{// + 1 for null terminator}}
\DoxyCodeLine{9631             \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} maxDoubleSize = DBL\_MAX\_10\_EXP + 1 + 1 + 3 + 1;}
\DoxyCodeLine{9632             \textcolor{keywordtype}{char} buffer[maxDoubleSize];}
\DoxyCodeLine{9633 }
\DoxyCodeLine{9634             \textcolor{comment}{// Save previous errno, to prevent sprintf from overwriting it}}
\DoxyCodeLine{9635             ErrnoGuard guard;}
\DoxyCodeLine{9636 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{9637             sprintf\_s(buffer, \textcolor{stringliteral}{"{}\%.3f"{}}, duration);}
\DoxyCodeLine{9638 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{9639             sprintf(buffer, \textcolor{stringliteral}{"{}\%.3f"{}}, duration);}
\DoxyCodeLine{9640 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9641             \textcolor{keywordflow}{return} std::string(buffer);}
\DoxyCodeLine{9642         \}}
\DoxyCodeLine{9643     \}}
\DoxyCodeLine{9644 }
\DoxyCodeLine{9645     \textcolor{keyword}{struct }StreamingReporterBase : SharedImpl<IStreamingReporter> \{}
\DoxyCodeLine{9646 }
\DoxyCodeLine{9647         StreamingReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{9648         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{9649             stream( \_config.stream() )}
\DoxyCodeLine{9650         \{}
\DoxyCodeLine{9651             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{9652         \}}
\DoxyCodeLine{9653 }
\DoxyCodeLine{9654         \textcolor{keyword}{virtual} ReporterPreferences getPreferences() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{9655             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{9656         \}}
\DoxyCodeLine{9657 }
\DoxyCodeLine{9658         \textcolor{keyword}{virtual} \string~StreamingReporterBase() CATCH\_OVERRIDE;}
\DoxyCodeLine{9659 }
\DoxyCodeLine{9660         virtual \textcolor{keywordtype}{void} noMatchingTestCases( std::\textcolor{keywordtype}{string} const\& ) CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{9661 }
\DoxyCodeLine{9662         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& \_testRunInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9663             currentTestRunInfo = \_testRunInfo;}
\DoxyCodeLine{9664         \}}
\DoxyCodeLine{9665         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& \_groupInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9666             currentGroupInfo = \_groupInfo;}
\DoxyCodeLine{9667         \}}
\DoxyCodeLine{9668 }
\DoxyCodeLine{9669         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& \_testInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9670             currentTestCaseInfo = \_testInfo;}
\DoxyCodeLine{9671         \}}
\DoxyCodeLine{9672         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& \_sectionInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9673             m\_sectionStack.push\_back( \_sectionInfo );}
\DoxyCodeLine{9674         \}}
\DoxyCodeLine{9675 }
\DoxyCodeLine{9676         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_sectionStats */} ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9677             m\_sectionStack.pop\_back();}
\DoxyCodeLine{9678         \}}
\DoxyCodeLine{9679         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testCaseStats */} ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9680             currentTestCaseInfo.reset();}
\DoxyCodeLine{9681         \}}
\DoxyCodeLine{9682         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testGroupStats */} ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9683             currentGroupInfo.reset();}
\DoxyCodeLine{9684         \}}
\DoxyCodeLine{9685         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testRunStats */} ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9686             currentTestCaseInfo.reset();}
\DoxyCodeLine{9687             currentGroupInfo.reset();}
\DoxyCodeLine{9688             currentTestRunInfo.reset();}
\DoxyCodeLine{9689         \}}
\DoxyCodeLine{9690 }
\DoxyCodeLine{9691         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9692             \textcolor{comment}{// Don't do anything with this by default.}}
\DoxyCodeLine{9693             \textcolor{comment}{// It can optionally be overridden in the derived class.}}
\DoxyCodeLine{9694         \}}
\DoxyCodeLine{9695 }
\DoxyCodeLine{9696         Ptr<IConfig const> m\_config;}
\DoxyCodeLine{9697         std::ostream\& stream;}
\DoxyCodeLine{9698 }
\DoxyCodeLine{9699         LazyStat<TestRunInfo> currentTestRunInfo;}
\DoxyCodeLine{9700         LazyStat<GroupInfo> currentGroupInfo;}
\DoxyCodeLine{9701         LazyStat<TestCaseInfo> currentTestCaseInfo;}
\DoxyCodeLine{9702 }
\DoxyCodeLine{9703         std::vector<SectionInfo> m\_sectionStack;}
\DoxyCodeLine{9704         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{9705     \};}
\DoxyCodeLine{9706 }
\DoxyCodeLine{9707     \textcolor{keyword}{struct }CumulativeReporterBase : SharedImpl<IStreamingReporter> \{}
\DoxyCodeLine{9708         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ChildNodeT>}
\DoxyCodeLine{9709         \textcolor{keyword}{struct }Node : SharedImpl<> \{}
\DoxyCodeLine{9710             \textcolor{keyword}{explicit} Node( T \textcolor{keyword}{const}\& \_value ) : value( \_value ) \{\}}
\DoxyCodeLine{9711             \textcolor{keyword}{virtual} \string~Node() \{\}}
\DoxyCodeLine{9712 }
\DoxyCodeLine{9713             \textcolor{keyword}{typedef} std::vector<Ptr<ChildNodeT> > ChildNodes;}
\DoxyCodeLine{9714             T value;}
\DoxyCodeLine{9715             ChildNodes children;}
\DoxyCodeLine{9716         \};}
\DoxyCodeLine{9717         \textcolor{keyword}{struct }SectionNode : SharedImpl<> \{}
\DoxyCodeLine{9718             \textcolor{keyword}{explicit} SectionNode( SectionStats \textcolor{keyword}{const}\& \_stats ) : stats( \_stats ) \{\}}
\DoxyCodeLine{9719             \textcolor{keyword}{virtual} \string~SectionNode();}
\DoxyCodeLine{9720 }
\DoxyCodeLine{9721             \textcolor{keywordtype}{bool} operator == ( SectionNode \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9722                 \textcolor{keywordflow}{return} stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;}
\DoxyCodeLine{9723             \}}
\DoxyCodeLine{9724             \textcolor{keywordtype}{bool} operator == ( Ptr<SectionNode> \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9725                 \textcolor{keywordflow}{return} operator==( *other );}
\DoxyCodeLine{9726             \}}
\DoxyCodeLine{9727 }
\DoxyCodeLine{9728             SectionStats stats;}
\DoxyCodeLine{9729             \textcolor{keyword}{typedef} std::vector<Ptr<SectionNode> > ChildSections;}
\DoxyCodeLine{9730             \textcolor{keyword}{typedef} std::vector<AssertionStats> Assertions;}
\DoxyCodeLine{9731             ChildSections childSections;}
\DoxyCodeLine{9732             Assertions assertions;}
\DoxyCodeLine{9733             std::string stdOut;}
\DoxyCodeLine{9734             std::string stdErr;}
\DoxyCodeLine{9735         \};}
\DoxyCodeLine{9736 }
\DoxyCodeLine{9737         \textcolor{keyword}{struct }BySectionInfo \{}
\DoxyCodeLine{9738             BySectionInfo( SectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other ) \{\}}
\DoxyCodeLine{9739             BySectionInfo( BySectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other.m\_other ) \{\}}
\DoxyCodeLine{9740             \textcolor{keywordtype}{bool} operator() ( Ptr<SectionNode> \textcolor{keyword}{const}\& node )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9741                 \textcolor{keywordflow}{return} ((node-\/>stats.sectionInfo.name == m\_other.name) \&\&}
\DoxyCodeLine{9742                         (node-\/>stats.sectionInfo.lineInfo == m\_other.lineInfo));}
\DoxyCodeLine{9743             \}}
\DoxyCodeLine{9744         \textcolor{keyword}{private}:}
\DoxyCodeLine{9745             \textcolor{keywordtype}{void} operator=( BySectionInfo \textcolor{keyword}{const}\& );}
\DoxyCodeLine{9746             SectionInfo \textcolor{keyword}{const}\& m\_other;}
\DoxyCodeLine{9747         \};}
\DoxyCodeLine{9748 }
\DoxyCodeLine{9749         \textcolor{keyword}{typedef} Node<TestCaseStats, SectionNode> TestCaseNode;}
\DoxyCodeLine{9750         \textcolor{keyword}{typedef} Node<TestGroupStats, TestCaseNode> TestGroupNode;}
\DoxyCodeLine{9751         \textcolor{keyword}{typedef} Node<TestRunStats, TestGroupNode> TestRunNode;}
\DoxyCodeLine{9752 }
\DoxyCodeLine{9753         CumulativeReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{9754         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{9755             stream( \_config.stream() )}
\DoxyCodeLine{9756         \{}
\DoxyCodeLine{9757             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{9758         \}}
\DoxyCodeLine{9759         \string~CumulativeReporterBase();}
\DoxyCodeLine{9760 }
\DoxyCodeLine{9761         \textcolor{keyword}{virtual} ReporterPreferences getPreferences() const CATCH\_OVERRIDE \{}
\DoxyCodeLine{9762             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{9763         \}}
\DoxyCodeLine{9764 }
\DoxyCodeLine{9765         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{9766         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{9767 }
\DoxyCodeLine{9768         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{9769 }
\DoxyCodeLine{9770         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9771             SectionStats incompleteStats( sectionInfo, Counts(), 0, \textcolor{keyword}{false} );}
\DoxyCodeLine{9772             Ptr<SectionNode> node;}
\DoxyCodeLine{9773             \textcolor{keywordflow}{if}( m\_sectionStack.empty() ) \{}
\DoxyCodeLine{9774                 \textcolor{keywordflow}{if}( !m\_rootSection )}
\DoxyCodeLine{9775                     m\_rootSection = \textcolor{keyword}{new} SectionNode( incompleteStats );}
\DoxyCodeLine{9776                 node = m\_rootSection;}
\DoxyCodeLine{9777             \}}
\DoxyCodeLine{9778             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{9779                 SectionNode\& parentNode = *m\_sectionStack.back();}
\DoxyCodeLine{9780                 SectionNode::ChildSections::const\_iterator it =}
\DoxyCodeLine{9781                     std::find\_if(   parentNode.childSections.begin(),}
\DoxyCodeLine{9782                                     parentNode.childSections.end(),}
\DoxyCodeLine{9783                                     BySectionInfo( sectionInfo ) );}
\DoxyCodeLine{9784                 \textcolor{keywordflow}{if}( it == parentNode.childSections.end() ) \{}
\DoxyCodeLine{9785                     node = \textcolor{keyword}{new} SectionNode( incompleteStats );}
\DoxyCodeLine{9786                     parentNode.childSections.push\_back( node );}
\DoxyCodeLine{9787                 \}}
\DoxyCodeLine{9788                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9789                     node = *it;}
\DoxyCodeLine{9790             \}}
\DoxyCodeLine{9791             m\_sectionStack.push\_back( node );}
\DoxyCodeLine{9792             m\_deepestSection = node;}
\DoxyCodeLine{9793         \}}
\DoxyCodeLine{9794 }
\DoxyCodeLine{9795         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{9796 }
\DoxyCodeLine{9797         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9798             assert( !m\_sectionStack.empty() );}
\DoxyCodeLine{9799             SectionNode\& sectionNode = *m\_sectionStack.back();}
\DoxyCodeLine{9800             sectionNode.assertions.push\_back( assertionStats );}
\DoxyCodeLine{9801             \textcolor{comment}{// AssertionResult holds a pointer to a temporary DecomposedExpression,}}
\DoxyCodeLine{9802             \textcolor{comment}{// which getExpandedExpression() calls to build the expression string.}}
\DoxyCodeLine{9803             \textcolor{comment}{// Our section stack copy of the assertionResult will likely outlive the}}
\DoxyCodeLine{9804             \textcolor{comment}{// temporary, so it must be expanded or discarded now to avoid calling}}
\DoxyCodeLine{9805             \textcolor{comment}{// a destroyed object later.}}
\DoxyCodeLine{9806             prepareExpandedExpression( sectionNode.assertions.back().assertionResult );}
\DoxyCodeLine{9807             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{9808         \}}
\DoxyCodeLine{9809         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9810             assert( !m\_sectionStack.empty() );}
\DoxyCodeLine{9811             SectionNode\& node = *m\_sectionStack.back();}
\DoxyCodeLine{9812             node.stats = sectionStats;}
\DoxyCodeLine{9813             m\_sectionStack.pop\_back();}
\DoxyCodeLine{9814         \}}
\DoxyCodeLine{9815         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9816             Ptr<TestCaseNode> node = \textcolor{keyword}{new} TestCaseNode( testCaseStats );}
\DoxyCodeLine{9817             assert( m\_sectionStack.size() == 0 );}
\DoxyCodeLine{9818             node-\/>children.push\_back( m\_rootSection );}
\DoxyCodeLine{9819             m\_testCases.push\_back( node );}
\DoxyCodeLine{9820             m\_rootSection.reset();}
\DoxyCodeLine{9821 }
\DoxyCodeLine{9822             assert( m\_deepestSection );}
\DoxyCodeLine{9823             m\_deepestSection-\/>stdOut = testCaseStats.stdOut;}
\DoxyCodeLine{9824             m\_deepestSection-\/>stdErr = testCaseStats.stdErr;}
\DoxyCodeLine{9825         \}}
\DoxyCodeLine{9826         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9827             Ptr<TestGroupNode> node = \textcolor{keyword}{new} TestGroupNode( testGroupStats );}
\DoxyCodeLine{9828             node-\/>children.swap( m\_testCases );}
\DoxyCodeLine{9829             m\_testGroups.push\_back( node );}
\DoxyCodeLine{9830         \}}
\DoxyCodeLine{9831         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9832             Ptr<TestRunNode> node = \textcolor{keyword}{new} TestRunNode( testRunStats );}
\DoxyCodeLine{9833             node-\/>children.swap( m\_testGroups );}
\DoxyCodeLine{9834             m\_testRuns.push\_back( node );}
\DoxyCodeLine{9835             testRunEndedCumulative();}
\DoxyCodeLine{9836         \}}
\DoxyCodeLine{9837         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEndedCumulative() = 0;}
\DoxyCodeLine{9838 }
\DoxyCodeLine{9839         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{9840 }
\DoxyCodeLine{9841         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} prepareExpandedExpression( AssertionResult\& result )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9842             \textcolor{keywordflow}{if}( result.isOk() )}
\DoxyCodeLine{9843                 result.discardDecomposedExpression();}
\DoxyCodeLine{9844             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9845                 result.expandDecomposedExpression();}
\DoxyCodeLine{9846         \}}
\DoxyCodeLine{9847 }
\DoxyCodeLine{9848         Ptr<IConfig const> m\_config;}
\DoxyCodeLine{9849         std::ostream\& stream;}
\DoxyCodeLine{9850         std::vector<AssertionStats> m\_assertions;}
\DoxyCodeLine{9851         std::vector<std::vector<Ptr<SectionNode> > > m\_sections;}
\DoxyCodeLine{9852         std::vector<Ptr<TestCaseNode> > m\_testCases;}
\DoxyCodeLine{9853         std::vector<Ptr<TestGroupNode> > m\_testGroups;}
\DoxyCodeLine{9854 }
\DoxyCodeLine{9855         std::vector<Ptr<TestRunNode> > m\_testRuns;}
\DoxyCodeLine{9856 }
\DoxyCodeLine{9857         Ptr<SectionNode> m\_rootSection;}
\DoxyCodeLine{9858         Ptr<SectionNode> m\_deepestSection;}
\DoxyCodeLine{9859         std::vector<Ptr<SectionNode> > m\_sectionStack;}
\DoxyCodeLine{9860         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{9861 }
\DoxyCodeLine{9862     \};}
\DoxyCodeLine{9863 }
\DoxyCodeLine{9864     \textcolor{keyword}{template}<\textcolor{keywordtype}{char} C>}
\DoxyCodeLine{9865     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* getLineOfChars() \{}
\DoxyCodeLine{9866         \textcolor{keyword}{static} \textcolor{keywordtype}{char} line[CATCH\_CONFIG\_CONSOLE\_WIDTH] = \{0\};}
\DoxyCodeLine{9867         \textcolor{keywordflow}{if}( !*line ) \{}
\DoxyCodeLine{9868             std::memset( line, C, CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1 );}
\DoxyCodeLine{9869             line[CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1] = 0;}
\DoxyCodeLine{9870         \}}
\DoxyCodeLine{9871         \textcolor{keywordflow}{return} line;}
\DoxyCodeLine{9872     \}}
\DoxyCodeLine{9873 }
\DoxyCodeLine{9874     \textcolor{keyword}{struct }TestEventListenerBase : StreamingReporterBase \{}
\DoxyCodeLine{9875         TestEventListenerBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{9876         :   StreamingReporterBase( \_config )}
\DoxyCodeLine{9877         \{\}}
\DoxyCodeLine{9878 }
\DoxyCodeLine{9879         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{9880         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{9881             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9882         \}}
\DoxyCodeLine{9883     \};}
\DoxyCodeLine{9884 }
\DoxyCodeLine{9885 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9886 }
\DoxyCodeLine{9887 \textcolor{comment}{// \#included from: ../internal/catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{9888 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REPORTER\_REGISTRARS\_HPP\_INCLUDED}}
\DoxyCodeLine{9889 }
\DoxyCodeLine{9890 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9891 }
\DoxyCodeLine{9892     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9893     \textcolor{keyword}{class }LegacyReporterRegistrar \{}
\DoxyCodeLine{9894 }
\DoxyCodeLine{9895         \textcolor{keyword}{class }ReporterFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{9896             \textcolor{keyword}{virtual} IStreamingReporter* create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9897                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} LegacyReporterAdapter( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{9898             \}}
\DoxyCodeLine{9899 }
\DoxyCodeLine{9900             \textcolor{keyword}{virtual} std::string getDescription()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9901                 \textcolor{keywordflow}{return} T::getDescription();}
\DoxyCodeLine{9902             \}}
\DoxyCodeLine{9903         \};}
\DoxyCodeLine{9904 }
\DoxyCodeLine{9905     \textcolor{keyword}{public}:}
\DoxyCodeLine{9906 }
\DoxyCodeLine{9907         LegacyReporterRegistrar( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{9908             getMutableRegistryHub().registerReporter( name, \textcolor{keyword}{new} ReporterFactory() );}
\DoxyCodeLine{9909         \}}
\DoxyCodeLine{9910     \};}
\DoxyCodeLine{9911 }
\DoxyCodeLine{9912     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9913     \textcolor{keyword}{class }ReporterRegistrar \{}
\DoxyCodeLine{9914 }
\DoxyCodeLine{9915         \textcolor{keyword}{class }ReporterFactory : \textcolor{keyword}{public} SharedImpl<IReporterFactory> \{}
\DoxyCodeLine{9916 }
\DoxyCodeLine{9917             \textcolor{comment}{// *** Please Note ***:}}
\DoxyCodeLine{9918             \textcolor{comment}{// -\/ If you end up here looking at a compiler error because it's trying to register}}
\DoxyCodeLine{9919             \textcolor{comment}{// your custom reporter class be aware that the native reporter interface has changed}}
\DoxyCodeLine{9920             \textcolor{comment}{// to IStreamingReporter. The "{}legacy"{} interface, IReporter, is still supported via}}
\DoxyCodeLine{9921             \textcolor{comment}{// an adapter. Just use REGISTER\_LEGACY\_REPORTER to take advantage of the adapter.}}
\DoxyCodeLine{9922             \textcolor{comment}{// However please consider updating to the new interface as the old one is now}}
\DoxyCodeLine{9923             \textcolor{comment}{// deprecated and will probably be removed quite soon!}}
\DoxyCodeLine{9924             \textcolor{comment}{// Please contact me via github if you have any questions at all about this.}}
\DoxyCodeLine{9925             \textcolor{comment}{// In fact, ideally, please contact me anyway to let me know you've hit this -\/ as I have}}
\DoxyCodeLine{9926             \textcolor{comment}{// no idea who is actually using custom reporters at all (possibly no-\/one!).}}
\DoxyCodeLine{9927             \textcolor{comment}{// The new interface is designed to minimise exposure to interface changes in the future.}}
\DoxyCodeLine{9928             \textcolor{keyword}{virtual} IStreamingReporter* create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9929                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} T( config );}
\DoxyCodeLine{9930             \}}
\DoxyCodeLine{9931 }
\DoxyCodeLine{9932             \textcolor{keyword}{virtual} std::string getDescription()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9933                 \textcolor{keywordflow}{return} T::getDescription();}
\DoxyCodeLine{9934             \}}
\DoxyCodeLine{9935         \};}
\DoxyCodeLine{9936 }
\DoxyCodeLine{9937     \textcolor{keyword}{public}:}
\DoxyCodeLine{9938 }
\DoxyCodeLine{9939         ReporterRegistrar( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{9940             getMutableRegistryHub().registerReporter( name, \textcolor{keyword}{new} ReporterFactory() );}
\DoxyCodeLine{9941         \}}
\DoxyCodeLine{9942     \};}
\DoxyCodeLine{9943 }
\DoxyCodeLine{9944     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9945     \textcolor{keyword}{class }ListenerRegistrar \{}
\DoxyCodeLine{9946 }
\DoxyCodeLine{9947         \textcolor{keyword}{class }ListenerFactory : \textcolor{keyword}{public} SharedImpl<IReporterFactory> \{}
\DoxyCodeLine{9948 }
\DoxyCodeLine{9949             \textcolor{keyword}{virtual} IStreamingReporter* create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9950                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} T( config );}
\DoxyCodeLine{9951             \}}
\DoxyCodeLine{9952             \textcolor{keyword}{virtual} std::string getDescription()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9953                 \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{9954             \}}
\DoxyCodeLine{9955         \};}
\DoxyCodeLine{9956 }
\DoxyCodeLine{9957     \textcolor{keyword}{public}:}
\DoxyCodeLine{9958 }
\DoxyCodeLine{9959         ListenerRegistrar() \{}
\DoxyCodeLine{9960             getMutableRegistryHub().registerListener( \textcolor{keyword}{new} ListenerFactory() );}
\DoxyCodeLine{9961         \}}
\DoxyCodeLine{9962     \};}
\DoxyCodeLine{9963 \}}
\DoxyCodeLine{9964 }
\DoxyCodeLine{9965 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REGISTER\_LEGACY\_REPORTER( name, reporterType ) \(\backslash\)}}
\DoxyCodeLine{9966 \textcolor{preprocessor}{    namespace\{ Catch::LegacyReporterRegistrar<reporterType> catch\_internal\_RegistrarFor\#\#reporterType( name ); \}}}
\DoxyCodeLine{9967 }
\DoxyCodeLine{9968 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REGISTER\_REPORTER( name, reporterType ) \(\backslash\)}}
\DoxyCodeLine{9969 \textcolor{preprocessor}{    namespace\{ Catch::ReporterRegistrar<reporterType> catch\_internal\_RegistrarFor\#\#reporterType( name ); \}}}
\DoxyCodeLine{9970 }
\DoxyCodeLine{9971 \textcolor{comment}{// Deprecated -\/ use the form without INTERNAL\_}}
\DoxyCodeLine{9972 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REGISTER\_LISTENER( listenerType ) \(\backslash\)}}
\DoxyCodeLine{9973 \textcolor{preprocessor}{    namespace\{ Catch::ListenerRegistrar<listenerType> catch\_internal\_RegistrarFor\#\#listenerType; \}}}
\DoxyCodeLine{9974 }
\DoxyCodeLine{9975 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER( listenerType ) \(\backslash\)}}
\DoxyCodeLine{9976 \textcolor{preprocessor}{    namespace\{ Catch::ListenerRegistrar<listenerType> catch\_internal\_RegistrarFor\#\#listenerType; \}}}
\DoxyCodeLine{9977 }
\DoxyCodeLine{9978 \textcolor{comment}{// \#included from: ../internal/catch\_xmlwriter.hpp}}
\DoxyCodeLine{9979 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_XMLWRITER\_HPP\_INCLUDED}}
\DoxyCodeLine{9980 }
\DoxyCodeLine{9981 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{9982 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{9983 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{9984 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{9985 }
\DoxyCodeLine{9986 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9987 }
\DoxyCodeLine{9988     \textcolor{keyword}{class }XmlEncode \{}
\DoxyCodeLine{9989     \textcolor{keyword}{public}:}
\DoxyCodeLine{9990         \textcolor{keyword}{enum} ForWhat \{ ForTextNodes, ForAttributes \};}
\DoxyCodeLine{9991 }
\DoxyCodeLine{9992         XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat = ForTextNodes )}
\DoxyCodeLine{9993         :   m\_str( str ),}
\DoxyCodeLine{9994             m\_forWhat( forWhat )}
\DoxyCodeLine{9995         \{\}}
\DoxyCodeLine{9996 }
\DoxyCodeLine{9997         \textcolor{keywordtype}{void} encodeTo( std::ostream\& os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9998 }
\DoxyCodeLine{9999             \textcolor{comment}{// Apostrophe escaping not necessary if we always use "{} to write attributes}}
\DoxyCodeLine{10000             \textcolor{comment}{// (see: http://www.w3.org/TR/xml/\#syntax)}}
\DoxyCodeLine{10001 }
\DoxyCodeLine{10002             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < m\_str.size(); ++ i ) \{}
\DoxyCodeLine{10003                 \textcolor{keywordtype}{char} c = m\_str[i];}
\DoxyCodeLine{10004                 \textcolor{keywordflow}{switch}( c ) \{}
\DoxyCodeLine{10005                     \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:   os << \textcolor{stringliteral}{"{}\&lt;"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{10006                     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\&'}:   os << \textcolor{stringliteral}{"{}\&amp;"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{10007 }
\DoxyCodeLine{10008                     \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{10009                         \textcolor{comment}{// See: http://www.w3.org/TR/xml/\#syntax}}
\DoxyCodeLine{10010                         \textcolor{keywordflow}{if}( i > 2 \&\& m\_str[i-\/1] == \textcolor{charliteral}{']'} \&\& m\_str[i-\/2] == \textcolor{charliteral}{']'} )}
\DoxyCodeLine{10011                             os << \textcolor{stringliteral}{"{}\&gt;"{}};}
\DoxyCodeLine{10012                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10013                             os << c;}
\DoxyCodeLine{10014                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10015 }
\DoxyCodeLine{10016                     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"{}'}:}
\DoxyCodeLine{10017                         \textcolor{keywordflow}{if}( m\_forWhat == ForAttributes )}
\DoxyCodeLine{10018                             os << \textcolor{stringliteral}{"{}\&quot;"{}};}
\DoxyCodeLine{10019                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10020                             os << c;}
\DoxyCodeLine{10021                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10022 }
\DoxyCodeLine{10023                     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10024                         \textcolor{comment}{// Escape control chars -\/ based on contribution by @espenalb in PR \#465 and}}
\DoxyCodeLine{10025                         \textcolor{comment}{// by @mrpi PR \#588}}
\DoxyCodeLine{10026                         \textcolor{keywordflow}{if} ( ( c >= 0 \&\& c < \textcolor{stringliteral}{'\(\backslash\)x09'} ) || ( c > \textcolor{stringliteral}{'\(\backslash\)x0D'} \&\& c < \textcolor{stringliteral}{'\(\backslash\)x20'}) || c==\textcolor{stringliteral}{'\(\backslash\)x7F'} ) \{}
\DoxyCodeLine{10027                             \textcolor{comment}{// see http://stackoverflow.com/questions/404107/why-\/are-\/control-\/characters-\/illegal-\/in-\/xml-\/1-\/0}}
\DoxyCodeLine{10028                             os << \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)x"{}} << std::uppercase << std::hex << std::setfill(\textcolor{charliteral}{'0'}) << std::setw(2)}
\DoxyCodeLine{10029                                << \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( c );}
\DoxyCodeLine{10030                         \}}
\DoxyCodeLine{10031                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10032                             os << c;}
\DoxyCodeLine{10033                 \}}
\DoxyCodeLine{10034             \}}
\DoxyCodeLine{10035         \}}
\DoxyCodeLine{10036 }
\DoxyCodeLine{10037         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode ) \{}
\DoxyCodeLine{10038             xmlEncode.encodeTo( os );}
\DoxyCodeLine{10039             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{10040         \}}
\DoxyCodeLine{10041 }
\DoxyCodeLine{10042     \textcolor{keyword}{private}:}
\DoxyCodeLine{10043         std::string m\_str;}
\DoxyCodeLine{10044         ForWhat m\_forWhat;}
\DoxyCodeLine{10045     \};}
\DoxyCodeLine{10046 }
\DoxyCodeLine{10047     \textcolor{keyword}{class }XmlWriter \{}
\DoxyCodeLine{10048     \textcolor{keyword}{public}:}
\DoxyCodeLine{10049 }
\DoxyCodeLine{10050         \textcolor{keyword}{class }ScopedElement \{}
\DoxyCodeLine{10051         \textcolor{keyword}{public}:}
\DoxyCodeLine{10052             ScopedElement( XmlWriter* writer )}
\DoxyCodeLine{10053             :   m\_writer( writer )}
\DoxyCodeLine{10054             \{\}}
\DoxyCodeLine{10055 }
\DoxyCodeLine{10056             ScopedElement( ScopedElement \textcolor{keyword}{const}\& other )}
\DoxyCodeLine{10057             :   m\_writer( other.m\_writer )\{}
\DoxyCodeLine{10058                 other.m\_writer = CATCH\_NULL;}
\DoxyCodeLine{10059             \}}
\DoxyCodeLine{10060 }
\DoxyCodeLine{10061             \string~ScopedElement() \{}
\DoxyCodeLine{10062                 \textcolor{keywordflow}{if}( m\_writer )}
\DoxyCodeLine{10063                     m\_writer-\/>endElement();}
\DoxyCodeLine{10064             \}}
\DoxyCodeLine{10065 }
\DoxyCodeLine{10066             ScopedElement\& writeText( std::string \textcolor{keyword}{const}\& text, \textcolor{keywordtype}{bool} indent = \textcolor{keyword}{true} ) \{}
\DoxyCodeLine{10067                 m\_writer-\/>writeText( text, indent );}
\DoxyCodeLine{10068                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10069             \}}
\DoxyCodeLine{10070 }
\DoxyCodeLine{10071             \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{10072             ScopedElement\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{10073                 m\_writer-\/>writeAttribute( name, attribute );}
\DoxyCodeLine{10074                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10075             \}}
\DoxyCodeLine{10076 }
\DoxyCodeLine{10077         \textcolor{keyword}{private}:}
\DoxyCodeLine{10078             \textcolor{keyword}{mutable} XmlWriter* m\_writer;}
\DoxyCodeLine{10079         \};}
\DoxyCodeLine{10080 }
\DoxyCodeLine{10081         XmlWriter()}
\DoxyCodeLine{10082         :   m\_tagIsOpen( false ),}
\DoxyCodeLine{10083             m\_needsNewline( false ),}
\DoxyCodeLine{10084             m\_os( Catch::cout() )}
\DoxyCodeLine{10085         \{}
\DoxyCodeLine{10086             writeDeclaration();}
\DoxyCodeLine{10087         \}}
\DoxyCodeLine{10088 }
\DoxyCodeLine{10089         XmlWriter( std::ostream\& os )}
\DoxyCodeLine{10090         :   m\_tagIsOpen( false ),}
\DoxyCodeLine{10091             m\_needsNewline( false ),}
\DoxyCodeLine{10092             m\_os( os )}
\DoxyCodeLine{10093         \{}
\DoxyCodeLine{10094             writeDeclaration();}
\DoxyCodeLine{10095         \}}
\DoxyCodeLine{10096 }
\DoxyCodeLine{10097         \string~XmlWriter() \{}
\DoxyCodeLine{10098             \textcolor{keywordflow}{while}( !m\_tags.empty() )}
\DoxyCodeLine{10099                 endElement();}
\DoxyCodeLine{10100         \}}
\DoxyCodeLine{10101 }
\DoxyCodeLine{10102         XmlWriter\& startElement( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{10103             ensureTagClosed();}
\DoxyCodeLine{10104             newlineIfNecessary();}
\DoxyCodeLine{10105             m\_os << m\_indent << \textcolor{charliteral}{'<'} << name;}
\DoxyCodeLine{10106             m\_tags.push\_back( name );}
\DoxyCodeLine{10107             m\_indent += "{}  "{};}
\DoxyCodeLine{10108             m\_tagIsOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{10109             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10110         \}}
\DoxyCodeLine{10111 }
\DoxyCodeLine{10112         ScopedElement scopedElement( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{10113             ScopedElement scoped( \textcolor{keyword}{this} );}
\DoxyCodeLine{10114             startElement( name );}
\DoxyCodeLine{10115             \textcolor{keywordflow}{return} scoped;}
\DoxyCodeLine{10116         \}}
\DoxyCodeLine{10117 }
\DoxyCodeLine{10118         XmlWriter\& endElement() \{}
\DoxyCodeLine{10119             newlineIfNecessary();}
\DoxyCodeLine{10120             m\_indent = m\_indent.substr( 0, m\_indent.size()-\/2 );}
\DoxyCodeLine{10121             \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{10122                 m\_os << \textcolor{stringliteral}{"{}/>"{}};}
\DoxyCodeLine{10123                 m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{10124             \}}
\DoxyCodeLine{10125             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10126                 m\_os << m\_indent << \textcolor{stringliteral}{"{}</"{}} << m\_tags.back() << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{10127             \}}
\DoxyCodeLine{10128             m\_os << std::endl;}
\DoxyCodeLine{10129             m\_tags.pop\_back();}
\DoxyCodeLine{10130             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10131         \}}
\DoxyCodeLine{10132 }
\DoxyCodeLine{10133         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{10134             \textcolor{keywordflow}{if}( !name.empty() \&\& !attribute.empty() )}
\DoxyCodeLine{10135                 m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"{}=\(\backslash\)"{}"{}} << XmlEncode( attribute, XmlEncode::ForAttributes ) << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{10136             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10137         \}}
\DoxyCodeLine{10138 }
\DoxyCodeLine{10139         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute ) \{}
\DoxyCodeLine{10140             m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"{}=\(\backslash\)"{}"{}} << ( attribute ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}} ) << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{10141             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10142         \}}
\DoxyCodeLine{10143 }
\DoxyCodeLine{10144         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{10145         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{10146             std::ostringstream oss;}
\DoxyCodeLine{10147             oss << attribute;}
\DoxyCodeLine{10148             \textcolor{keywordflow}{return} writeAttribute( name, oss.str() );}
\DoxyCodeLine{10149         \}}
\DoxyCodeLine{10150 }
\DoxyCodeLine{10151         XmlWriter\& writeText( std::string \textcolor{keyword}{const}\& text, \textcolor{keywordtype}{bool} indent = \textcolor{keyword}{true} ) \{}
\DoxyCodeLine{10152             \textcolor{keywordflow}{if}( !text.empty() )\{}
\DoxyCodeLine{10153                 \textcolor{keywordtype}{bool} tagWasOpen = m\_tagIsOpen;}
\DoxyCodeLine{10154                 ensureTagClosed();}
\DoxyCodeLine{10155                 \textcolor{keywordflow}{if}( tagWasOpen \&\& indent )}
\DoxyCodeLine{10156                     m\_os << m\_indent;}
\DoxyCodeLine{10157                 m\_os << XmlEncode( text );}
\DoxyCodeLine{10158                 m\_needsNewline = \textcolor{keyword}{true};}
\DoxyCodeLine{10159             \}}
\DoxyCodeLine{10160             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10161         \}}
\DoxyCodeLine{10162 }
\DoxyCodeLine{10163         XmlWriter\& writeComment( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10164             ensureTagClosed();}
\DoxyCodeLine{10165             m\_os << m\_indent << \textcolor{stringliteral}{"{}<!-\/-\/"{}} << text << \textcolor{stringliteral}{"{}-\/-\/>"{}};}
\DoxyCodeLine{10166             m\_needsNewline = \textcolor{keyword}{true};}
\DoxyCodeLine{10167             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10168         \}}
\DoxyCodeLine{10169 }
\DoxyCodeLine{10170         \textcolor{keywordtype}{void} writeStylesheetRef( std::string \textcolor{keyword}{const}\& url ) \{}
\DoxyCodeLine{10171             m\_os << \textcolor{stringliteral}{"{}<?xml-\/stylesheet type=\(\backslash\)"{}text/xsl\(\backslash\)"{} href=\(\backslash\)"{}"{}} << url << \textcolor{stringliteral}{"{}\(\backslash\)"{}?>\(\backslash\)n"{}};}
\DoxyCodeLine{10172         \}}
\DoxyCodeLine{10173 }
\DoxyCodeLine{10174         XmlWriter\& writeBlankLine() \{}
\DoxyCodeLine{10175             ensureTagClosed();}
\DoxyCodeLine{10176             m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10177             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10178         \}}
\DoxyCodeLine{10179 }
\DoxyCodeLine{10180         \textcolor{keywordtype}{void} ensureTagClosed() \{}
\DoxyCodeLine{10181             \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{10182                 m\_os << \textcolor{stringliteral}{"{}>"{}} << std::endl;}
\DoxyCodeLine{10183                 m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{10184             \}}
\DoxyCodeLine{10185         \}}
\DoxyCodeLine{10186 }
\DoxyCodeLine{10187     \textcolor{keyword}{private}:}
\DoxyCodeLine{10188         XmlWriter( XmlWriter \textcolor{keyword}{const}\& );}
\DoxyCodeLine{10189         \textcolor{keywordtype}{void} operator=( XmlWriter \textcolor{keyword}{const}\& );}
\DoxyCodeLine{10190 }
\DoxyCodeLine{10191         \textcolor{keywordtype}{void} writeDeclaration() \{}
\DoxyCodeLine{10192             m\_os << \textcolor{stringliteral}{"{}<?xml version=\(\backslash\)"{}1.0\(\backslash\)"{} encoding=\(\backslash\)"{}UTF-\/8\(\backslash\)"{}?>\(\backslash\)n"{}};}
\DoxyCodeLine{10193         \}}
\DoxyCodeLine{10194 }
\DoxyCodeLine{10195         \textcolor{keywordtype}{void} newlineIfNecessary() \{}
\DoxyCodeLine{10196             \textcolor{keywordflow}{if}( m\_needsNewline ) \{}
\DoxyCodeLine{10197                 m\_os << std::endl;}
\DoxyCodeLine{10198                 m\_needsNewline = \textcolor{keyword}{false};}
\DoxyCodeLine{10199             \}}
\DoxyCodeLine{10200         \}}
\DoxyCodeLine{10201 }
\DoxyCodeLine{10202         \textcolor{keywordtype}{bool} m\_tagIsOpen;}
\DoxyCodeLine{10203         \textcolor{keywordtype}{bool} m\_needsNewline;}
\DoxyCodeLine{10204         std::vector<std::string> m\_tags;}
\DoxyCodeLine{10205         std::string m\_indent;}
\DoxyCodeLine{10206         std::ostream\& m\_os;}
\DoxyCodeLine{10207     \};}
\DoxyCodeLine{10208 }
\DoxyCodeLine{10209 \}}
\DoxyCodeLine{10210 }
\DoxyCodeLine{10211 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10212     \textcolor{keyword}{class }XmlReporter : \textcolor{keyword}{public} StreamingReporterBase \{}
\DoxyCodeLine{10213     \textcolor{keyword}{public}:}
\DoxyCodeLine{10214         XmlReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{10215         :   StreamingReporterBase( \_config ),}
\DoxyCodeLine{10216             m\_xml(\_config.stream()),}
\DoxyCodeLine{10217             m\_sectionDepth( 0 )}
\DoxyCodeLine{10218         \{}
\DoxyCodeLine{10219             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{10220         \}}
\DoxyCodeLine{10221 }
\DoxyCodeLine{10222         \textcolor{keyword}{virtual} \string~XmlReporter() CATCH\_OVERRIDE;}
\DoxyCodeLine{10223 }
\DoxyCodeLine{10224         static std::\textcolor{keywordtype}{string} getDescription() \{}
\DoxyCodeLine{10225             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results as an XML document"{}};}
\DoxyCodeLine{10226         \}}
\DoxyCodeLine{10227 }
\DoxyCodeLine{10228         \textcolor{keyword}{virtual} std::string getStylesheetRef()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10229             \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{10230         \}}
\DoxyCodeLine{10231 }
\DoxyCodeLine{10232         \textcolor{keywordtype}{void} writeSourceInfo( SourceLineInfo \textcolor{keyword}{const}\& sourceInfo ) \{}
\DoxyCodeLine{10233             m\_xml}
\DoxyCodeLine{10234                 .writeAttribute( \textcolor{stringliteral}{"{}filename"{}}, sourceInfo.file )}
\DoxyCodeLine{10235                 .writeAttribute( \textcolor{stringliteral}{"{}line"{}}, sourceInfo.line );}
\DoxyCodeLine{10236         \}}
\DoxyCodeLine{10237 }
\DoxyCodeLine{10238     \textcolor{keyword}{public}: \textcolor{comment}{// StreamingReporterBase}}
\DoxyCodeLine{10239 }
\DoxyCodeLine{10240         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& s ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10241             StreamingReporterBase::noMatchingTestCases( s );}
\DoxyCodeLine{10242         \}}
\DoxyCodeLine{10243 }
\DoxyCodeLine{10244         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10245             StreamingReporterBase::testRunStarting( testInfo );}
\DoxyCodeLine{10246             std::string stylesheetRef = getStylesheetRef();}
\DoxyCodeLine{10247             \textcolor{keywordflow}{if}( !stylesheetRef.empty() )}
\DoxyCodeLine{10248                 m\_xml.writeStylesheetRef( stylesheetRef );}
\DoxyCodeLine{10249             m\_xml.startElement( \textcolor{stringliteral}{"{}Catch"{}} );}
\DoxyCodeLine{10250             \textcolor{keywordflow}{if}( !m\_config-\/>name().empty() )}
\DoxyCodeLine{10251                 m\_xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, m\_config-\/>name() );}
\DoxyCodeLine{10252         \}}
\DoxyCodeLine{10253 }
\DoxyCodeLine{10254         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10255             StreamingReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{10256             m\_xml.startElement( \textcolor{stringliteral}{"{}Group"{}} )}
\DoxyCodeLine{10257                 .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, groupInfo.name );}
\DoxyCodeLine{10258         \}}
\DoxyCodeLine{10259 }
\DoxyCodeLine{10260         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10261             StreamingReporterBase::testCaseStarting(testInfo);}
\DoxyCodeLine{10262             m\_xml.startElement( \textcolor{stringliteral}{"{}TestCase"{}} )}
\DoxyCodeLine{10263                 .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, trim( testInfo.name ) )}
\DoxyCodeLine{10264                 .writeAttribute( \textcolor{stringliteral}{"{}description"{}}, testInfo.description )}
\DoxyCodeLine{10265                 .writeAttribute( \textcolor{stringliteral}{"{}tags"{}}, testInfo.tagsAsString );}
\DoxyCodeLine{10266 }
\DoxyCodeLine{10267             writeSourceInfo( testInfo.lineInfo );}
\DoxyCodeLine{10268 }
\DoxyCodeLine{10269             \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{10270                 m\_testCaseTimer.start();}
\DoxyCodeLine{10271             m\_xml.ensureTagClosed();}
\DoxyCodeLine{10272         \}}
\DoxyCodeLine{10273 }
\DoxyCodeLine{10274         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10275             StreamingReporterBase::sectionStarting( sectionInfo );}
\DoxyCodeLine{10276             \textcolor{keywordflow}{if}( m\_sectionDepth++ > 0 ) \{}
\DoxyCodeLine{10277                 m\_xml.startElement( \textcolor{stringliteral}{"{}Section"{}} )}
\DoxyCodeLine{10278                     .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, trim( sectionInfo.name ) )}
\DoxyCodeLine{10279                     .writeAttribute( \textcolor{stringliteral}{"{}description"{}}, sectionInfo.description );}
\DoxyCodeLine{10280                 writeSourceInfo( sectionInfo.lineInfo );}
\DoxyCodeLine{10281                 m\_xml.ensureTagClosed();}
\DoxyCodeLine{10282             \}}
\DoxyCodeLine{10283         \}}
\DoxyCodeLine{10284 }
\DoxyCodeLine{10285         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{ \}}
\DoxyCodeLine{10286 }
\DoxyCodeLine{10287         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10288 }
\DoxyCodeLine{10289             AssertionResult \textcolor{keyword}{const}\& result = assertionStats.assertionResult;}
\DoxyCodeLine{10290 }
\DoxyCodeLine{10291             \textcolor{keywordtype}{bool} includeResults = m\_config-\/>includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{10292 }
\DoxyCodeLine{10293             \textcolor{keywordflow}{if}( includeResults || result.getResultType() == ResultWas::Warning ) \{}
\DoxyCodeLine{10294                 \textcolor{comment}{// Print any info messages in <Info> tags.}}
\DoxyCodeLine{10295                 \textcolor{keywordflow}{for}( std::vector<MessageInfo>::const\_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();}
\DoxyCodeLine{10296                      it != itEnd;}
\DoxyCodeLine{10297                      ++it ) \{}
\DoxyCodeLine{10298                     \textcolor{keywordflow}{if}( it-\/>type == ResultWas::Info \&\& includeResults ) \{}
\DoxyCodeLine{10299                         m\_xml.scopedElement( \textcolor{stringliteral}{"{}Info"{}} )}
\DoxyCodeLine{10300                                 .writeText( it-\/>message );}
\DoxyCodeLine{10301                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( it-\/>type == ResultWas::Warning ) \{}
\DoxyCodeLine{10302                         m\_xml.scopedElement( \textcolor{stringliteral}{"{}Warning"{}} )}
\DoxyCodeLine{10303                                 .writeText( it-\/>message );}
\DoxyCodeLine{10304                     \}}
\DoxyCodeLine{10305                 \}}
\DoxyCodeLine{10306             \}}
\DoxyCodeLine{10307 }
\DoxyCodeLine{10308             \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{10309             \textcolor{keywordflow}{if}( !includeResults \&\& result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{10310                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{10311 }
\DoxyCodeLine{10312             \textcolor{comment}{// Print the expression if there is one.}}
\DoxyCodeLine{10313             \textcolor{keywordflow}{if}( result.hasExpression() ) \{}
\DoxyCodeLine{10314                 m\_xml.startElement( \textcolor{stringliteral}{"{}Expression"{}} )}
\DoxyCodeLine{10315                     .writeAttribute( \textcolor{stringliteral}{"{}success"{}}, result.succeeded() )}
\DoxyCodeLine{10316                     .writeAttribute( \textcolor{stringliteral}{"{}type"{}}, result.getTestMacroName() );}
\DoxyCodeLine{10317 }
\DoxyCodeLine{10318                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{10319 }
\DoxyCodeLine{10320                 m\_xml.scopedElement( \textcolor{stringliteral}{"{}Original"{}} )}
\DoxyCodeLine{10321                     .writeText( result.getExpression() );}
\DoxyCodeLine{10322                 m\_xml.scopedElement( \textcolor{stringliteral}{"{}Expanded"{}} )}
\DoxyCodeLine{10323                     .writeText( result.getExpandedExpression() );}
\DoxyCodeLine{10324             \}}
\DoxyCodeLine{10325 }
\DoxyCodeLine{10326             \textcolor{comment}{// And... Print a result applicable to each result type.}}
\DoxyCodeLine{10327             \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{10328                 \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{10329                     m\_xml.startElement( \textcolor{stringliteral}{"{}Exception"{}} );}
\DoxyCodeLine{10330                     writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{10331                     m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{10332                     m\_xml.endElement();}
\DoxyCodeLine{10333                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10334                 \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{10335                     m\_xml.startElement( \textcolor{stringliteral}{"{}FatalErrorCondition"{}} );}
\DoxyCodeLine{10336                     writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{10337                     m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{10338                     m\_xml.endElement();}
\DoxyCodeLine{10339                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10340                 \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{10341                     m\_xml.scopedElement( \textcolor{stringliteral}{"{}Info"{}} )}
\DoxyCodeLine{10342                         .writeText( result.getMessage() );}
\DoxyCodeLine{10343                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10344                 \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{10345                     \textcolor{comment}{// Warning will already have been written}}
\DoxyCodeLine{10346                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10347                 \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{10348                     m\_xml.startElement( \textcolor{stringliteral}{"{}Failure"{}} );}
\DoxyCodeLine{10349                     writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{10350                     m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{10351                     m\_xml.endElement();}
\DoxyCodeLine{10352                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10353                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10354                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10355             \}}
\DoxyCodeLine{10356 }
\DoxyCodeLine{10357             \textcolor{keywordflow}{if}( result.hasExpression() )}
\DoxyCodeLine{10358                 m\_xml.endElement();}
\DoxyCodeLine{10359 }
\DoxyCodeLine{10360             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{10361         \}}
\DoxyCodeLine{10362 }
\DoxyCodeLine{10363         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10364             StreamingReporterBase::sectionEnded( sectionStats );}
\DoxyCodeLine{10365             \textcolor{keywordflow}{if}( -\/-\/m\_sectionDepth > 0 ) \{}
\DoxyCodeLine{10366                 XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} );}
\DoxyCodeLine{10367                 e.writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, sectionStats.assertions.passed );}
\DoxyCodeLine{10368                 e.writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, sectionStats.assertions.failed );}
\DoxyCodeLine{10369                 e.writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, sectionStats.assertions.failedButOk );}
\DoxyCodeLine{10370 }
\DoxyCodeLine{10371                 \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{10372                     e.writeAttribute( \textcolor{stringliteral}{"{}durationInSeconds"{}}, sectionStats.durationInSeconds );}
\DoxyCodeLine{10373 }
\DoxyCodeLine{10374                 m\_xml.endElement();}
\DoxyCodeLine{10375             \}}
\DoxyCodeLine{10376         \}}
\DoxyCodeLine{10377 }
\DoxyCodeLine{10378         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10379             StreamingReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{10380             XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResult"{}} );}
\DoxyCodeLine{10381             e.writeAttribute( \textcolor{stringliteral}{"{}success"{}}, testCaseStats.totals.assertions.allOk() );}
\DoxyCodeLine{10382 }
\DoxyCodeLine{10383             \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{10384                 e.writeAttribute( \textcolor{stringliteral}{"{}durationInSeconds"{}}, m\_testCaseTimer.getElapsedSeconds() );}
\DoxyCodeLine{10385 }
\DoxyCodeLine{10386             \textcolor{keywordflow}{if}( !testCaseStats.stdOut.empty() )}
\DoxyCodeLine{10387                 m\_xml.scopedElement( \textcolor{stringliteral}{"{}StdOut"{}} ).writeText( trim( testCaseStats.stdOut ), \textcolor{keyword}{false} );}
\DoxyCodeLine{10388             \textcolor{keywordflow}{if}( !testCaseStats.stdErr.empty() )}
\DoxyCodeLine{10389                 m\_xml.scopedElement( \textcolor{stringliteral}{"{}StdErr"{}} ).writeText( trim( testCaseStats.stdErr ), \textcolor{keyword}{false} );}
\DoxyCodeLine{10390 }
\DoxyCodeLine{10391             m\_xml.endElement();}
\DoxyCodeLine{10392         \}}
\DoxyCodeLine{10393 }
\DoxyCodeLine{10394         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10395             StreamingReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{10396             \textcolor{comment}{// TODO: Check testGroupStats.aborting and act accordingly.}}
\DoxyCodeLine{10397             m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} )}
\DoxyCodeLine{10398                 .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testGroupStats.totals.assertions.passed )}
\DoxyCodeLine{10399                 .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testGroupStats.totals.assertions.failed )}
\DoxyCodeLine{10400                 .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testGroupStats.totals.assertions.failedButOk );}
\DoxyCodeLine{10401             m\_xml.endElement();}
\DoxyCodeLine{10402         \}}
\DoxyCodeLine{10403 }
\DoxyCodeLine{10404         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10405             StreamingReporterBase::testRunEnded( testRunStats );}
\DoxyCodeLine{10406             m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} )}
\DoxyCodeLine{10407                 .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testRunStats.totals.assertions.passed )}
\DoxyCodeLine{10408                 .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testRunStats.totals.assertions.failed )}
\DoxyCodeLine{10409                 .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testRunStats.totals.assertions.failedButOk );}
\DoxyCodeLine{10410             m\_xml.endElement();}
\DoxyCodeLine{10411         \}}
\DoxyCodeLine{10412 }
\DoxyCodeLine{10413     \textcolor{keyword}{private}:}
\DoxyCodeLine{10414         Timer m\_testCaseTimer;}
\DoxyCodeLine{10415         XmlWriter m\_xml;}
\DoxyCodeLine{10416         \textcolor{keywordtype}{int} m\_sectionDepth;}
\DoxyCodeLine{10417     \};}
\DoxyCodeLine{10418 }
\DoxyCodeLine{10419      INTERNAL\_CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}xml"{}}, XmlReporter )}
\DoxyCodeLine{10420 }
\DoxyCodeLine{10421 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10422 }
\DoxyCodeLine{10423 \textcolor{comment}{// \#included from: ../reporters/catch\_reporter\_junit.hpp}}
\DoxyCodeLine{10424 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REPORTER\_JUNIT\_HPP\_INCLUDED}}
\DoxyCodeLine{10425 }
\DoxyCodeLine{10426 \textcolor{preprocessor}{\#include <assert.h>}}
\DoxyCodeLine{10427 }
\DoxyCodeLine{10428 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10429 }
\DoxyCodeLine{10430     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10431         std::string getCurrentTimestamp() \{}
\DoxyCodeLine{10432             \textcolor{comment}{// Beware, this is not reentrant because of backward compatibility issues}}
\DoxyCodeLine{10433             \textcolor{comment}{// Also, UTC only, again because of backward compatibility (\%z is C++11)}}
\DoxyCodeLine{10434             time\_t rawtime;}
\DoxyCodeLine{10435             std::time(\&rawtime);}
\DoxyCodeLine{10436             \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"{}2017-\/01-\/16T17:06:45Z"{}});}
\DoxyCodeLine{10437 }
\DoxyCodeLine{10438 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{10439             std::tm timeInfo = \{\};}
\DoxyCodeLine{10440             gmtime\_s(\&timeInfo, \&rawtime);}
\DoxyCodeLine{10441 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10442             std::tm* timeInfo;}
\DoxyCodeLine{10443             timeInfo = std::gmtime(\&rawtime);}
\DoxyCodeLine{10444 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10445 }
\DoxyCodeLine{10446             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{10447             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%dT\%H:\%M:\%SZ"{}};}
\DoxyCodeLine{10448 }
\DoxyCodeLine{10449 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{10450             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{10451 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10452             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{10453 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10454             \textcolor{keywordflow}{return} std::string(timeStamp);}
\DoxyCodeLine{10455         \}}
\DoxyCodeLine{10456 }
\DoxyCodeLine{10457     \}}
\DoxyCodeLine{10458 }
\DoxyCodeLine{10459     \textcolor{keyword}{class }JunitReporter : \textcolor{keyword}{public} CumulativeReporterBase \{}
\DoxyCodeLine{10460     \textcolor{keyword}{public}:}
\DoxyCodeLine{10461         JunitReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{10462         :   CumulativeReporterBase( \_config ),}
\DoxyCodeLine{10463             xml( \_config.stream() ),}
\DoxyCodeLine{10464             unexpectedExceptions( 0 ),}
\DoxyCodeLine{10465             m\_okToFail( false )}
\DoxyCodeLine{10466         \{}
\DoxyCodeLine{10467             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{10468         \}}
\DoxyCodeLine{10469 }
\DoxyCodeLine{10470         \textcolor{keyword}{virtual} \string~JunitReporter() CATCH\_OVERRIDE;}
\DoxyCodeLine{10471 }
\DoxyCodeLine{10472         static std::\textcolor{keywordtype}{string} getDescription() \{}
\DoxyCodeLine{10473             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results in an XML format that looks like Ant's junitreport target"{}};}
\DoxyCodeLine{10474         \}}
\DoxyCodeLine{10475 }
\DoxyCodeLine{10476         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/} ) CATCH\_OVERRIDE \{\}}
\DoxyCodeLine{10477 }
\DoxyCodeLine{10478         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& runInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10479             CumulativeReporterBase::testRunStarting( runInfo );}
\DoxyCodeLine{10480             xml.startElement( \textcolor{stringliteral}{"{}testsuites"{}} );}
\DoxyCodeLine{10481         \}}
\DoxyCodeLine{10482 }
\DoxyCodeLine{10483         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10484             suiteTimer.start();}
\DoxyCodeLine{10485             stdOutForSuite.str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{10486             stdErrForSuite.str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{10487             unexpectedExceptions = 0;}
\DoxyCodeLine{10488             CumulativeReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{10489         \}}
\DoxyCodeLine{10490 }
\DoxyCodeLine{10491         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10492             m\_okToFail = testCaseInfo.okToFail();}
\DoxyCodeLine{10493         \}}
\DoxyCodeLine{10494         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10495             \textcolor{keywordflow}{if}( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException \&\& !m\_okToFail )}
\DoxyCodeLine{10496                 unexpectedExceptions++;}
\DoxyCodeLine{10497             \textcolor{keywordflow}{return} CumulativeReporterBase::assertionEnded( assertionStats );}
\DoxyCodeLine{10498         \}}
\DoxyCodeLine{10499 }
\DoxyCodeLine{10500         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10501             stdOutForSuite << testCaseStats.stdOut;}
\DoxyCodeLine{10502             stdErrForSuite << testCaseStats.stdErr;}
\DoxyCodeLine{10503             CumulativeReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{10504         \}}
\DoxyCodeLine{10505 }
\DoxyCodeLine{10506         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10507             \textcolor{keywordtype}{double} suiteTime = suiteTimer.getElapsedSeconds();}
\DoxyCodeLine{10508             CumulativeReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{10509             writeGroup( *m\_testGroups.back(), suiteTime );}
\DoxyCodeLine{10510         \}}
\DoxyCodeLine{10511 }
\DoxyCodeLine{10512         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEndedCumulative() CATCH\_OVERRIDE \{}
\DoxyCodeLine{10513             xml.endElement();}
\DoxyCodeLine{10514         \}}
\DoxyCodeLine{10515 }
\DoxyCodeLine{10516         \textcolor{keywordtype}{void} writeGroup( TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime ) \{}
\DoxyCodeLine{10517             XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"{}testsuite"{}} );}
\DoxyCodeLine{10518             TestGroupStats \textcolor{keyword}{const}\& stats = groupNode.value;}
\DoxyCodeLine{10519             xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, stats.groupInfo.name );}
\DoxyCodeLine{10520             xml.writeAttribute( \textcolor{stringliteral}{"{}errors"{}}, unexpectedExceptions );}
\DoxyCodeLine{10521             xml.writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, stats.totals.assertions.failed-\/unexpectedExceptions );}
\DoxyCodeLine{10522             xml.writeAttribute( \textcolor{stringliteral}{"{}tests"{}}, stats.totals.assertions.total() );}
\DoxyCodeLine{10523             xml.writeAttribute( \textcolor{stringliteral}{"{}hostname"{}}, \textcolor{stringliteral}{"{}tbd"{}} ); \textcolor{comment}{// !TBD}}
\DoxyCodeLine{10524             \textcolor{keywordflow}{if}( m\_config-\/>showDurations() == ShowDurations::Never )}
\DoxyCodeLine{10525                 xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, \textcolor{stringliteral}{"{}"{}} );}
\DoxyCodeLine{10526             \textcolor{keywordflow}{else}}
\DoxyCodeLine{10527                 xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, suiteTime );}
\DoxyCodeLine{10528             xml.writeAttribute( \textcolor{stringliteral}{"{}timestamp"{}}, getCurrentTimestamp() );}
\DoxyCodeLine{10529 }
\DoxyCodeLine{10530             \textcolor{comment}{// Write test cases}}
\DoxyCodeLine{10531             \textcolor{keywordflow}{for}( TestGroupNode::ChildNodes::const\_iterator}
\DoxyCodeLine{10532                     it = groupNode.children.begin(), itEnd = groupNode.children.end();}
\DoxyCodeLine{10533                     it != itEnd;}
\DoxyCodeLine{10534                     ++it )}
\DoxyCodeLine{10535                 writeTestCase( **it );}
\DoxyCodeLine{10536 }
\DoxyCodeLine{10537             xml.scopedElement( \textcolor{stringliteral}{"{}system-\/out"{}} ).writeText( trim( stdOutForSuite.str() ), \textcolor{keyword}{false} );}
\DoxyCodeLine{10538             xml.scopedElement( \textcolor{stringliteral}{"{}system-\/err"{}} ).writeText( trim( stdErrForSuite.str() ), \textcolor{keyword}{false} );}
\DoxyCodeLine{10539         \}}
\DoxyCodeLine{10540 }
\DoxyCodeLine{10541         \textcolor{keywordtype}{void} writeTestCase( TestCaseNode \textcolor{keyword}{const}\& testCaseNode ) \{}
\DoxyCodeLine{10542             TestCaseStats \textcolor{keyword}{const}\& stats = testCaseNode.value;}
\DoxyCodeLine{10543 }
\DoxyCodeLine{10544             \textcolor{comment}{// All test cases have exactly one section -\/ which represents the}}
\DoxyCodeLine{10545             \textcolor{comment}{// test case itself. That section may have 0-\/n nested sections}}
\DoxyCodeLine{10546             assert( testCaseNode.children.size() == 1 );}
\DoxyCodeLine{10547             SectionNode \textcolor{keyword}{const}\& rootSection = *testCaseNode.children.front();}
\DoxyCodeLine{10548 }
\DoxyCodeLine{10549             std::string className = stats.testInfo.className;}
\DoxyCodeLine{10550 }
\DoxyCodeLine{10551             \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{10552                 \textcolor{keywordflow}{if}( rootSection.childSections.empty() )}
\DoxyCodeLine{10553                     className = \textcolor{stringliteral}{"{}global"{}};}
\DoxyCodeLine{10554             \}}
\DoxyCodeLine{10555             writeSection( className, \textcolor{stringliteral}{"{}"{}}, rootSection );}
\DoxyCodeLine{10556         \}}
\DoxyCodeLine{10557 }
\DoxyCodeLine{10558         \textcolor{keywordtype}{void} writeSection(  std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{10559                             std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{10560                             SectionNode \textcolor{keyword}{const}\& sectionNode ) \{}
\DoxyCodeLine{10561             std::string name = trim( sectionNode.stats.sectionInfo.name );}
\DoxyCodeLine{10562             \textcolor{keywordflow}{if}( !rootName.empty() )}
\DoxyCodeLine{10563                 name = rootName + '/' + name;}
\DoxyCodeLine{10564 }
\DoxyCodeLine{10565             \textcolor{keywordflow}{if}( !sectionNode.assertions.empty() ||}
\DoxyCodeLine{10566                 !sectionNode.stdOut.empty() ||}
\DoxyCodeLine{10567                 !sectionNode.stdErr.empty() ) \{}
\DoxyCodeLine{10568                 XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"{}testcase"{}} );}
\DoxyCodeLine{10569                 \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{10570                     xml.writeAttribute( \textcolor{stringliteral}{"{}classname"{}}, name );}
\DoxyCodeLine{10571                     xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}root"{}} );}
\DoxyCodeLine{10572                 \}}
\DoxyCodeLine{10573                 \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10574                     xml.writeAttribute( \textcolor{stringliteral}{"{}classname"{}}, className );}
\DoxyCodeLine{10575                     xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, name );}
\DoxyCodeLine{10576                 \}}
\DoxyCodeLine{10577                 xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, Catch::toString( sectionNode.stats.durationInSeconds ) );}
\DoxyCodeLine{10578 }
\DoxyCodeLine{10579                 writeAssertions( sectionNode );}
\DoxyCodeLine{10580 }
\DoxyCodeLine{10581                 \textcolor{keywordflow}{if}( !sectionNode.stdOut.empty() )}
\DoxyCodeLine{10582                     xml.scopedElement( \textcolor{stringliteral}{"{}system-\/out"{}} ).writeText( trim( sectionNode.stdOut ), \textcolor{keyword}{false} );}
\DoxyCodeLine{10583                 \textcolor{keywordflow}{if}( !sectionNode.stdErr.empty() )}
\DoxyCodeLine{10584                     xml.scopedElement( \textcolor{stringliteral}{"{}system-\/err"{}} ).writeText( trim( sectionNode.stdErr ), \textcolor{keyword}{false} );}
\DoxyCodeLine{10585             \}}
\DoxyCodeLine{10586             \textcolor{keywordflow}{for}( SectionNode::ChildSections::const\_iterator}
\DoxyCodeLine{10587                     it = sectionNode.childSections.begin(),}
\DoxyCodeLine{10588                     itEnd = sectionNode.childSections.end();}
\DoxyCodeLine{10589                     it != itEnd;}
\DoxyCodeLine{10590                     ++it )}
\DoxyCodeLine{10591                 \textcolor{keywordflow}{if}( className.empty() )}
\DoxyCodeLine{10592                     writeSection( name, \textcolor{stringliteral}{"{}"{}}, **it );}
\DoxyCodeLine{10593                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{10594                     writeSection( className, name, **it );}
\DoxyCodeLine{10595         \}}
\DoxyCodeLine{10596 }
\DoxyCodeLine{10597         \textcolor{keywordtype}{void} writeAssertions( SectionNode \textcolor{keyword}{const}\& sectionNode ) \{}
\DoxyCodeLine{10598             \textcolor{keywordflow}{for}( SectionNode::Assertions::const\_iterator}
\DoxyCodeLine{10599                     it = sectionNode.assertions.begin(), itEnd = sectionNode.assertions.end();}
\DoxyCodeLine{10600                     it != itEnd;}
\DoxyCodeLine{10601                     ++it )}
\DoxyCodeLine{10602                 writeAssertion( *it );}
\DoxyCodeLine{10603         \}}
\DoxyCodeLine{10604         \textcolor{keywordtype}{void} writeAssertion( AssertionStats \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{10605             AssertionResult \textcolor{keyword}{const}\& result = stats.assertionResult;}
\DoxyCodeLine{10606             \textcolor{keywordflow}{if}( !result.isOk() ) \{}
\DoxyCodeLine{10607                 std::string elementName;}
\DoxyCodeLine{10608                 \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{10609                     \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{10610                     \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{10611                         elementName = \textcolor{stringliteral}{"{}error"{}};}
\DoxyCodeLine{10612                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10613                     \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{10614                         elementName = \textcolor{stringliteral}{"{}failure"{}};}
\DoxyCodeLine{10615                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10616                     \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{10617                         elementName = \textcolor{stringliteral}{"{}failure"{}};}
\DoxyCodeLine{10618                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10619                     \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{10620                         elementName = \textcolor{stringliteral}{"{}failure"{}};}
\DoxyCodeLine{10621                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10622 }
\DoxyCodeLine{10623                     \textcolor{comment}{// We should never see these here:}}
\DoxyCodeLine{10624                     \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{10625                     \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{10626                     \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{10627                     \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{10628                     \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{10629                     \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{10630                         elementName = \textcolor{stringliteral}{"{}internalError"{}};}
\DoxyCodeLine{10631                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10632                 \}}
\DoxyCodeLine{10633 }
\DoxyCodeLine{10634                 XmlWriter::ScopedElement e = xml.scopedElement( elementName );}
\DoxyCodeLine{10635 }
\DoxyCodeLine{10636                 xml.writeAttribute( \textcolor{stringliteral}{"{}message"{}}, result.getExpandedExpression() );}
\DoxyCodeLine{10637                 xml.writeAttribute( \textcolor{stringliteral}{"{}type"{}}, result.getTestMacroName() );}
\DoxyCodeLine{10638 }
\DoxyCodeLine{10639                 std::ostringstream oss;}
\DoxyCodeLine{10640                 \textcolor{keywordflow}{if}( !result.getMessage().empty() )}
\DoxyCodeLine{10641                     oss << result.getMessage() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10642                 \textcolor{keywordflow}{for}( std::vector<MessageInfo>::const\_iterator}
\DoxyCodeLine{10643                         it = stats.infoMessages.begin(),}
\DoxyCodeLine{10644                         itEnd = stats.infoMessages.end();}
\DoxyCodeLine{10645                             it != itEnd;}
\DoxyCodeLine{10646                             ++it )}
\DoxyCodeLine{10647                     \textcolor{keywordflow}{if}( it-\/>type == ResultWas::Info )}
\DoxyCodeLine{10648                         oss << it-\/>message << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10649 }
\DoxyCodeLine{10650                 oss << \textcolor{stringliteral}{"{}at "{}} << result.getSourceInfo();}
\DoxyCodeLine{10651                 xml.writeText( oss.str(), \textcolor{keyword}{false} );}
\DoxyCodeLine{10652             \}}
\DoxyCodeLine{10653         \}}
\DoxyCodeLine{10654 }
\DoxyCodeLine{10655         XmlWriter xml;}
\DoxyCodeLine{10656         Timer suiteTimer;}
\DoxyCodeLine{10657         std::ostringstream stdOutForSuite;}
\DoxyCodeLine{10658         std::ostringstream stdErrForSuite;}
\DoxyCodeLine{10659         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} unexpectedExceptions;}
\DoxyCodeLine{10660         \textcolor{keywordtype}{bool} m\_okToFail;}
\DoxyCodeLine{10661     \};}
\DoxyCodeLine{10662 }
\DoxyCodeLine{10663     INTERNAL\_CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}junit"{}}, JunitReporter )}
\DoxyCodeLine{10664 }
\DoxyCodeLine{10665 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10666 }
\DoxyCodeLine{10667 \textcolor{comment}{// \#included from: ../reporters/catch\_reporter\_console.hpp}}
\DoxyCodeLine{10668 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REPORTER\_CONSOLE\_HPP\_INCLUDED}}
\DoxyCodeLine{10669 }
\DoxyCodeLine{10670 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{10671 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{10672 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{10673 }
\DoxyCodeLine{10674 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10675 }
\DoxyCodeLine{10676     \textcolor{keyword}{struct }ConsoleReporter : StreamingReporterBase \{}
\DoxyCodeLine{10677         ConsoleReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{10678         :   StreamingReporterBase( \_config ),}
\DoxyCodeLine{10679             m\_headerPrinted( false )}
\DoxyCodeLine{10680         \{\}}
\DoxyCodeLine{10681 }
\DoxyCodeLine{10682         \textcolor{keyword}{virtual} \string~ConsoleReporter() CATCH\_OVERRIDE;}
\DoxyCodeLine{10683         static std::\textcolor{keywordtype}{string} getDescription() \{}
\DoxyCodeLine{10684             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results as plain lines of text"{}};}
\DoxyCodeLine{10685         \}}
\DoxyCodeLine{10686 }
\DoxyCodeLine{10687         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10688             stream << \textcolor{stringliteral}{"{}No test cases matched '"{}} << spec << \textcolor{charliteral}{'\(\backslash\)''} << std::endl;}
\DoxyCodeLine{10689         \}}
\DoxyCodeLine{10690 }
\DoxyCodeLine{10691         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10692         \}}
\DoxyCodeLine{10693 }
\DoxyCodeLine{10694         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& \_assertionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10695             AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{10696 }
\DoxyCodeLine{10697             \textcolor{keywordtype}{bool} includeResults = m\_config-\/>includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{10698 }
\DoxyCodeLine{10699             \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{10700             \textcolor{keywordflow}{if}( !includeResults \&\& result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{10701                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10702 }
\DoxyCodeLine{10703             lazyPrint();}
\DoxyCodeLine{10704 }
\DoxyCodeLine{10705             AssertionPrinter printer( stream, \_assertionStats, includeResults );}
\DoxyCodeLine{10706             printer.print();}
\DoxyCodeLine{10707             stream << std::endl;}
\DoxyCodeLine{10708             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{10709         \}}
\DoxyCodeLine{10710 }
\DoxyCodeLine{10711         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& \_sectionInfo ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10712             m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{10713             StreamingReporterBase::sectionStarting( \_sectionInfo );}
\DoxyCodeLine{10714         \}}
\DoxyCodeLine{10715         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& \_sectionStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10716             \textcolor{keywordflow}{if}( \_sectionStats.missingAssertions ) \{}
\DoxyCodeLine{10717                 lazyPrint();}
\DoxyCodeLine{10718                 Colour colour( Colour::ResultError );}
\DoxyCodeLine{10719                 \textcolor{keywordflow}{if}( m\_sectionStack.size() > 1 )}
\DoxyCodeLine{10720                     stream << \textcolor{stringliteral}{"{}\(\backslash\)nNo assertions in section"{}};}
\DoxyCodeLine{10721                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{10722                     stream << \textcolor{stringliteral}{"{}\(\backslash\)nNo assertions in test case"{}};}
\DoxyCodeLine{10723                 stream << \textcolor{stringliteral}{"{} '"{}} << \_sectionStats.sectionInfo.name << \textcolor{stringliteral}{"{}'\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{10724             \}}
\DoxyCodeLine{10725             \textcolor{keywordflow}{if}( m\_config-\/>showDurations() == ShowDurations::Always ) \{}
\DoxyCodeLine{10726                 stream << getFormattedDuration(\_sectionStats.durationInSeconds) << \textcolor{stringliteral}{"{} s: "{}} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{10727             \}}
\DoxyCodeLine{10728             \textcolor{keywordflow}{if}( m\_headerPrinted ) \{}
\DoxyCodeLine{10729                 m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{10730             \}}
\DoxyCodeLine{10731             StreamingReporterBase::sectionEnded( \_sectionStats );}
\DoxyCodeLine{10732         \}}
\DoxyCodeLine{10733 }
\DoxyCodeLine{10734         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10735             StreamingReporterBase::testCaseEnded( \_testCaseStats );}
\DoxyCodeLine{10736             m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{10737         \}}
\DoxyCodeLine{10738         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10739             \textcolor{keywordflow}{if}( currentGroupInfo.used ) \{}
\DoxyCodeLine{10740                 printSummaryDivider();}
\DoxyCodeLine{10741                 stream << \textcolor{stringliteral}{"{}Summary for group '"{}} << \_testGroupStats.groupInfo.name << \textcolor{stringliteral}{"{}':\(\backslash\)n"{}};}
\DoxyCodeLine{10742                 printTotals( \_testGroupStats.totals );}
\DoxyCodeLine{10743                 stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{10744             \}}
\DoxyCodeLine{10745             StreamingReporterBase::testGroupEnded( \_testGroupStats );}
\DoxyCodeLine{10746         \}}
\DoxyCodeLine{10747         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& \_testRunStats ) CATCH\_OVERRIDE \{}
\DoxyCodeLine{10748             printTotalsDivider( \_testRunStats.totals );}
\DoxyCodeLine{10749             printTotals( \_testRunStats.totals );}
\DoxyCodeLine{10750             stream << std::endl;}
\DoxyCodeLine{10751             StreamingReporterBase::testRunEnded( \_testRunStats );}
\DoxyCodeLine{10752         \}}
\DoxyCodeLine{10753 }
\DoxyCodeLine{10754     \textcolor{keyword}{private}:}
\DoxyCodeLine{10755 }
\DoxyCodeLine{10756         \textcolor{keyword}{class }AssertionPrinter \{}
\DoxyCodeLine{10757             \textcolor{keywordtype}{void} operator= ( AssertionPrinter \textcolor{keyword}{const}\& );}
\DoxyCodeLine{10758         \textcolor{keyword}{public}:}
\DoxyCodeLine{10759             AssertionPrinter( std::ostream\& \_stream, AssertionStats \textcolor{keyword}{const}\& \_stats, \textcolor{keywordtype}{bool} \_printInfoMessages )}
\DoxyCodeLine{10760             :   stream( \_stream ),}
\DoxyCodeLine{10761                 stats( \_stats ),}
\DoxyCodeLine{10762                 result( \_stats.assertionResult ),}
\DoxyCodeLine{10763                 colour( Colour::\mbox{\hyperlink{group__window_gga00319cf9896ddf15ebfe0c14ffbc8f60a8c35a9c8507559e455387fc4a83ce422}{None}} ),}
\DoxyCodeLine{10764                 message( result.getMessage() ),}
\DoxyCodeLine{10765                 messages( \_stats.infoMessages ),}
\DoxyCodeLine{10766                 printInfoMessages( \_printInfoMessages )}
\DoxyCodeLine{10767             \{}
\DoxyCodeLine{10768                 \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{10769                     \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{10770                         colour = Colour::Success;}
\DoxyCodeLine{10771                         passOrFail = \textcolor{stringliteral}{"{}PASSED"{}};}
\DoxyCodeLine{10772                         \textcolor{comment}{//if( result.hasMessage() )}}
\DoxyCodeLine{10773                         \textcolor{keywordflow}{if}( \_stats.infoMessages.size() == 1 )}
\DoxyCodeLine{10774                             messageLabel = \textcolor{stringliteral}{"{}with message"{}};}
\DoxyCodeLine{10775                         \textcolor{keywordflow}{if}( \_stats.infoMessages.size() > 1 )}
\DoxyCodeLine{10776                             messageLabel = \textcolor{stringliteral}{"{}with messages"{}};}
\DoxyCodeLine{10777                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10778                     \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{10779                         \textcolor{keywordflow}{if}( result.isOk() ) \{}
\DoxyCodeLine{10780                             colour = Colour::Success;}
\DoxyCodeLine{10781                             passOrFail = \textcolor{stringliteral}{"{}FAILED -\/ but was ok"{}};}
\DoxyCodeLine{10782                         \}}
\DoxyCodeLine{10783                         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10784                             colour = Colour::Error;}
\DoxyCodeLine{10785                             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{10786                         \}}
\DoxyCodeLine{10787                         \textcolor{keywordflow}{if}( \_stats.infoMessages.size() == 1 )}
\DoxyCodeLine{10788                             messageLabel = \textcolor{stringliteral}{"{}with message"{}};}
\DoxyCodeLine{10789                         \textcolor{keywordflow}{if}( \_stats.infoMessages.size() > 1 )}
\DoxyCodeLine{10790                             messageLabel = \textcolor{stringliteral}{"{}with messages"{}};}
\DoxyCodeLine{10791                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10792                     \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{10793                         colour = Colour::Error;}
\DoxyCodeLine{10794                         passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{10795                         messageLabel = \textcolor{stringliteral}{"{}due to unexpected exception with "{}};}
\DoxyCodeLine{10796                         \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{10797                             messageLabel += "{}message"{};}
\DoxyCodeLine{10798                         \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{10799                             messageLabel += "{}messages"{};}
\DoxyCodeLine{10800                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10801                     \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{10802                         colour = Colour::Error;}
\DoxyCodeLine{10803                         passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{10804                         messageLabel = \textcolor{stringliteral}{"{}due to a fatal error condition"{}};}
\DoxyCodeLine{10805                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10806                     \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{10807                         colour = Colour::Error;}
\DoxyCodeLine{10808                         passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{10809                         messageLabel = \textcolor{stringliteral}{"{}because no exception was thrown where one was expected"{}};}
\DoxyCodeLine{10810                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10811                     \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{10812                         messageLabel = \textcolor{stringliteral}{"{}info"{}};}
\DoxyCodeLine{10813                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10814                     \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{10815                         messageLabel = \textcolor{stringliteral}{"{}warning"{}};}
\DoxyCodeLine{10816                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10817                     \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{10818                         passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{10819                         colour = Colour::Error;}
\DoxyCodeLine{10820                         \textcolor{keywordflow}{if}( \_stats.infoMessages.size() == 1 )}
\DoxyCodeLine{10821                             messageLabel = \textcolor{stringliteral}{"{}explicitly with message"{}};}
\DoxyCodeLine{10822                         \textcolor{keywordflow}{if}( \_stats.infoMessages.size() > 1 )}
\DoxyCodeLine{10823                             messageLabel = \textcolor{stringliteral}{"{}explicitly with messages"{}};}
\DoxyCodeLine{10824                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10825                     \textcolor{comment}{// These cases are here to prevent compiler warnings}}
\DoxyCodeLine{10826                     \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{10827                     \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{10828                     \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{10829                         passOrFail = \textcolor{stringliteral}{"{}** internal error **"{}};}
\DoxyCodeLine{10830                         colour = Colour::Error;}
\DoxyCodeLine{10831                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{10832                 \}}
\DoxyCodeLine{10833             \}}
\DoxyCodeLine{10834 }
\DoxyCodeLine{10835             \textcolor{keywordtype}{void} print()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10836                 printSourceInfo();}
\DoxyCodeLine{10837                 \textcolor{keywordflow}{if}( stats.totals.assertions.total() > 0 ) \{}
\DoxyCodeLine{10838                     \textcolor{keywordflow}{if}( result.isOk() )}
\DoxyCodeLine{10839                         stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10840                     printResultType();}
\DoxyCodeLine{10841                     printOriginalExpression();}
\DoxyCodeLine{10842                     printReconstructedExpression();}
\DoxyCodeLine{10843                 \}}
\DoxyCodeLine{10844                 \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10845                     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10846                 \}}
\DoxyCodeLine{10847                 printMessage();}
\DoxyCodeLine{10848             \}}
\DoxyCodeLine{10849 }
\DoxyCodeLine{10850         \textcolor{keyword}{private}:}
\DoxyCodeLine{10851             \textcolor{keywordtype}{void} printResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10852                 \textcolor{keywordflow}{if}( !passOrFail.empty() ) \{}
\DoxyCodeLine{10853                     Colour colourGuard( colour );}
\DoxyCodeLine{10854                     stream << passOrFail << \textcolor{stringliteral}{"{}:\(\backslash\)n"{}};}
\DoxyCodeLine{10855                 \}}
\DoxyCodeLine{10856             \}}
\DoxyCodeLine{10857             \textcolor{keywordtype}{void} printOriginalExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10858                 \textcolor{keywordflow}{if}( result.hasExpression() ) \{}
\DoxyCodeLine{10859                     Colour colourGuard( Colour::OriginalExpression );}
\DoxyCodeLine{10860                     stream  << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{10861                     stream << result.getExpressionInMacro();}
\DoxyCodeLine{10862                     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10863                 \}}
\DoxyCodeLine{10864             \}}
\DoxyCodeLine{10865             \textcolor{keywordtype}{void} printReconstructedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10866                 \textcolor{keywordflow}{if}( result.hasExpandedExpression() ) \{}
\DoxyCodeLine{10867                     stream << \textcolor{stringliteral}{"{}with expansion:\(\backslash\)n"{}};}
\DoxyCodeLine{10868                     Colour colourGuard( Colour::ReconstructedExpression );}
\DoxyCodeLine{10869                     stream << Text( result.getExpandedExpression(), TextAttributes().setIndent(2) ) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10870                 \}}
\DoxyCodeLine{10871             \}}
\DoxyCodeLine{10872             \textcolor{keywordtype}{void} printMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10873                 \textcolor{keywordflow}{if}( !messageLabel.empty() )}
\DoxyCodeLine{10874                     stream << messageLabel << \textcolor{charliteral}{':'} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10875                 \textcolor{keywordflow}{for}( std::vector<MessageInfo>::const\_iterator it = messages.begin(), itEnd = messages.end();}
\DoxyCodeLine{10876                         it != itEnd;}
\DoxyCodeLine{10877                         ++it ) \{}
\DoxyCodeLine{10878                     \textcolor{comment}{// If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{10879                     \textcolor{keywordflow}{if}( printInfoMessages || it-\/>type != ResultWas::Info )}
\DoxyCodeLine{10880                         stream << Text( it-\/>message, TextAttributes().setIndent(2) ) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10881                 \}}
\DoxyCodeLine{10882             \}}
\DoxyCodeLine{10883             \textcolor{keywordtype}{void} printSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10884                 Colour colourGuard( Colour::FileName );}
\DoxyCodeLine{10885                 stream << result.getSourceInfo() << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{10886             \}}
\DoxyCodeLine{10887 }
\DoxyCodeLine{10888             std::ostream\& stream;}
\DoxyCodeLine{10889             AssertionStats \textcolor{keyword}{const}\& stats;}
\DoxyCodeLine{10890             AssertionResult \textcolor{keyword}{const}\& result;}
\DoxyCodeLine{10891             Colour::Code colour;}
\DoxyCodeLine{10892             std::string passOrFail;}
\DoxyCodeLine{10893             std::string messageLabel;}
\DoxyCodeLine{10894             std::string message;}
\DoxyCodeLine{10895             std::vector<MessageInfo> messages;}
\DoxyCodeLine{10896             \textcolor{keywordtype}{bool} printInfoMessages;}
\DoxyCodeLine{10897         \};}
\DoxyCodeLine{10898 }
\DoxyCodeLine{10899         \textcolor{keywordtype}{void} lazyPrint() \{}
\DoxyCodeLine{10900 }
\DoxyCodeLine{10901             \textcolor{keywordflow}{if}( !currentTestRunInfo.used )}
\DoxyCodeLine{10902                 lazyPrintRunInfo();}
\DoxyCodeLine{10903             \textcolor{keywordflow}{if}( !currentGroupInfo.used )}
\DoxyCodeLine{10904                 lazyPrintGroupInfo();}
\DoxyCodeLine{10905 }
\DoxyCodeLine{10906             \textcolor{keywordflow}{if}( !m\_headerPrinted ) \{}
\DoxyCodeLine{10907                 printTestCaseAndSectionHeader();}
\DoxyCodeLine{10908                 m\_headerPrinted = \textcolor{keyword}{true};}
\DoxyCodeLine{10909             \}}
\DoxyCodeLine{10910         \}}
\DoxyCodeLine{10911         \textcolor{keywordtype}{void} lazyPrintRunInfo() \{}
\DoxyCodeLine{10912             stream  << '\(\backslash\)n' << getLineOfChars<'\string~'>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10913             Colour colour( Colour::SecondaryText );}
\DoxyCodeLine{10914             stream  << currentTestRunInfo-\/>name}
\DoxyCodeLine{10915                     << \textcolor{stringliteral}{"{} is a Catch v"{}}  << libraryVersion() << \textcolor{stringliteral}{"{} host application.\(\backslash\)n"{}}}
\DoxyCodeLine{10916                     << \textcolor{stringliteral}{"{}Run with -\/? for options\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{10917 }
\DoxyCodeLine{10918             \textcolor{keywordflow}{if}( m\_config-\/>rngSeed() != 0 )}
\DoxyCodeLine{10919                 stream << \textcolor{stringliteral}{"{}Randomness seeded to: "{}} << m\_config-\/>rngSeed() << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{10920 }
\DoxyCodeLine{10921             currentTestRunInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{10922         \}}
\DoxyCodeLine{10923         \textcolor{keywordtype}{void} lazyPrintGroupInfo() \{}
\DoxyCodeLine{10924             \textcolor{keywordflow}{if}( !currentGroupInfo-\/>name.empty() \&\& currentGroupInfo-\/>groupsCounts > 1 ) \{}
\DoxyCodeLine{10925                 printClosedHeader( \textcolor{stringliteral}{"{}Group: "{}} + currentGroupInfo-\/>name );}
\DoxyCodeLine{10926                 currentGroupInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{10927             \}}
\DoxyCodeLine{10928         \}}
\DoxyCodeLine{10929         \textcolor{keywordtype}{void} printTestCaseAndSectionHeader() \{}
\DoxyCodeLine{10930             assert( !m\_sectionStack.empty() );}
\DoxyCodeLine{10931             printOpenHeader( currentTestCaseInfo-\/>name );}
\DoxyCodeLine{10932 }
\DoxyCodeLine{10933             \textcolor{keywordflow}{if}( m\_sectionStack.size() > 1 ) \{}
\DoxyCodeLine{10934                 Colour colourGuard( Colour::Headers );}
\DoxyCodeLine{10935 }
\DoxyCodeLine{10936                 std::vector<SectionInfo>::const\_iterator}
\DoxyCodeLine{10937                     it = m\_sectionStack.begin()+1, \textcolor{comment}{// Skip first section (test case)}}
\DoxyCodeLine{10938                     itEnd = m\_sectionStack.end();}
\DoxyCodeLine{10939                 \textcolor{keywordflow}{for}( ; it != itEnd; ++it )}
\DoxyCodeLine{10940                     printHeaderString( it-\/>name, 2 );}
\DoxyCodeLine{10941             \}}
\DoxyCodeLine{10942 }
\DoxyCodeLine{10943             SourceLineInfo lineInfo = m\_sectionStack.back().lineInfo;}
\DoxyCodeLine{10944 }
\DoxyCodeLine{10945             \textcolor{keywordflow}{if}( !lineInfo.empty() )\{}
\DoxyCodeLine{10946                 stream << getLineOfChars<\textcolor{stringliteral}{'-\/'}>() << \textcolor{stringliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10947                 Colour colourGuard( Colour::FileName );}
\DoxyCodeLine{10948                 stream << lineInfo << \textcolor{stringliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10949             \}}
\DoxyCodeLine{10950             stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{10951         \}}
\DoxyCodeLine{10952 }
\DoxyCodeLine{10953         \textcolor{keywordtype}{void} printClosedHeader( std::string \textcolor{keyword}{const}\& \_name ) \{}
\DoxyCodeLine{10954             printOpenHeader( \_name );}
\DoxyCodeLine{10955             stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10956         \}}
\DoxyCodeLine{10957         \textcolor{keywordtype}{void} printOpenHeader( std::string \textcolor{keyword}{const}\& \_name ) \{}
\DoxyCodeLine{10958             stream  << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10959             \{}
\DoxyCodeLine{10960                 Colour colourGuard( Colour::Headers );}
\DoxyCodeLine{10961                 printHeaderString( \_name );}
\DoxyCodeLine{10962             \}}
\DoxyCodeLine{10963         \}}
\DoxyCodeLine{10964 }
\DoxyCodeLine{10965         \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{10966         \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{10967         \textcolor{keywordtype}{void} printHeaderString( std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent = 0 ) \{}
\DoxyCodeLine{10968             std::size\_t i = \_string.find( \textcolor{stringliteral}{"{}: "{}} );}
\DoxyCodeLine{10969             \textcolor{keywordflow}{if}( i != std::string::npos )}
\DoxyCodeLine{10970                 i+=2;}
\DoxyCodeLine{10971             \textcolor{keywordflow}{else}}
\DoxyCodeLine{10972                 i = 0;}
\DoxyCodeLine{10973             stream << Text( \_string, TextAttributes()}
\DoxyCodeLine{10974                                         .setIndent( indent+i)}
\DoxyCodeLine{10975                                         .setInitialIndent( indent ) ) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10976         \}}
\DoxyCodeLine{10977 }
\DoxyCodeLine{10978         \textcolor{keyword}{struct }SummaryColumn \{}
\DoxyCodeLine{10979 }
\DoxyCodeLine{10980             SummaryColumn( std::string \textcolor{keyword}{const}\& \_label, Colour::Code \_colour )}
\DoxyCodeLine{10981             :   label( \_label ),}
\DoxyCodeLine{10982                 colour( \_colour )}
\DoxyCodeLine{10983             \{\}}
\DoxyCodeLine{10984             SummaryColumn addRow( std::size\_t count ) \{}
\DoxyCodeLine{10985                 std::ostringstream oss;}
\DoxyCodeLine{10986                 oss << count;}
\DoxyCodeLine{10987                 std::string row = oss.str();}
\DoxyCodeLine{10988                 \textcolor{keywordflow}{for}( std::vector<std::string>::iterator it = rows.begin(); it != rows.end(); ++it ) \{}
\DoxyCodeLine{10989                     \textcolor{keywordflow}{while}( it-\/>size() < row.size() )}
\DoxyCodeLine{10990                         *it = \textcolor{charliteral}{' '} + *it;}
\DoxyCodeLine{10991                     \textcolor{keywordflow}{while}( it-\/>size() > row.size() )}
\DoxyCodeLine{10992                         row = \textcolor{charliteral}{' '} + row;}
\DoxyCodeLine{10993                 \}}
\DoxyCodeLine{10994                 rows.push\_back( row );}
\DoxyCodeLine{10995                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10996             \}}
\DoxyCodeLine{10997 }
\DoxyCodeLine{10998             std::string label;}
\DoxyCodeLine{10999             Colour::Code colour;}
\DoxyCodeLine{11000             std::vector<std::string> rows;}
\DoxyCodeLine{11001 }
\DoxyCodeLine{11002         \};}
\DoxyCodeLine{11003 }
\DoxyCodeLine{11004         \textcolor{keywordtype}{void} printTotals( Totals \textcolor{keyword}{const}\& totals ) \{}
\DoxyCodeLine{11005             \textcolor{keywordflow}{if}( totals.testCases.total() == 0 ) \{}
\DoxyCodeLine{11006                 stream << Colour( Colour::Warning ) << \textcolor{stringliteral}{"{}No tests ran\(\backslash\)n"{}};}
\DoxyCodeLine{11007             \}}
\DoxyCodeLine{11008             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( totals.assertions.total() > 0 \&\& totals.testCases.allPassed() ) \{}
\DoxyCodeLine{11009                 stream << Colour( Colour::ResultSuccess ) << \textcolor{stringliteral}{"{}All tests passed"{}};}
\DoxyCodeLine{11010                 stream << \textcolor{stringliteral}{"{} ("{}}}
\DoxyCodeLine{11011                         << pluralise( totals.assertions.passed, \textcolor{stringliteral}{"{}assertion"{}} ) << \textcolor{stringliteral}{"{} in "{}}}
\DoxyCodeLine{11012                         << pluralise( totals.testCases.passed, \textcolor{stringliteral}{"{}test case"{}} ) << \textcolor{charliteral}{')'}}
\DoxyCodeLine{11013                         << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{11014             \}}
\DoxyCodeLine{11015             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11016 }
\DoxyCodeLine{11017                 std::vector<SummaryColumn> columns;}
\DoxyCodeLine{11018                 columns.push\_back( SummaryColumn( \textcolor{stringliteral}{"{}"{}}, Colour::None )}
\DoxyCodeLine{11019                                         .addRow( totals.testCases.total() )}
\DoxyCodeLine{11020                                         .addRow( totals.assertions.total() ) );}
\DoxyCodeLine{11021                 columns.push\_back( SummaryColumn( \textcolor{stringliteral}{"{}passed"{}}, Colour::Success )}
\DoxyCodeLine{11022                                         .addRow( totals.testCases.passed )}
\DoxyCodeLine{11023                                         .addRow( totals.assertions.passed ) );}
\DoxyCodeLine{11024                 columns.push\_back( SummaryColumn( \textcolor{stringliteral}{"{}failed"{}}, Colour::ResultError )}
\DoxyCodeLine{11025                                         .addRow( totals.testCases.failed )}
\DoxyCodeLine{11026                                         .addRow( totals.assertions.failed ) );}
\DoxyCodeLine{11027                 columns.push\_back( SummaryColumn( \textcolor{stringliteral}{"{}failed as expected"{}}, Colour::ResultExpectedFailure )}
\DoxyCodeLine{11028                                         .addRow( totals.testCases.failedButOk )}
\DoxyCodeLine{11029                                         .addRow( totals.assertions.failedButOk ) );}
\DoxyCodeLine{11030 }
\DoxyCodeLine{11031                 printSummaryRow( \textcolor{stringliteral}{"{}test cases"{}}, columns, 0 );}
\DoxyCodeLine{11032                 printSummaryRow( \textcolor{stringliteral}{"{}assertions"{}}, columns, 1 );}
\DoxyCodeLine{11033             \}}
\DoxyCodeLine{11034         \}}
\DoxyCodeLine{11035         \textcolor{keywordtype}{void} printSummaryRow( std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row ) \{}
\DoxyCodeLine{11036             \textcolor{keywordflow}{for}( std::vector<SummaryColumn>::const\_iterator it = cols.begin(); it != cols.end(); ++it ) \{}
\DoxyCodeLine{11037                 std::string value = it-\/>rows[row];}
\DoxyCodeLine{11038                 \textcolor{keywordflow}{if}( it-\/>label.empty() ) \{}
\DoxyCodeLine{11039                     stream << label << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{11040                     \textcolor{keywordflow}{if}( value != \textcolor{stringliteral}{"{}0"{}} )}
\DoxyCodeLine{11041                         stream << value;}
\DoxyCodeLine{11042                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{11043                         stream << Colour( Colour::Warning ) << \textcolor{stringliteral}{"{}-\/ none -\/"{}};}
\DoxyCodeLine{11044                 \}}
\DoxyCodeLine{11045                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( value != \textcolor{stringliteral}{"{}0"{}} ) \{}
\DoxyCodeLine{11046                     stream  << Colour( Colour::LightGrey ) << \textcolor{stringliteral}{"{} | "{}};}
\DoxyCodeLine{11047                     stream  << Colour( it-\/>colour )}
\DoxyCodeLine{11048                             << value << \textcolor{charliteral}{' '} << it-\/>label;}
\DoxyCodeLine{11049                 \}}
\DoxyCodeLine{11050             \}}
\DoxyCodeLine{11051             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{11052         \}}
\DoxyCodeLine{11053 }
\DoxyCodeLine{11054         \textcolor{keyword}{static} std::size\_t makeRatio( std::size\_t number, std::size\_t total ) \{}
\DoxyCodeLine{11055             std::size\_t ratio = total > 0 ? CATCH\_CONFIG\_CONSOLE\_WIDTH * number/ total : 0;}
\DoxyCodeLine{11056             \textcolor{keywordflow}{return} ( ratio == 0 \&\& number > 0 ) ? 1 : ratio;}
\DoxyCodeLine{11057         \}}
\DoxyCodeLine{11058         \textcolor{keyword}{static} std::size\_t\& findMax( std::size\_t\& i, std::size\_t\& j, std::size\_t\& k ) \{}
\DoxyCodeLine{11059             \textcolor{keywordflow}{if}( i > j \&\& i > k )}
\DoxyCodeLine{11060                 \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11061             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( j > k )}
\DoxyCodeLine{11062                 \textcolor{keywordflow}{return} j;}
\DoxyCodeLine{11063             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11064                 \textcolor{keywordflow}{return} k;}
\DoxyCodeLine{11065         \}}
\DoxyCodeLine{11066 }
\DoxyCodeLine{11067         \textcolor{keywordtype}{void} printTotalsDivider( Totals \textcolor{keyword}{const}\& totals ) \{}
\DoxyCodeLine{11068             \textcolor{keywordflow}{if}( totals.testCases.total() > 0 ) \{}
\DoxyCodeLine{11069                 std::size\_t failedRatio = makeRatio( totals.testCases.failed, totals.testCases.total() );}
\DoxyCodeLine{11070                 std::size\_t failedButOkRatio = makeRatio( totals.testCases.failedButOk, totals.testCases.total() );}
\DoxyCodeLine{11071                 std::size\_t passedRatio = makeRatio( totals.testCases.passed, totals.testCases.total() );}
\DoxyCodeLine{11072                 \textcolor{keywordflow}{while}( failedRatio + failedButOkRatio + passedRatio < CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1 )}
\DoxyCodeLine{11073                     findMax( failedRatio, failedButOkRatio, passedRatio )++;}
\DoxyCodeLine{11074                 \textcolor{keywordflow}{while}( failedRatio + failedButOkRatio + passedRatio > CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1 )}
\DoxyCodeLine{11075                     findMax( failedRatio, failedButOkRatio, passedRatio )-\/-\/;}
\DoxyCodeLine{11076 }
\DoxyCodeLine{11077                 stream << Colour( Colour::Error ) << std::string( failedRatio, \textcolor{charliteral}{'='} );}
\DoxyCodeLine{11078                 stream << Colour( Colour::ResultExpectedFailure ) << std::string( failedButOkRatio, \textcolor{charliteral}{'='} );}
\DoxyCodeLine{11079                 \textcolor{keywordflow}{if}( totals.testCases.allPassed() )}
\DoxyCodeLine{11080                     stream << Colour( Colour::ResultSuccess ) << std::string( passedRatio, \textcolor{charliteral}{'='} );}
\DoxyCodeLine{11081                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{11082                     stream << Colour( Colour::Success ) << std::string( passedRatio, \textcolor{charliteral}{'='} );}
\DoxyCodeLine{11083             \}}
\DoxyCodeLine{11084             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11085                 stream << Colour( Colour::Warning ) << std::string( CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1, \textcolor{charliteral}{'='} );}
\DoxyCodeLine{11086             \}}
\DoxyCodeLine{11087             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{11088         \}}
\DoxyCodeLine{11089         \textcolor{keywordtype}{void} printSummaryDivider() \{}
\DoxyCodeLine{11090             stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{11091         \}}
\DoxyCodeLine{11092 }
\DoxyCodeLine{11093     \textcolor{keyword}{private}:}
\DoxyCodeLine{11094         \textcolor{keywordtype}{bool} m\_headerPrinted;}
\DoxyCodeLine{11095     \};}
\DoxyCodeLine{11096 }
\DoxyCodeLine{11097     INTERNAL\_CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}console"{}}, ConsoleReporter )}
\DoxyCodeLine{11098 }
\DoxyCodeLine{11099 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11100 }
\DoxyCodeLine{11101 \textcolor{comment}{// \#included from: ../reporters/catch\_reporter\_compact.hpp}}
\DoxyCodeLine{11102 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REPORTER\_COMPACT\_HPP\_INCLUDED}}
\DoxyCodeLine{11103 }
\DoxyCodeLine{11104 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11105 }
\DoxyCodeLine{11106     \textcolor{keyword}{struct }CompactReporter : StreamingReporterBase \{}
\DoxyCodeLine{11107 }
\DoxyCodeLine{11108         CompactReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{11109         : StreamingReporterBase( \_config )}
\DoxyCodeLine{11110         \{\}}
\DoxyCodeLine{11111 }
\DoxyCodeLine{11112         \textcolor{keyword}{virtual} \string~CompactReporter();}
\DoxyCodeLine{11113 }
\DoxyCodeLine{11114         \textcolor{keyword}{static} std::string getDescription() \{}
\DoxyCodeLine{11115             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results on a single line, suitable for IDEs"{}};}
\DoxyCodeLine{11116         \}}
\DoxyCodeLine{11117 }
\DoxyCodeLine{11118         \textcolor{keyword}{virtual} ReporterPreferences getPreferences()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11119             ReporterPreferences prefs;}
\DoxyCodeLine{11120             prefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{11121             \textcolor{keywordflow}{return} prefs;}
\DoxyCodeLine{11122         \}}
\DoxyCodeLine{11123 }
\DoxyCodeLine{11124         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \{}
\DoxyCodeLine{11125             stream << \textcolor{stringliteral}{"{}No test cases matched '"{}} << spec << \textcolor{charliteral}{'\(\backslash\)''} << std::endl;}
\DoxyCodeLine{11126         \}}
\DoxyCodeLine{11127 }
\DoxyCodeLine{11128         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{11129 }
\DoxyCodeLine{11130         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& \_assertionStats ) \{}
\DoxyCodeLine{11131             AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{11132 }
\DoxyCodeLine{11133             \textcolor{keywordtype}{bool} printInfoMessages = \textcolor{keyword}{true};}
\DoxyCodeLine{11134 }
\DoxyCodeLine{11135             \textcolor{comment}{// Drop out if result was successful and we're not printing those}}
\DoxyCodeLine{11136             \textcolor{keywordflow}{if}( !m\_config-\/>includeSuccessfulResults() \&\& result.isOk() ) \{}
\DoxyCodeLine{11137                 \textcolor{keywordflow}{if}( result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{11138                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11139                 printInfoMessages = \textcolor{keyword}{false};}
\DoxyCodeLine{11140             \}}
\DoxyCodeLine{11141 }
\DoxyCodeLine{11142             AssertionPrinter printer( stream, \_assertionStats, printInfoMessages );}
\DoxyCodeLine{11143             printer.print();}
\DoxyCodeLine{11144 }
\DoxyCodeLine{11145             stream << std::endl;}
\DoxyCodeLine{11146             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11147         \}}
\DoxyCodeLine{11148 }
\DoxyCodeLine{11149         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) CATCH\_OVERRIDE \{}
\DoxyCodeLine{11150             \textcolor{keywordflow}{if} (m\_config-\/>showDurations() == ShowDurations::Always) \{}
\DoxyCodeLine{11151                 stream << getFormattedDuration(\_sectionStats.durationInSeconds) << \textcolor{stringliteral}{"{} s: "{}} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{11152             \}}
\DoxyCodeLine{11153         \}}
\DoxyCodeLine{11154 }
\DoxyCodeLine{11155         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& \_testRunStats ) \{}
\DoxyCodeLine{11156             printTotals( \_testRunStats.totals );}
\DoxyCodeLine{11157             stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11158             StreamingReporterBase::testRunEnded( \_testRunStats );}
\DoxyCodeLine{11159         \}}
\DoxyCodeLine{11160 }
\DoxyCodeLine{11161     \textcolor{keyword}{private}:}
\DoxyCodeLine{11162         \textcolor{keyword}{class }AssertionPrinter \{}
\DoxyCodeLine{11163             \textcolor{keywordtype}{void} operator= ( AssertionPrinter \textcolor{keyword}{const}\& );}
\DoxyCodeLine{11164         \textcolor{keyword}{public}:}
\DoxyCodeLine{11165             AssertionPrinter( std::ostream\& \_stream, AssertionStats \textcolor{keyword}{const}\& \_stats, \textcolor{keywordtype}{bool} \_printInfoMessages )}
\DoxyCodeLine{11166             : stream( \_stream )}
\DoxyCodeLine{11167             , stats( \_stats )}
\DoxyCodeLine{11168             , result( \_stats.assertionResult )}
\DoxyCodeLine{11169             , messages( \_stats.infoMessages )}
\DoxyCodeLine{11170             , itMessage( \_stats.infoMessages.begin() )}
\DoxyCodeLine{11171             , printInfoMessages( \_printInfoMessages )}
\DoxyCodeLine{11172             \{\}}
\DoxyCodeLine{11173 }
\DoxyCodeLine{11174             \textcolor{keywordtype}{void} print() \{}
\DoxyCodeLine{11175                 printSourceInfo();}
\DoxyCodeLine{11176 }
\DoxyCodeLine{11177                 itMessage = messages.begin();}
\DoxyCodeLine{11178 }
\DoxyCodeLine{11179                 \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{11180                     \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{11181                         printResultType( Colour::ResultSuccess, passedString() );}
\DoxyCodeLine{11182                         printOriginalExpression();}
\DoxyCodeLine{11183                         printReconstructedExpression();}
\DoxyCodeLine{11184                         \textcolor{keywordflow}{if} ( ! result.hasExpression() )}
\DoxyCodeLine{11185                             printRemainingMessages( Colour::None );}
\DoxyCodeLine{11186                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11187                             printRemainingMessages();}
\DoxyCodeLine{11188                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11189                     \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{11190                         \textcolor{keywordflow}{if}( result.isOk() )}
\DoxyCodeLine{11191                             printResultType( Colour::ResultSuccess, failedString() + std::string( \textcolor{stringliteral}{"{} -\/ but was ok"{}} ) );}
\DoxyCodeLine{11192                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11193                             printResultType( Colour::Error, failedString() );}
\DoxyCodeLine{11194                         printOriginalExpression();}
\DoxyCodeLine{11195                         printReconstructedExpression();}
\DoxyCodeLine{11196                         printRemainingMessages();}
\DoxyCodeLine{11197                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11198                     \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{11199                         printResultType( Colour::Error, failedString() );}
\DoxyCodeLine{11200                         printIssue( \textcolor{stringliteral}{"{}unexpected exception with message:"{}} );}
\DoxyCodeLine{11201                         printMessage();}
\DoxyCodeLine{11202                         printExpressionWas();}
\DoxyCodeLine{11203                         printRemainingMessages();}
\DoxyCodeLine{11204                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11205                     \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{11206                         printResultType( Colour::Error, failedString() );}
\DoxyCodeLine{11207                         printIssue( \textcolor{stringliteral}{"{}fatal error condition with message:"{}} );}
\DoxyCodeLine{11208                         printMessage();}
\DoxyCodeLine{11209                         printExpressionWas();}
\DoxyCodeLine{11210                         printRemainingMessages();}
\DoxyCodeLine{11211                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11212                     \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{11213                         printResultType( Colour::Error, failedString() );}
\DoxyCodeLine{11214                         printIssue( \textcolor{stringliteral}{"{}expected exception, got none"{}} );}
\DoxyCodeLine{11215                         printExpressionWas();}
\DoxyCodeLine{11216                         printRemainingMessages();}
\DoxyCodeLine{11217                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11218                     \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{11219                         printResultType( Colour::None, \textcolor{stringliteral}{"{}info"{}} );}
\DoxyCodeLine{11220                         printMessage();}
\DoxyCodeLine{11221                         printRemainingMessages();}
\DoxyCodeLine{11222                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11223                     \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{11224                         printResultType( Colour::None, \textcolor{stringliteral}{"{}warning"{}} );}
\DoxyCodeLine{11225                         printMessage();}
\DoxyCodeLine{11226                         printRemainingMessages();}
\DoxyCodeLine{11227                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11228                     \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{11229                         printResultType( Colour::Error, failedString() );}
\DoxyCodeLine{11230                         printIssue( \textcolor{stringliteral}{"{}explicitly"{}} );}
\DoxyCodeLine{11231                         printRemainingMessages( Colour::None );}
\DoxyCodeLine{11232                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11233                     \textcolor{comment}{// These cases are here to prevent compiler warnings}}
\DoxyCodeLine{11234                     \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{11235                     \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{11236                     \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{11237                         printResultType( Colour::Error, \textcolor{stringliteral}{"{}** internal error **"{}} );}
\DoxyCodeLine{11238                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{11239                 \}}
\DoxyCodeLine{11240             \}}
\DoxyCodeLine{11241 }
\DoxyCodeLine{11242         \textcolor{keyword}{private}:}
\DoxyCodeLine{11243             \textcolor{comment}{// Colour::LightGrey}}
\DoxyCodeLine{11244 }
\DoxyCodeLine{11245             \textcolor{keyword}{static} Colour::Code dimColour() \{ \textcolor{keywordflow}{return} Colour::FileName; \}}
\DoxyCodeLine{11246 }
\DoxyCodeLine{11247 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{11248             \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* failedString() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}FAILED"{}}; \}}
\DoxyCodeLine{11249             \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* passedString() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}PASSED"{}}; \}}
\DoxyCodeLine{11250 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11251             \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* failedString() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}failed"{}}; \}}
\DoxyCodeLine{11252             \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* passedString() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}passed"{}}; \}}
\DoxyCodeLine{11253 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11254 }
\DoxyCodeLine{11255             \textcolor{keywordtype}{void} printSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11256                 Colour colourGuard( Colour::FileName );}
\DoxyCodeLine{11257                 stream << result.getSourceInfo() << \textcolor{charliteral}{':'};}
\DoxyCodeLine{11258             \}}
\DoxyCodeLine{11259 }
\DoxyCodeLine{11260             \textcolor{keywordtype}{void} printResultType( Colour::Code colour, std::string \textcolor{keyword}{const}\& passOrFail )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11261                 \textcolor{keywordflow}{if}( !passOrFail.empty() ) \{}
\DoxyCodeLine{11262                     \{}
\DoxyCodeLine{11263                         Colour colourGuard( colour );}
\DoxyCodeLine{11264                         stream << \textcolor{charliteral}{' '} << passOrFail;}
\DoxyCodeLine{11265                     \}}
\DoxyCodeLine{11266                     stream << \textcolor{charliteral}{':'};}
\DoxyCodeLine{11267                 \}}
\DoxyCodeLine{11268             \}}
\DoxyCodeLine{11269 }
\DoxyCodeLine{11270             \textcolor{keywordtype}{void} printIssue( std::string \textcolor{keyword}{const}\& issue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11271                 stream << \textcolor{charliteral}{' '} << issue;}
\DoxyCodeLine{11272             \}}
\DoxyCodeLine{11273 }
\DoxyCodeLine{11274             \textcolor{keywordtype}{void} printExpressionWas() \{}
\DoxyCodeLine{11275                 \textcolor{keywordflow}{if}( result.hasExpression() ) \{}
\DoxyCodeLine{11276                     stream << \textcolor{charliteral}{';'};}
\DoxyCodeLine{11277                     \{}
\DoxyCodeLine{11278                         Colour colour( dimColour() );}
\DoxyCodeLine{11279                         stream << \textcolor{stringliteral}{"{} expression was:"{}};}
\DoxyCodeLine{11280                     \}}
\DoxyCodeLine{11281                     printOriginalExpression();}
\DoxyCodeLine{11282                 \}}
\DoxyCodeLine{11283             \}}
\DoxyCodeLine{11284 }
\DoxyCodeLine{11285             \textcolor{keywordtype}{void} printOriginalExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11286                 \textcolor{keywordflow}{if}( result.hasExpression() ) \{}
\DoxyCodeLine{11287                     stream << \textcolor{charliteral}{' '} << result.getExpression();}
\DoxyCodeLine{11288                 \}}
\DoxyCodeLine{11289             \}}
\DoxyCodeLine{11290 }
\DoxyCodeLine{11291             \textcolor{keywordtype}{void} printReconstructedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11292                 \textcolor{keywordflow}{if}( result.hasExpandedExpression() ) \{}
\DoxyCodeLine{11293                     \{}
\DoxyCodeLine{11294                         Colour colour( dimColour() );}
\DoxyCodeLine{11295                         stream << \textcolor{stringliteral}{"{} for: "{}};}
\DoxyCodeLine{11296                     \}}
\DoxyCodeLine{11297                     stream << result.getExpandedExpression();}
\DoxyCodeLine{11298                 \}}
\DoxyCodeLine{11299             \}}
\DoxyCodeLine{11300 }
\DoxyCodeLine{11301             \textcolor{keywordtype}{void} printMessage() \{}
\DoxyCodeLine{11302                 \textcolor{keywordflow}{if} ( itMessage != messages.end() ) \{}
\DoxyCodeLine{11303                     stream << \textcolor{stringliteral}{"{} '"{}} << itMessage-\/>message << \textcolor{charliteral}{'\(\backslash\)''};}
\DoxyCodeLine{11304                     ++itMessage;}
\DoxyCodeLine{11305                 \}}
\DoxyCodeLine{11306             \}}
\DoxyCodeLine{11307 }
\DoxyCodeLine{11308             \textcolor{keywordtype}{void} printRemainingMessages( Colour::Code colour = dimColour() ) \{}
\DoxyCodeLine{11309                 \textcolor{keywordflow}{if} ( itMessage == messages.end() )}
\DoxyCodeLine{11310                     \textcolor{keywordflow}{return};}
\DoxyCodeLine{11311 }
\DoxyCodeLine{11312                 \textcolor{comment}{// using messages.end() directly yields compilation error:}}
\DoxyCodeLine{11313                 std::vector<MessageInfo>::const\_iterator itEnd = messages.end();}
\DoxyCodeLine{11314                 \textcolor{keyword}{const} std::size\_t N = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}( std::distance( itMessage, itEnd ) );}
\DoxyCodeLine{11315 }
\DoxyCodeLine{11316                 \{}
\DoxyCodeLine{11317                     Colour colourGuard( colour );}
\DoxyCodeLine{11318                     stream << \textcolor{stringliteral}{"{} with "{}} << pluralise( N, \textcolor{stringliteral}{"{}message"{}} ) << \textcolor{charliteral}{':'};}
\DoxyCodeLine{11319                 \}}
\DoxyCodeLine{11320 }
\DoxyCodeLine{11321                 \textcolor{keywordflow}{for}(; itMessage != itEnd; ) \{}
\DoxyCodeLine{11322                     \textcolor{comment}{// If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{11323                     \textcolor{keywordflow}{if}( printInfoMessages || itMessage-\/>type != ResultWas::Info ) \{}
\DoxyCodeLine{11324                         stream << \textcolor{stringliteral}{"{} '"{}} << itMessage-\/>message << \textcolor{charliteral}{'\(\backslash\)''};}
\DoxyCodeLine{11325                         \textcolor{keywordflow}{if} ( ++itMessage != itEnd ) \{}
\DoxyCodeLine{11326                             Colour colourGuard( dimColour() );}
\DoxyCodeLine{11327                             stream << \textcolor{stringliteral}{"{} and"{}};}
\DoxyCodeLine{11328                         \}}
\DoxyCodeLine{11329                     \}}
\DoxyCodeLine{11330                 \}}
\DoxyCodeLine{11331             \}}
\DoxyCodeLine{11332 }
\DoxyCodeLine{11333         \textcolor{keyword}{private}:}
\DoxyCodeLine{11334             std::ostream\& stream;}
\DoxyCodeLine{11335             AssertionStats \textcolor{keyword}{const}\& stats;}
\DoxyCodeLine{11336             AssertionResult \textcolor{keyword}{const}\& result;}
\DoxyCodeLine{11337             std::vector<MessageInfo> messages;}
\DoxyCodeLine{11338             std::vector<MessageInfo>::const\_iterator itMessage;}
\DoxyCodeLine{11339             \textcolor{keywordtype}{bool} printInfoMessages;}
\DoxyCodeLine{11340         \};}
\DoxyCodeLine{11341 }
\DoxyCodeLine{11342         \textcolor{comment}{// Colour, message variants:}}
\DoxyCodeLine{11343         \textcolor{comment}{// -\/ white: No tests ran.}}
\DoxyCodeLine{11344         \textcolor{comment}{// -\/   red: Failed [both/all] N test cases, failed [both/all] M assertions.}}
\DoxyCodeLine{11345         \textcolor{comment}{// -\/ white: Passed [both/all] N test cases (no assertions).}}
\DoxyCodeLine{11346         \textcolor{comment}{// -\/   red: Failed N tests cases, failed M assertions.}}
\DoxyCodeLine{11347         \textcolor{comment}{// -\/ green: Passed [both/all] N tests cases with M assertions.}}
\DoxyCodeLine{11348 }
\DoxyCodeLine{11349         std::string bothOrAll( std::size\_t count )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11350             \textcolor{keywordflow}{return} count == 1 ? std::string() : count == 2 ? \textcolor{stringliteral}{"{}both "{}} : \textcolor{stringliteral}{"{}all "{}} ;}
\DoxyCodeLine{11351         \}}
\DoxyCodeLine{11352 }
\DoxyCodeLine{11353         \textcolor{keywordtype}{void} printTotals( \textcolor{keyword}{const} Totals\& totals )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11354             \textcolor{keywordflow}{if}( totals.testCases.total() == 0 ) \{}
\DoxyCodeLine{11355                 stream << \textcolor{stringliteral}{"{}No tests ran."{}};}
\DoxyCodeLine{11356             \}}
\DoxyCodeLine{11357             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( totals.testCases.failed == totals.testCases.total() ) \{}
\DoxyCodeLine{11358                 Colour colour( Colour::ResultError );}
\DoxyCodeLine{11359                 \textcolor{keyword}{const} std::string qualify\_assertions\_failed =}
\DoxyCodeLine{11360                     totals.assertions.failed == totals.assertions.total() ?}
\DoxyCodeLine{11361                         bothOrAll( totals.assertions.failed ) : std::string();}
\DoxyCodeLine{11362                 stream <<}
\DoxyCodeLine{11363                     \textcolor{stringliteral}{"{}Failed "{}} << bothOrAll( totals.testCases.failed )}
\DoxyCodeLine{11364                               << pluralise( totals.testCases.failed, \textcolor{stringliteral}{"{}test case"{}}  ) << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{11365                     \textcolor{stringliteral}{"{}failed "{}} << qualify\_assertions\_failed <<}
\DoxyCodeLine{11366                                  pluralise( totals.assertions.failed, \textcolor{stringliteral}{"{}assertion"{}} ) << \textcolor{charliteral}{'.'};}
\DoxyCodeLine{11367             \}}
\DoxyCodeLine{11368             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( totals.assertions.total() == 0 ) \{}
\DoxyCodeLine{11369                 stream <<}
\DoxyCodeLine{11370                     \textcolor{stringliteral}{"{}Passed "{}} << bothOrAll( totals.testCases.total() )}
\DoxyCodeLine{11371                               << pluralise( totals.testCases.total(), \textcolor{stringliteral}{"{}test case"{}} )}
\DoxyCodeLine{11372                               << \textcolor{stringliteral}{"{} (no assertions)."{}};}
\DoxyCodeLine{11373             \}}
\DoxyCodeLine{11374             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( totals.assertions.failed ) \{}
\DoxyCodeLine{11375                 Colour colour( Colour::ResultError );}
\DoxyCodeLine{11376                 stream <<}
\DoxyCodeLine{11377                     \textcolor{stringliteral}{"{}Failed "{}} << pluralise( totals.testCases.failed, \textcolor{stringliteral}{"{}test case"{}}  ) << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{11378                     \textcolor{stringliteral}{"{}failed "{}} << pluralise( totals.assertions.failed, \textcolor{stringliteral}{"{}assertion"{}} ) << \textcolor{charliteral}{'.'};}
\DoxyCodeLine{11379             \}}
\DoxyCodeLine{11380             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11381                 Colour colour( Colour::ResultSuccess );}
\DoxyCodeLine{11382                 stream <<}
\DoxyCodeLine{11383                     \textcolor{stringliteral}{"{}Passed "{}} << bothOrAll( totals.testCases.passed )}
\DoxyCodeLine{11384                               << pluralise( totals.testCases.passed, \textcolor{stringliteral}{"{}test case"{}}  ) <<}
\DoxyCodeLine{11385                     \textcolor{stringliteral}{"{} with "{}}  << pluralise( totals.assertions.passed, \textcolor{stringliteral}{"{}assertion"{}} ) << \textcolor{charliteral}{'.'};}
\DoxyCodeLine{11386             \}}
\DoxyCodeLine{11387         \}}
\DoxyCodeLine{11388     \};}
\DoxyCodeLine{11389 }
\DoxyCodeLine{11390     INTERNAL\_CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}compact"{}}, CompactReporter )}
\DoxyCodeLine{11391 }
\DoxyCodeLine{11392 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11393 }
\DoxyCodeLine{11394 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11395     \textcolor{comment}{// These are all here to avoid warnings about not having any out of line}}
\DoxyCodeLine{11396     \textcolor{comment}{// virtual methods}}
\DoxyCodeLine{11397     NonCopyable::\string~NonCopyable() \{\}}
\DoxyCodeLine{11398     IShared::\string~IShared() \{\}}
\DoxyCodeLine{11399     IStream::\string~IStream() CATCH\_NOEXCEPT \{\}}
\DoxyCodeLine{11400     FileStream::\string~FileStream() CATCH\_NOEXCEPT \{\}}
\DoxyCodeLine{11401     CoutStream::\string~CoutStream() CATCH\_NOEXCEPT \{\}}
\DoxyCodeLine{11402     DebugOutStream::\string~DebugOutStream() CATCH\_NOEXCEPT \{\}}
\DoxyCodeLine{11403     StreamBufBase::\string~StreamBufBase() CATCH\_NOEXCEPT \{\}}
\DoxyCodeLine{11404     IContext::\string~IContext() \{\}}
\DoxyCodeLine{11405     IResultCapture::\string~IResultCapture() \{\}}
\DoxyCodeLine{11406     ITestCase::\string~ITestCase() \{\}}
\DoxyCodeLine{11407     ITestCaseRegistry::\string~ITestCaseRegistry() \{\}}
\DoxyCodeLine{11408     IRegistryHub::\string~IRegistryHub() \{\}}
\DoxyCodeLine{11409     IMutableRegistryHub::\string~IMutableRegistryHub() \{\}}
\DoxyCodeLine{11410     IExceptionTranslator::\string~IExceptionTranslator() \{\}}
\DoxyCodeLine{11411     IExceptionTranslatorRegistry::\string~IExceptionTranslatorRegistry() \{\}}
\DoxyCodeLine{11412     IReporter::\string~IReporter() \{\}}
\DoxyCodeLine{11413     IReporterFactory::\string~IReporterFactory() \{\}}
\DoxyCodeLine{11414     IReporterRegistry::\string~IReporterRegistry() \{\}}
\DoxyCodeLine{11415     IStreamingReporter::\string~IStreamingReporter() \{\}}
\DoxyCodeLine{11416     AssertionStats::\string~AssertionStats() \{\}}
\DoxyCodeLine{11417     SectionStats::\string~SectionStats() \{\}}
\DoxyCodeLine{11418     TestCaseStats::\string~TestCaseStats() \{\}}
\DoxyCodeLine{11419     TestGroupStats::\string~TestGroupStats() \{\}}
\DoxyCodeLine{11420     TestRunStats::\string~TestRunStats() \{\}}
\DoxyCodeLine{11421     CumulativeReporterBase::SectionNode::\string~SectionNode() \{\}}
\DoxyCodeLine{11422     CumulativeReporterBase::\string~CumulativeReporterBase() \{\}}
\DoxyCodeLine{11423 }
\DoxyCodeLine{11424     StreamingReporterBase::\string~StreamingReporterBase() \{\}}
\DoxyCodeLine{11425     ConsoleReporter::\string~ConsoleReporter() \{\}}
\DoxyCodeLine{11426     CompactReporter::\string~CompactReporter() \{\}}
\DoxyCodeLine{11427     IRunner::\string~IRunner() \{\}}
\DoxyCodeLine{11428     IMutableContext::\string~IMutableContext() \{\}}
\DoxyCodeLine{11429     IConfig::\string~IConfig() \{\}}
\DoxyCodeLine{11430     XmlReporter::\string~XmlReporter() \{\}}
\DoxyCodeLine{11431     JunitReporter::\string~JunitReporter() \{\}}
\DoxyCodeLine{11432     TestRegistry::\string~TestRegistry() \{\}}
\DoxyCodeLine{11433     FreeFunctionTestCase::\string~FreeFunctionTestCase() \{\}}
\DoxyCodeLine{11434     IGeneratorInfo::\string~IGeneratorInfo() \{\}}
\DoxyCodeLine{11435     IGeneratorsForTest::\string~IGeneratorsForTest() \{\}}
\DoxyCodeLine{11436     WildcardPattern::\string~WildcardPattern() \{\}}
\DoxyCodeLine{11437     TestSpec::Pattern::\string~Pattern() \{\}}
\DoxyCodeLine{11438     TestSpec::NamePattern::\string~NamePattern() \{\}}
\DoxyCodeLine{11439     TestSpec::TagPattern::\string~TagPattern() \{\}}
\DoxyCodeLine{11440     TestSpec::ExcludedPattern::\string~ExcludedPattern() \{\}}
\DoxyCodeLine{11441     Matchers::Impl::MatcherUntypedBase::\string~MatcherUntypedBase() \{\}}
\DoxyCodeLine{11442 }
\DoxyCodeLine{11443     \textcolor{keywordtype}{void} Config::dummy() \{\}}
\DoxyCodeLine{11444 }
\DoxyCodeLine{11445     \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{11446         ITracker::\string~ITracker() \{\}}
\DoxyCodeLine{11447         TrackerBase::\string~TrackerBase() \{\}}
\DoxyCodeLine{11448         SectionTracker::\string~SectionTracker() \{\}}
\DoxyCodeLine{11449         IndexTracker::\string~IndexTracker() \{\}}
\DoxyCodeLine{11450     \}}
\DoxyCodeLine{11451 \}}
\DoxyCodeLine{11452 }
\DoxyCodeLine{11453 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{11454 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{11455 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11456 }
\DoxyCodeLine{11457 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11458 }
\DoxyCodeLine{11459 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_MAIN}}
\DoxyCodeLine{11460 \textcolor{comment}{// \#included from: internal/catch\_default\_main.hpp}}
\DoxyCodeLine{11461 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_DEFAULT\_MAIN\_HPP\_INCLUDED}}
\DoxyCodeLine{11462 }
\DoxyCodeLine{11463 \textcolor{preprocessor}{\#ifndef \_\_OBJC\_\_}}
\DoxyCodeLine{11464 }
\DoxyCodeLine{11465 \textcolor{preprocessor}{\#if defined(WIN32) \&\& defined(\_UNICODE) \&\& !defined(DO\_NOT\_USE\_WMAIN)}}
\DoxyCodeLine{11466 \textcolor{comment}{// Standard C/C++ Win32 Unicode wmain entry point}}
\DoxyCodeLine{11467 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \textcolor{keywordtype}{int} wmain (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} * argv[], \textcolor{keywordtype}{wchar\_t} * []) \{}
\DoxyCodeLine{11468 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11469 \textcolor{comment}{// Standard C/C++ main entry point}}
\DoxyCodeLine{11470 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * argv[]) \{}
\DoxyCodeLine{11471 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11472 }
\DoxyCodeLine{11473     \textcolor{keywordtype}{int} result = Catch::Session().run( argc, argv );}
\DoxyCodeLine{11474     \textcolor{keywordflow}{return} ( result < 0xff ? result : 0xff );}
\DoxyCodeLine{11475 \}}
\DoxyCodeLine{11476 }
\DoxyCodeLine{11477 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{11478 }
\DoxyCodeLine{11479 \textcolor{comment}{// Objective-\/C entry point}}
\DoxyCodeLine{11480 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{11481 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{11482     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];}
\DoxyCodeLine{11483 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11484 }
\DoxyCodeLine{11485     Catch::registerTestMethods();}
\DoxyCodeLine{11486     \textcolor{keywordtype}{int} result = Catch::Session().run( argc, (\textcolor{keywordtype}{char}* \textcolor{keyword}{const}*)argv );}
\DoxyCodeLine{11487 }
\DoxyCodeLine{11488 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{11489     [pool drain];}
\DoxyCodeLine{11490 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11491 }
\DoxyCodeLine{11492     \textcolor{keywordflow}{return} ( result < 0xff ? result : 0xff );}
\DoxyCodeLine{11493 \}}
\DoxyCodeLine{11494 }
\DoxyCodeLine{11495 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{11496 }
\DoxyCodeLine{11497 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11498 }
\DoxyCodeLine{11499 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{11500 \textcolor{preprocessor}{\#  undef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{11501 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11502 }
\DoxyCodeLine{11504 }
\DoxyCodeLine{11505 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{11506 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{11507 }
\DoxyCodeLine{11508 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE)}}
\DoxyCodeLine{11509 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( expr ) INTERNAL\_CATCH\_TEST\_NO\_TRY( "{}CATCH\_REQUIRE"{}}, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{11510 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( expr ) INTERNAL\_CATCH\_TEST\_NO\_TRY( "{}CATCH\_REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )}
\DoxyCodeLine{11511 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11512 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( expr ) INTERNAL\_CATCH\_TEST( "{}CATCH\_REQUIRE"{}}, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{11513 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( expr ) INTERNAL\_CATCH\_TEST( "{}CATCH\_REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr  )}
\DoxyCodeLine{11514 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11515 }
\DoxyCodeLine{11516 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( expr ) INTERNAL\_CATCH\_THROWS( "{}CATCH\_REQUIRE\_THROWS"{}}, Catch::ResultDisposition::Normal, "{}"{}, expr )}
\DoxyCodeLine{11517 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CATCH\_REQUIRE\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{11518 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS( "{}CATCH\_REQUIRE\_THROWS\_WITH"{}}, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{11519 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( expr ) INTERNAL\_CATCH\_NO\_THROW( "{}CATCH\_REQUIRE\_NOTHROW"{}}, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{11520 }
\DoxyCodeLine{11521 \textcolor{preprocessor}{\#define CATCH\_CHECK( expr ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK"{}}, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11522 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( expr ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK\_FALSE"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, expr )}
\DoxyCodeLine{11523 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( expr ) INTERNAL\_CATCH\_IF( "{}CATCH\_CHECKED\_IF"{}}, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11524 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( expr ) INTERNAL\_CATCH\_ELSE( "{}CATCH\_CHECKED\_ELSE"{}}, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11525 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( expr ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK\_NOFAIL"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, expr )}
\DoxyCodeLine{11526 }
\DoxyCodeLine{11527 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( expr )  INTERNAL\_CATCH\_THROWS( "{}CATCH\_CHECK\_THROWS"{}}, Catch::ResultDisposition::ContinueOnFailure, "{}"{}, expr )}
\DoxyCodeLine{11528 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CATCH\_CHECK\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11529 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS( "{}CATCH\_CHECK\_THROWS\_WITH"{}}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{11530 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( expr ) INTERNAL\_CATCH\_NO\_THROW( "{}CATCH\_CHECK\_NOTHROW"{}}, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11531 }
\DoxyCodeLine{11532 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CATCH\_CHECK\_THAT"{}}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}
\DoxyCodeLine{11533 }
\DoxyCodeLine{11534 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE)}}
\DoxyCodeLine{11535 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT\_NO\_TRY( "{}CATCH\_REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{11536 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11537 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CATCH\_REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{11538 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11539 }
\DoxyCodeLine{11540 \textcolor{preprocessor}{\#define CATCH\_INFO( msg ) INTERNAL\_CATCH\_INFO( "{}CATCH\_INFO"{}}, msg )}
\DoxyCodeLine{11541 \textcolor{preprocessor}{\#define CATCH\_WARN( msg ) INTERNAL\_CATCH\_MSG( "{}CATCH\_WARN"{}}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{11542 \textcolor{preprocessor}{\#define CATCH\_SCOPED\_INFO( msg ) INTERNAL\_CATCH\_INFO( "{}CATCH\_INFO"{}}, msg )}
\DoxyCodeLine{11543 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( msg ) INTERNAL\_CATCH\_INFO( "{}CATCH\_CAPTURE"{}}, \#msg "{} := "{} << Catch::toString(msg) )}
\DoxyCodeLine{11544 \textcolor{preprocessor}{\#define CATCH\_SCOPED\_CAPTURE( msg ) INTERNAL\_CATCH\_INFO( "{}CATCH\_CAPTURE"{}}, \#msg "{} := "{} << Catch::toString(msg) )}
\DoxyCodeLine{11545 }
\DoxyCodeLine{11546 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{11547 \textcolor{preprocessor}{    \#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11548 \textcolor{preprocessor}{    \#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11549 \textcolor{preprocessor}{    \#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11550 \textcolor{preprocessor}{    \#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11551 \textcolor{preprocessor}{    \#define CATCH\_SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11552 \textcolor{preprocessor}{    \#define CATCH\_FAIL( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11553 \textcolor{preprocessor}{    \#define CATCH\_FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11554 \textcolor{preprocessor}{    \#define CATCH\_SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11555 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11556 \textcolor{preprocessor}{    \#define CATCH\_TEST\_CASE( name, description ) INTERNAL\_CATCH\_TESTCASE( name, description )}}
\DoxyCodeLine{11557 \textcolor{preprocessor}{    \#define CATCH\_TEST\_CASE\_METHOD( className, name, description ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, name, description )}}
\DoxyCodeLine{11558 \textcolor{preprocessor}{    \#define CATCH\_METHOD\_AS\_TEST\_CASE( method, name, description ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, name, description )}}
\DoxyCodeLine{11559 \textcolor{preprocessor}{    \#define CATCH\_REGISTER\_TEST\_CASE( function, name, description ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( function, name, description )}}
\DoxyCodeLine{11560 \textcolor{preprocessor}{    \#define CATCH\_SECTION( name, description ) INTERNAL\_CATCH\_SECTION( name, description )}}
\DoxyCodeLine{11561 \textcolor{preprocessor}{    \#define CATCH\_FAIL( msg ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, msg )}
\DoxyCodeLine{11562 \textcolor{preprocessor}{    \#define CATCH\_FAIL\_CHECK( msg ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{11563 \textcolor{preprocessor}{    \#define CATCH\_SUCCEED( msg ) INTERNAL\_CATCH\_MSG( "{}CATCH\_SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{11564 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11565 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE( "{}"{}}, "{}"{} )}
\DoxyCodeLine{11566 }
\DoxyCodeLine{11567 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER( name, reporterType ) INTERNAL\_CATCH\_REGISTER\_REPORTER( name, reporterType )}}
\DoxyCodeLine{11568 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LEGACY\_REPORTER( name, reporterType ) INTERNAL\_CATCH\_REGISTER\_LEGACY\_REPORTER( name, reporterType )}}
\DoxyCodeLine{11569 }
\DoxyCodeLine{11570 \textcolor{preprocessor}{\#define CATCH\_GENERATE( expr) INTERNAL\_CATCH\_GENERATE( expr )}}
\DoxyCodeLine{11571 }
\DoxyCodeLine{11572 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{11573 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{11574 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) CATCH\_TEST\_CASE( "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11575 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11576 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11577 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( name, tags ) CATCH\_TEST\_CASE( "{}Scenario: "{}} name, tags )}
\DoxyCodeLine{11578 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, name, tags ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} name, tags )}
\DoxyCodeLine{11579 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11580 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )    CATCH\_SECTION( std::string( "{}Given: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11581 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )     CATCH\_SECTION( std::string( "{} When: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11582 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc ) CATCH\_SECTION( std::string( "{}  And: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11583 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )     CATCH\_SECTION( std::string( "{} Then: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11584 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc ) CATCH\_SECTION( std::string( "{}  And: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11585 }
\DoxyCodeLine{11586 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{11587 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11588 }
\DoxyCodeLine{11589 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE)}}
\DoxyCodeLine{11590 \textcolor{preprocessor}{\#define REQUIRE( expr ) INTERNAL\_CATCH\_TEST\_NO\_TRY( "{}REQUIRE"{}}, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{11591 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( expr ) INTERNAL\_CATCH\_TEST\_NO\_TRY( "{}REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )}
\DoxyCodeLine{11592 }
\DoxyCodeLine{11593 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11594 \textcolor{preprocessor}{\#define REQUIRE( expr ) INTERNAL\_CATCH\_TEST( "{}REQUIRE"{}}, Catch::ResultDisposition::Normal, expr  )}
\DoxyCodeLine{11595 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( expr ) INTERNAL\_CATCH\_TEST( "{}REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )}
\DoxyCodeLine{11596 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11597 }
\DoxyCodeLine{11598 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( expr ) INTERNAL\_CATCH\_THROWS( "{}REQUIRE\_THROWS"{}}, Catch::ResultDisposition::Normal, "{}"{}, expr )}
\DoxyCodeLine{11599 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}REQUIRE\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{11600 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS( "{}REQUIRE\_THROWS\_WITH"{}}, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{11601 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( expr ) INTERNAL\_CATCH\_NO\_THROW( "{}REQUIRE\_NOTHROW"{}}, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{11602 }
\DoxyCodeLine{11603 \textcolor{preprocessor}{\#define CHECK( expr ) INTERNAL\_CATCH\_TEST( "{}CHECK"{}}, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11604 \textcolor{preprocessor}{\#define CHECK\_FALSE( expr ) INTERNAL\_CATCH\_TEST( "{}CHECK\_FALSE"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, expr )}
\DoxyCodeLine{11605 \textcolor{preprocessor}{\#define CHECKED\_IF( expr ) INTERNAL\_CATCH\_IF( "{}CHECKED\_IF"{}}, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11606 \textcolor{preprocessor}{\#define CHECKED\_ELSE( expr ) INTERNAL\_CATCH\_ELSE( "{}CHECKED\_ELSE"{}}, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11607 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( expr ) INTERNAL\_CATCH\_TEST( "{}CHECK\_NOFAIL"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, expr )}
\DoxyCodeLine{11608 }
\DoxyCodeLine{11609 \textcolor{preprocessor}{\#define CHECK\_THROWS( expr )  INTERNAL\_CATCH\_THROWS( "{}CHECK\_THROWS"{}}, Catch::ResultDisposition::ContinueOnFailure, "{}"{}, expr )}
\DoxyCodeLine{11610 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CHECK\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11611 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS( "{}CHECK\_THROWS\_WITH"{}}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{11612 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( expr ) INTERNAL\_CATCH\_NO\_THROW( "{}CHECK\_NOTHROW"{}}, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{11613 }
\DoxyCodeLine{11614 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CHECK\_THAT"{}}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}
\DoxyCodeLine{11615 }
\DoxyCodeLine{11616 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE)}}
\DoxyCodeLine{11617 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT\_NO\_TRY( "{}REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{11618 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11619 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{11620 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11621 }
\DoxyCodeLine{11622 \textcolor{preprocessor}{\#define INFO( msg ) INTERNAL\_CATCH\_INFO( "{}INFO"{}}, msg )}
\DoxyCodeLine{11623 \textcolor{preprocessor}{\#define WARN( msg ) INTERNAL\_CATCH\_MSG( "{}WARN"{}}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{11624 \textcolor{preprocessor}{\#define SCOPED\_INFO( msg ) INTERNAL\_CATCH\_INFO( "{}INFO"{}}, msg )}
\DoxyCodeLine{11625 \textcolor{preprocessor}{\#define CAPTURE( msg ) INTERNAL\_CATCH\_INFO( "{}CAPTURE"{}}, \#msg "{} := "{} << Catch::toString(msg) )}
\DoxyCodeLine{11626 \textcolor{preprocessor}{\#define SCOPED\_CAPTURE( msg ) INTERNAL\_CATCH\_INFO( "{}CAPTURE"{}}, \#msg "{} := "{} << Catch::toString(msg) )}
\DoxyCodeLine{11627 }
\DoxyCodeLine{11628 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{11629 \textcolor{preprocessor}{\#define TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11630 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11631 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11632 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11633 \textcolor{preprocessor}{\#define SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{11634 \textcolor{preprocessor}{\#define FAIL( ... ) INTERNAL\_CATCH\_MSG( "{}FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11635 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "{}FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11636 \textcolor{preprocessor}{\#define SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "{}SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11637 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11638 \textcolor{preprocessor}{\#define TEST\_CASE( name, description ) INTERNAL\_CATCH\_TESTCASE( name, description )}}
\DoxyCodeLine{11639 \textcolor{preprocessor}{    \#define TEST\_CASE\_METHOD( className, name, description ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, name, description )}}
\DoxyCodeLine{11640 \textcolor{preprocessor}{    \#define METHOD\_AS\_TEST\_CASE( method, name, description ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, name, description )}}
\DoxyCodeLine{11641 \textcolor{preprocessor}{    \#define REGISTER\_TEST\_CASE( method, name, description ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( method, name, description )}}
\DoxyCodeLine{11642 \textcolor{preprocessor}{    \#define SECTION( name, description ) INTERNAL\_CATCH\_SECTION( name, description )}}
\DoxyCodeLine{11643 \textcolor{preprocessor}{    \#define FAIL( msg ) INTERNAL\_CATCH\_MSG( "{}FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, msg )}
\DoxyCodeLine{11644 \textcolor{preprocessor}{    \#define FAIL\_CHECK( msg ) INTERNAL\_CATCH\_MSG( "{}FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{11645 \textcolor{preprocessor}{    \#define SUCCEED( msg ) INTERNAL\_CATCH\_MSG( "{}SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{11646 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11647 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE( "{}"{}}, "{}"{} )}
\DoxyCodeLine{11648 }
\DoxyCodeLine{11649 \textcolor{preprocessor}{\#define REGISTER\_REPORTER( name, reporterType ) INTERNAL\_CATCH\_REGISTER\_REPORTER( name, reporterType )}}
\DoxyCodeLine{11650 \textcolor{preprocessor}{\#define REGISTER\_LEGACY\_REPORTER( name, reporterType ) INTERNAL\_CATCH\_REGISTER\_LEGACY\_REPORTER( name, reporterType )}}
\DoxyCodeLine{11651 }
\DoxyCodeLine{11652 \textcolor{preprocessor}{\#define GENERATE( expr) INTERNAL\_CATCH\_GENERATE( expr )}}
\DoxyCodeLine{11653 }
\DoxyCodeLine{11654 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11655 }
\DoxyCodeLine{11656 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature )}}
\DoxyCodeLine{11657 }
\DoxyCodeLine{11658 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{11659 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_VARIADIC\_MACROS}}
\DoxyCodeLine{11660 \textcolor{preprocessor}{\#define SCENARIO( ... ) TEST\_CASE( "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11661 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{11662 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11663 \textcolor{preprocessor}{\#define SCENARIO( name, tags ) TEST\_CASE( "{}Scenario: "{}} name, tags )}
\DoxyCodeLine{11664 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, name, tags ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} name, tags )}
\DoxyCodeLine{11665 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11666 \textcolor{preprocessor}{\#define GIVEN( desc )    SECTION( std::string("{}   Given: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11667 \textcolor{preprocessor}{\#define WHEN( desc )     SECTION( std::string("{}    When: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11668 \textcolor{preprocessor}{\#define AND\_WHEN( desc ) SECTION( std::string("{}And when: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11669 \textcolor{preprocessor}{\#define THEN( desc )     SECTION( std::string("{}    Then: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11670 \textcolor{preprocessor}{\#define AND\_THEN( desc ) SECTION( std::string("{}     And: "{}}) + desc, "{}"{} )}
\DoxyCodeLine{11671 }
\DoxyCodeLine{11672 \textcolor{keyword}{using }\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{11673 }
\DoxyCodeLine{11674 \textcolor{comment}{// \#included from: internal/catch\_reenable\_warnings.h}}
\DoxyCodeLine{11675 }
\DoxyCodeLine{11676 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_REENABLE\_WARNINGS\_H\_INCLUDED}}
\DoxyCodeLine{11677 }
\DoxyCodeLine{11678 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{11679 \textcolor{preprocessor}{\#    ifdef \_\_ICC }\textcolor{comment}{// icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{11680 \textcolor{preprocessor}{\#        pragma warning(pop)}}
\DoxyCodeLine{11681 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{11682 \textcolor{preprocessor}{\#        pragma clang diagnostic pop}}
\DoxyCodeLine{11683 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{11684 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{11685 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{11686 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11687 }
\DoxyCodeLine{11688 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{11689 }

\end{DoxyCode}
